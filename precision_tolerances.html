<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="canonical" href="https://beancount.github.io/docs/precision_tolerances.html">
  <link rel="shortcut icon" href="img/favicon.ico">
  <title>Precision Tolerances - Beancount Documentation</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/theme_extra.css" />
  <link href="assets/_mkdocstrings.css" rel="stylesheet" />
  <link href="css/custom.css" rel="stylesheet" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Precision Tolerances";
    var mkdocs_page_input_path = "precision_tolerances.md";
    var mkdocs_page_url = "/docs/precision_tolerances.html";
  </script>
  
  <script src="js/jquery-2.1.1.min.js" defer></script>
  <script src="js/modernizr-2.8.3.min.js" defer></script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="index.html" class="icon icon-home"> Beancount Documentation</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="./search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="index.html">Index</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Outline</span></p>
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href="#">Documentation for Users</a>
    <ul class="current">
                <li class="toctree-l2"><a class="reference internal" href="command_line_accounting_in_context.html">Command Line Accounting in Context</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="the_double_entry_counting_method.html">The Double Entry Counting Method</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="installing_beancount.html">Installing Beancount</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="running_beancount_and_generating_reports.html">Running Beancount and Generating Reports</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="getting_started_with_beancount.html">Getting Started with Beancount</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="beancount_language_syntax.html">Beancount Language Syntax</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="beancount_options_reference.html">Beancount Options Reference</a>
                </li>
                <li class="toctree-l2 current"><a class="reference internal current" href="precision_tolerances.html">Precision Tolerances</a>
    <ul class="current">
    <li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#definitions">Definitions</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#tolerances-imprecision-in-balance-checks">Tolerances: Imprecision in Balance Checks</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#how-default-tolerances-are-determined">How Default Tolerances are Determined</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#balance-assertions-padding">Balance Assertions &amp; Padding</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#porting-existing-input">Porting Existing Input</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#interpolation-filling-in-with-round-numbers">Interpolation: Filling in with Round Numbers</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#precision-of-inferred-numbers">Precision of Inferred Numbers</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#saving-rounding-error">Saving Rounding Error</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#display-rounding-numbers-for-display">Display: Rounding Numbers for Display</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#computation-operations-at-finite-precision">Computation: Operations At Finite Precision</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#references">References</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#historical-notes">Historical Notes</a>
    </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="beancount_query_language.html">Beancount Query Language</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="beancount_cheat_sheet.html">Beancount Cheat Sheet</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="how_inventories_work.html">How Inventories Work</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="exporting_your_portfolio.html">Exporting Your Portfolio</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="tutorial_example.html">Tutorial & Example</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="beancount_history_and_credits.html">Beancount History and Credits</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="a_comparison_of_beancount_and_ledger_hledger.html">A Comparison of Beancount and Ledger Hledger</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="fetching_prices_in_beancount.html">Fetching Prices in Beancount</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="importing_external_data.html">Importing External Data</a>
                </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="#">Cookbooks & Examples</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="command_line_accounting_cookbook.html">Command Line Accounting Cookbook</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="trading_with_beancount.html">Trading with Beancount</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="stock_vesting_in_beancount.html">Stock Vesting in Beancount</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="sharing_expenses_with_beancount.html">Sharing Expenses with Beancount</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="how_we_share_expenses.html">How We Share Expenses</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="health_care_expenses.html">Health Care Expenses</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="calculating_portolio_returns.html">Calculating Portfolio Returns</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="tracking_medical_claims.html">Tracking Out-of-Network Medical Claims in Beancount</a>
                </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="#">Documentation for Developers</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="beancount_scripting_plugins.html">Beancount Scripting Plugins</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="beancount_design_doc.html">Beancount Design Doc</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="ledgerhub_design_doc.html">Ledgerhub Design Doc</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="external_contributions.html">External Contributions</a>
                </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="#">Enhancement Proposals & Discussions</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="a_proposal_for_an_improvement_on_inventory_booking.html">A Proposal for an Improvement on Inventory Booking</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="settlement_dates_in_beancount.html">Settlement Dates in Beancount</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="balance_assertions_in_beancount.html">Balance Assertions in Beancount</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="fund_accounting_with_beancount.html">Fund Accounting with Beancount</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="rounding_precision_in_beancount.html">Rounding Precision in Beancount</a>
                </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="#">Beancount 3</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="beancount_v3.html">Goals & Design</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="installing_beancount_v3.html">Installing Beancount</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="beancount_v3_dependencies.html">Dependencies</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="beangulp.html">Beangulp</a>
                </li>
    </ul>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">API reference</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="api_reference/index.html">beancount</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="api_reference/beancount.core.html">beancount.core</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="api_reference/beancount.loader.html">beancount.loader</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="api_reference/beancount.ops.html">beancount.ops</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="api_reference/beancount.parser.html">beancount.parser</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="api_reference/beancount.plugins.html">beancount.plugins</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="api_reference/beancount.scripts.html">beancount.scripts</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="api_reference/beancount.tools.html">beancount.tools</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="api_reference/beancount.utils.html">beancount.utils</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Beancount Documentation</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
    
      
        
          <li>Outline &raquo;</li>
        
      
        
          <li>Documentation for Users &raquo;</li>
        
      
    
    <li>Precision Tolerances</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>

          <div role="main">
            <div class="section">
              
                <h1 id="beancount-precision-tolerances">Beancount Precision &amp; Tolerances<a id="title"></a><a class="headerlink" href="#beancount-precision-tolerances" title="Permanent link"></a></h1>
<p><a href="http://plus.google.com/+MartinBlais"><u>Martin Blais</u></a>, May 2015, Updated May 2025</p>
<p><a href="http://furius.ca/beancount/doc/tolerances"><u>http://furius.ca/beancount/doc/tolerances</u></a></p>
<p><em>This document describes how Beancount handles the limited precision of numbers in transaction balance checks and balance assertions. It also documents rounding that may occur in inferring numbers automatically.</em></p>
<h2 id="introduction">Introduction<a id="introduction"></a><a class="headerlink" href="#introduction" title="Permanent link"></a></h2>
<p>Beancounts stores all of its numbers in decimal form, that is, the digits you enter in the input file are <em>precisely</em> represented in the computer's memory. We do not use floating-point numbers. The reasons for this are presented elsewhere, but essentially it is to allow us to perform exact sums without any rounding error.</p>
<p>There are four areas where the number of fractional digits in these decimal numbers become involved in Beancount. This section discusses these:</p>
<ul>
<li>
<p><strong>Tolerances:</strong> When we perform balance check calculations, we must account for the precision at which the numbers are stored, e.g., 1 cent for US dollars. Because currencies are stored by institutions at a limited precision, this means that rounding occurs naturally in balances. We must account for this properly in order to allow for this rounding yet detect imbalances that would result from errors larger than this.</p>
</li>
<li>
<p><strong>Interpolation</strong>: Beancount syntax allows users to leave out some numbers to be automatically filled in for convenience. When computing those missing numbers, we want to use the customary precision for that currency so that when the numbers are displayed they have a natural value that matches what an institution might calculate themselves.</p>
</li>
<li>
<p><strong>Display</strong>: When displaying numbers, every currency has a customary number of digits that are used to represent its amounts. If the numbers we're displaying are the result of a division we need to perform rounding in order to avoid showing a large number of irrelevant digits to the user (which is undesirable).</p>
</li>
<li>
<p><strong>Computation</strong>: When performing computations, decimal numbers aren't limited in the way that floating-point representations naturally are from their hardware implementations. We specify the precision of calculations that result in a large number of fractional digits (such as the division operation).</p>
</li>
</ul>
<p>This document discusses each of those issues in turn, how Beancount attempts to automatically figure out good defaults, and how to specify configuration to control the precision and tolerances it uses.</p>
<h3 id="definitions">Definitions<a id="definitions"></a><a class="headerlink" href="#definitions" title="Permanent link"></a></h3>
<p>"<strong>Precision</strong>": In the context of Beancount, the word "precision" has historically been abused a bit by its original author. In this document, we will take "precision" to mean either (a) the number of fractional digits to represent a decimal number, e.g., 12.356 uses a precision of "3", or (b) an example of the smallest number for that precision, e.g., a precision of "3" is input as "0.01" for configuration purposes.</p>
<p>"<strong>Tolerance</strong>" is just a number that will be used directly, such as "0.0005". It is not subject to the "tolerance_multiplier" mentioned below (you can say that the "tolerance_multiplier" adjusts a "precision" number).</p>
<h2 id="tolerances-imprecision-in-balance-checks">Tolerances: Imprecision in Balance Checks<a id="tolerances-imprecision-in-balance-checks"></a><a class="headerlink" href="#tolerances-imprecision-in-balance-checks" title="Permanent link"></a></h2>
<p>Beancount automatically enforces that the amounts on the Postings of Transactions entered in an input file sum up to zero. In order for Beancount to verify this in a realistic way, it must tolerate a small amount of imprecision. This is because Beancount lets you <strong>replicate what happens in real world account transactions</strong>, and in the real world, institutions round amounts up or down for practical reasons.</p>
<p>Here’s an example: Consider the following transaction which consists in a transfer between two accounts denominated in different currencies (US dollars and Euros):</p>
<pre><code>2015-05-01 * "Transfer from secret Swiss bank account"
  Assets:CH:SBS:Checking   -9000.00 CHF
  Assets:US:BofA:Checking   9643.82 USD @ 0.93324 CHF
</code></pre>
<p>In this example, the exchange rate used was 0.93324 USD/CHF, that is, 0.93324 Swiss Francs per US dollar. This rate was quoted to 5 digits of precision by the bank. A full-precision conversion of 9000.00 CHF / 0.93324 CHF yields <strong>9643.82152501...</strong> USD. Similarly, converting the US dollars to Francs using the given rate yields an imprecise result as well: 9643.82 x 0.93324 = <strong>8999.9985768…</strong> .</p>
<p>Here is another example where this type of rounding may occur: A transaction for a fractional number of shares of a mutual fund:</p>
<pre><code>2013-04-03 * "Buy Mutual Fund - Price as of date based on closing price"
  Assets:US:Vanguard:RGAGX       10.22626 RGAGX {37.61 USD}
  Assets:US:Vanguard:Cash         -384.61 USD
</code></pre>
<p>Once again, rounding occurs in this transaction: not only the Net Asset Value of the fund is rounded to its nearest penny value ($37.61), but the number of units is also rounded and accounted for by Vanguard with a fixed number of digits (10.22626 units of VPMBX). And the balance of the entire transaction needs to tolerate some imprecision, whether you compute the value of the shares (10.22626 x $37.61 = <strong>$384.6096386</strong>) or whether you compute the number of shares from the desired dollar amount of the contribution ($384.61 / $37.61 = <strong>10.2262696091</strong>).</p>
<p>From Beancount’s point-of-view, both of the examples above are balancing transactions. Clearly, if we are to try to represent and reproduce the transactions of external accounts to our input file, there needs to be some tolerance in the balance verification algorithm.</p>
<h3 id="how-default-tolerances-are-determined">How Default Tolerances are Determined<a id="how-default-tolerances-are-determined"></a><a class="headerlink" href="#how-default-tolerances-are-determined" title="Permanent link"></a></h3>
<p>Beancount attempts to derive the tolerance for each transaction <strong>automatically</strong>, from the input, for each Transaction <strong>in isolation</strong><sup id="fnref:1"><a class="footnote-ref" href="#fn:1">1</a></sup>. Let us inspect our last example again:</p>
<pre><code>2013-04-03 * "Buy Mutual Fund - Price as of date based on closing price"
  Assets:US:Vanguard:RGAGX       10.22626 RGAGX {37.61 USD}
  Assets:US:Vanguard:Cash         -384.61 USD
</code></pre>
<p>In this transaction, Beancount will infer the tolerance of</p>
<ul>
<li>
<p>RGAGX at 5 fractional digits, that is, <strong>0.000005 RGAGX</strong>, and</p>
</li>
<li>
<p>USD at 2 fractional digits, that is, <strong>0.005 USD</strong>.</p>
</li>
</ul>
<p>Note that the tolerance used is <strong>a fraction (typically half) of the last digit of precision</strong> provided by the user. This is entirely inferred from the input, without having to fetch any global tolerance declaration. Also note how the tolerance is calculated <strong>separately for each currency</strong>.</p>
<p>Observe that although we are inferring a tolerance for units of RGAGX, it is actually not used in the balancing of this transaction, because the “weight” of the first posting is in USD (10.22626 x 37.61 = 384.6096386 USD).</p>
<p>So what happens here? The weights of each postings are calculated:</p>
<ul>
<li>
<p>384.6096386 USD for the first posting</p>
</li>
<li>
<p>-384.61 USD for the second</p>
</li>
</ul>
<p>These are summed together, by currency (there are only USD units in the weights of this transaction) which results in a <em>residual</em> value of -0.0003614 USD. This value is compared to the tolerance for units of USD: |-0.0003614| &lt; 0.005, and this transaction balances.</p>
<h4 id="prices-and-costs">Prices and Costs<a id="prices-and-costs"></a><a class="headerlink" href="#prices-and-costs" title="Permanent link"></a></h4>
<p>For the purpose of inferring the tolerance to be used, the price and cost amounts declared on a transaction’s Postings <strong>are ignored</strong>. This makes sense if you consider that these are usually specified at a higher precision than the base amounts of the postings—and sometimes this extra precision is necessary to make the transaction balance. These should not be used in setting the tolerances for the whole transaction.</p>
<p>For example, in the following transaction:</p>
<pre><code>1999-09-30 * "Vest ESPP - Bought at discount: 18.5980 USD"
     Assets:US:Schwab:ESPP            54 HOOL {21.8800 USD}
     Income:CA:ESPP:PayContrib  -1467.84 CAD @ 0.6842 USD
     Income:CA:ESPP:Discount     -259.03 CAD @ 0.6842 USD
</code></pre>
<p>The only tolerance inferred here is 0.005 for CAD. (54 HOOL does not yield anything in this case because it is integral; the next section explains this). There is no tolerance inferred for USD, neither from the cost from the first posting (21.8800 USD), nor from the prices of the remaining postings (0.6842 USD).</p>
<h4 id="integer-amounts">Integer Amounts<a id="integer-amounts"></a><a class="headerlink" href="#integer-amounts" title="Permanent link"></a></h4>
<p>For integer amounts in the input, the tolerance is <strong>not</strong> inferred to 0.5, that is, this should fail to balance:</p>
<pre><code>2013-04-03 * "Buy Mutual Fund - Price as of date based on closing price"
  Assets:US:Vanguard:RGAGX    10.21005 RGAGX {37.61 USD}
  Assets:US:Vanguard:Cash         -384 USD
</code></pre>
<p>In other words, integer amounts do not contribute a number of digits to the determination of the tolerance for their currency.</p>
<p>By default, the tolerance used on amounts without fractional digits is <strong>zero</strong>. So in this example, because we cannot infer the precision of USD numbers (recall that the cost is ignored), this transaction will fail to balance, because its residual is non-zero (|-0.0003614| &gt; 0).</p>
<p>You can customize what the default value inferred for tolerance should be for each currency separately and for any currency as well (see the configuration section below on how to do this).</p>
<p>(This treatment of integer amounts implies that the <strong>maximum precision</strong> that one can specify just by inputting numbers is 0.05 units of the currency; for example, by providing a number such as 10.7 as input<sup id="fnref:2"><a class="footnote-ref" href="#fn:2">2</a></sup> the precision is 0.1 and we multiply by the tolerance multiplier of 0.5 to obtain 0.05. On the other hand, the settings for the default tolerance to use allows specifying arbitrary numbers.)</p>
<h4 id="resolving-ambiguities">Resolving Ambiguities<a id="resolving-ambiguities"></a><a class="headerlink" href="#resolving-ambiguities" title="Permanent link"></a></h4>
<p>A case that presents itself rarely is one where multiple different precisions are being input for the same currency. In this case, the <strong>largest</strong> (coarsest) of the inferred input tolerances is used.</p>
<p>For example, if we wanted to track income to more than pennies, we might write this:</p>
<pre><code>1999-08-20 * "Sell"
  Assets:US:BRS:ESPP           -81 HOOL {26.3125 USD}
  Assets:US:BRS:Cash       2141.36 USD
  Expenses:Financial:Fees     0.08 USD
  Income:CA:ESPP:PnL       -10.125 USD
</code></pre>
<p>The amounts we have for USD in this case are 2141.36, 0.08 and -10.125, which infer tolerances of either 0.005 or 0.0005. We select the coarsest amount: this transaction tolerates an imprecision of 0.005 USD.</p>
<h4 id="configuration-for-default-tolerances">Configuration for Default Tolerances<a id="configuration-for-default-tolerances"></a><a class="headerlink" href="#configuration-for-default-tolerances" title="Permanent link"></a></h4>
<p>When a transaction’s numbers do not provide enough information to infer a tolerance <em>locally</em>, we fall back to some default tolerance value. As seen in previous examples, this may occur either because (a) the numbers associated with the currency we need it for are integral, or (b) sufficient numbers are simply absent from the input.</p>
<p>By default, this default tolerance is <strong>zero</strong> for all currencies. This can be specified with an option, like this:</p>
<pre><code>option "inferred_tolerance_default" "*:0.001"
</code></pre>
<p>The default tolerance can be further refined for each currency involved, by providing the currency to the option, like this:</p>
<pre><code>option "inferred_tolerance_default" "USD:0.003"
</code></pre>
<p>If provided, the currency-specific tolerance will be used over the global value.</p>
<p>The general form for this option is:</p>
<pre><code>option "inferred_tolerance_default" "&lt;currency&gt;:&lt;tolerance&gt;"
</code></pre>
<p>Just to be clear: this option is <em>only</em> used when the tolerance cannot be inferred. If you have overly large rounding errors and the numbers in your transactions do infer some tolerance value, this value will be ignored (e.g., setting it to a larger number to try to address that fix will not work). If you need to loosen up the tolerance, see the “<code>tolerance_multiplier</code>” in the next section.</p>
<p><em>(Note: I’ve been considering dedicating a special meta-data field to the Commodity directive for this, but this would break from the invariant that meta-data is only there to be used by users and plugins, so I’ve refrained so far.)</em></p>
<h4 id="tolerance-multiplier">Tolerance Multiplier<a id="tolerance-multiplier"></a><a class="headerlink" href="#tolerance-multiplier" title="Permanent link"></a></h4>
<p>We’re shown previously that when the tolerance value isn’t provided explicitly, that it is inferred from the numbers on the postings. By default, the smallest digit found on those numbers is divided by half to obtain the tolerance because we assume that the institutions which we’re reproducing the transactions apply rounding and so the error should never be more than half.</p>
<p>But in reality, you might find that the rounding errors sometimes exceed this value. For this reason, we provide an option to set the multiplier for the inferred tolerance:</p>
<pre><code>option "tolerance_multiplier" "0.6"
</code></pre>
<p>This value overrides the default multiplier of <strong>0.5</strong>. In this example, for a transaction with postings only with values such as 24.45 CHF, the inferred tolerance for CHF would be +/- 0.012 CHF.</p>
<p>Note: I believe that you should probably never have to change to change this (and I use the default myself), but it's provided in case I'm wrong about this.</p>
<h4 id="inferring-tolerances-from-cost">Inferring Tolerances from Cost<a id="inferring-tolerances-from-cost"></a><a class="headerlink" href="#inferring-tolerances-from-cost" title="Permanent link"></a></h4>
<p>There is also a feature that expands the maximum tolerance inferred on transactions to include values on cost currencies inferred by postings held at-cost or converted at price. Those postings can imply a tolerance value by multiplying the smallest digit of the unit by the cost or price value and taking half of that value.</p>
<p>For example, if a posting has an amount of "2.345 RGAGX {45.00 USD}" attached to it, it implies a tolerance of 0.001 x 45.00 / 2 = 0.045 USD and the sum of all such possible rounding errors is calculate for all postings held at cost or converted from a price, and the resulting tolerance is added to the list of candidates used to figure out the tolerance we should use for the given commodity (we use the maximum value of all the inferred tolerances).</p>
<p>You turn on the feature like this:</p>
<pre><code>option "infer_tolerance_from_cost" "TRUE"
</code></pre>
<p>Enabling this flag only makes the tolerances potentially wider, never smaller.</p>
<h3 id="balance-assertions-padding">Balance Assertions &amp; Padding<a id="balance-assertions-padding"></a><a class="headerlink" href="#balance-assertions-padding" title="Permanent link"></a></h3>
<p>There are a few other places where approximate comparisons are needed. Balance assertions also compare two numbers:</p>
<pre><code>2015-05-08 balance Assets:Investments:RGAGX       4.271 RGAGX
</code></pre>
<p>This asserts that the accumulated balance for this account has 4.271 units of RGAGX, plus or minus 0.001 RGAGX. So accumulated values of 4.270 RGAGX up to 4.272 RGAGX will check as asserted.</p>
<p>The tolerance is inferred automatically to be 1 unit of the least significant digit of the number on the balance assertion. If you wanted a looser assertion, you could have declared:</p>
<pre><code>2015-05-08 balance Assets:Investments:RGAGX       4.27 RGAGX
</code></pre>
<p>This assertion would accept values from 4.26 RGAGX to 4.28 RGAGX.</p>
<p>Note that the inferred tolerances are also expanded by the inferred tolerance multiplier discussed above.</p>
<h4 id="tolerances-that-trigger-padding">Tolerances that Trigger Padding<a id="tolerances-that-trigger-padding"></a><a class="headerlink" href="#tolerances-that-trigger-padding" title="Permanent link"></a></h4>
<p>Pad directives automatically insert transactions to bring account balances in-line with a subsequent balance assertion. The insertion only triggers if the balance differs from the expected value, and the tolerance for this to occur behaves exactly the same as for balance assertions.</p>
<h4 id="explicit-tolerances-on-balance-assertions">Explicit Tolerances on Balance Assertions<a id="explicit-tolerances-on-balance-assertions"></a><a class="headerlink" href="#explicit-tolerances-on-balance-assertions" title="Permanent link"></a></h4>
<p>Beancount supports the specification of an explicit tolerance amount, like this:</p>
<pre><code>2015-05-08 balance Assets:Investments:RGAGX       4.271 ~ 0.01 RGAGX
</code></pre>
<p>This feature was added because of some observed peculiarities in Vanguard investment accounts whereby rounding appears to follow odd rules and balances don’t match.</p>
<h3 id="porting-existing-input">Porting Existing Input<a id="porting-existing-input"></a><a class="headerlink" href="#porting-existing-input" title="Permanent link"></a></h3>
<p>The inference of tolerance values from the transaction’s numbers is generally good enough to keep existing files working without changes. There may be new errors appearing in older files once we process them with the method described in this document, but they should either point to previously undetected errors in the input, or be fixable with simple addition of a suitable number of digits.</p>
<p>As a testimony, porting the author’s very large input file has been a relatively painless process that took less than 1 hour.</p>
<p>In order to ease the transition, you will probably want to change the default tolerance for all currencies to match the previous value that Beancount had been using, like this:</p>
<pre><code>option "inferred_tolerance_default" "*:0.005"
</code></pre>
<p>I would recommend you start with this and fix all errors in your file, then proceed to removing this and fix the rest of errors. This should make it easier to adapt your file to this new behavior.</p>
<p>As an example of how to fix a new error… converting this newly failing transaction from the Integer Amounts section:</p>
<pre><code>2013-04-03 * "Buy Mutual Fund - Price as of date based on closing price"
  Assets:US:Vanguard:RGAGX    10.21005 RGAGX {37.61 USD}
  Assets:US:Vanguard:Cash         -384 USD
</code></pre>
<p>by inserting zero’s to provide a locally inferred value like this:</p>
<pre><code>2013-04-03 * "Buy Mutual Fund - Price as of date based on closing price"
  Assets:US:Vanguard:RGAGX    10.21005 RGAGX {37.61 USD}
  Assets:US:Vanguard:Cash      -384.00 USD
</code></pre>
<p>is sufficient to silence the balance check.</p>
<h2 id="interpolation-filling-in-with-round-numbers">Interpolation: Filling in with Round Numbers<a id="interpolation-filling-in-with-round-numbers"></a><a class="headerlink" href="#interpolation-filling-in-with-round-numbers" title="Permanent link"></a></h2>
<p>Beancount allows users to leave out some numbers to be filled in, or <em>interpolated</em>. For example, the value for the profit here is left for it to fill in:</p>
<pre><code>2013-04-03 * "Buy Mutual Fund - Price as of date based on closing price"
  Assets:US:Vanguard:RGAGX       -10.22626 RGAGX {37.61 USD}
  Assets:US:Vanguard:Cash         645.61 USD
  Income:US:Vanguard:Profit
</code></pre>
<p>While Beancount could fill in the precise difference, in practice the profit/loss here would be calculated by brokers at two digits of precision as $216.00, even though the unrounded number would be $261.0003614. Beancount does <em>rounding</em> of numbers at a specific precision, and that precision also depends on the currency the amount represents. We would insert "<strong><code>216.00 USD</code></strong>" here.</p>
<h3 id="precision-of-inferred-numbers">Precision of Inferred Numbers<a id="precision-of-inferred-numbers"></a><a class="headerlink" href="#precision-of-inferred-numbers" title="Permanent link"></a></h3>
<p>Beancount is able to infer some missing numbers in the input. For example, the second posting in this transaction is “interpolated” automatically by Beancount:</p>
<pre><code>2014-05-06 * "Buy mutual fund"
  Assets:Investments:RGXGX        4.27 RGAGX {53.21 USD}
  Assets:Investments:Cash
</code></pre>
<p>The calculated amount to be inserted from the first posting is -227.2067 USD. Now, you might ask, to which precision is it inserted at? Does it insert 227.2067 USD at the full precision or does the number get rounded to a penny, e.g. 227.21 USD?</p>
<p>It depends on the tolerance inferred for that currency. In this example, no tolerance is able to get inferred (there is no USD amount provided other than the cost amount, which is ignored for the purpose of inferring the tolerance), so we have to defer to the default tolerance.</p>
<p>If the default tolerance is not overridden in the input file—and therefore is zero—the full precision will be used; no rounding occurs. This will result in the following transaction:</p>
<pre><code>2014-05-06 * "Buy mutual fund"
  Assets:Investments:RGXGX        4.27 RGAGX {53.21 USD}
  Assets:Investments:Cash    -227.2067 USD
</code></pre>
<p>Note that if a tolerance could be inferred from other numbers on that transaction, it would be used for rounding, such as in this example where the Cash posting is rounded to two digits because of the 9.95 USD number on the Commissions posting:</p>
<pre><code>2014-05-06 * "Buy mutual fund"
  Assets:Investments:RGXGX        4.27 RGAGX {53.21 USD}
  Expenses:Commissions            9.95 USD
  Assets:Investments:Cash      -237.16 USD
</code></pre>
<p>However, if no inference is possible, and the default tolerance for USD is set to 0.001, the number will be quantized to 0.001 before insertion, that is, 227.207 USD will be stored:</p>
<pre><code>option "default_tolerance" "USD:0.001"

2014-05-06 * "Buy mutual fund"
  Assets:Investments:RGXGX        4.27 RGAGX {53.21 USD}
  Assets:Investments:Cash     -227.207 USD
</code></pre>
<p>Finally, if you enabled the accumulation of rounding error, the posting’s amount will reflect the correct residual, taking into account the rounded amount that was automatically inserted:</p>
<pre><code>option "default_tolerance" "USD:0.01"
option "account_rounding" "Equity:RoundingError"

2014-05-06 * "Buy mutual fund"
  Assets:Investments:RGXGX        4.27 RGAGX {53.21 USD}
  Assets:Investments:Cash     -227.207 USD
  Equity:RoundingError          0.0003 USD
</code></pre>
<h3 id="saving-rounding-error">Saving Rounding Error<a id="saving-rounding-error"></a><a class="headerlink" href="#saving-rounding-error" title="Permanent link"></a></h3>
<p>As we saw previously, transactions don’t have to balance exactly, they allow for a small amount of imprecision. This bothers some people. If you would like to track and measure the residual amounts allowed by the tolerances, Beancount offers an option to automatically insert postings that will make each transaction balance exactly.</p>
<p>You enable the feature like this:</p>
<pre><code>option "account_rounding" "Equity:RoundingError"
</code></pre>
<p>This tells Beancount to insert postings to compensate for the rounding error to an “<code>Equity:RoundingError</code>” account. For example, with the feature enabled, the following transaction:</p>
<pre><code>2013-02-23 * "Buying something"
  Assets:Invest     1.245 RGAGX {43.23 USD}
  Assets:Cash      -53.82 USD
</code></pre>
<p>will be automatically transformed into this:</p>
<pre><code>2013-02-23 * "Buying something"
  Assets:Invest             1.245 RGAGX {43.23 USD}
  Assets:Cash              -53.82 USD
  Equity:RoundingError   -0.00135 USD
</code></pre>
<p>You can verify that this transaction balances exactly. If the transaction already balances exactly (this is the case for most transactions) no posting is inserted. Note that rounding errors inserted in this way <strong>are not rounded like other interpolated numbers</strong>.</p>
<p>Finally, if you require that all accounts be opened explicitly, you should remember to declare the rounding account in your file at an appropriate date, like this:</p>
<pre><code>2000-01-01 open Equity:RoundingError
</code></pre>
<h2 id="display-rounding-numbers-for-display">Display: Rounding Numbers for Display<a id="display-rounding-numbers-for-display"></a><a class="headerlink" href="#display-rounding-numbers-for-display" title="Permanent link"></a></h2>
<p>When displaying numbers, it's really incongruous to witness a number that is the result of a division with an unusually large number of digits<sup id="fnref:3"><a class="footnote-ref" href="#fn:3">3</a></sup>. For example, a cost amount rendered as "<code>134.2374736427639678237437 USD</code>" is not useful to the reader, the extra digits are small and not very meaningful quantities; we would much rather present "<code>134.24 USD</code>". Thus, the numbers must be rounded to a certain precision.</p>
<p>The number of digits to use to render those numbers depend on a few things:</p>
<ul>
<li>
<p><strong>The currency that the numbers represent.</strong> Dollars typically use a resolution of 1 penny ($0.01) and a precision of 2. Japanese Yen typically use integers (1 JPY is a small value). Mutual fund shares are typically using at least 3 digits because one share may represent a relatively large amount. Exchange rates may use as many as 5 digits of precision (e.g., USD/JPY).</p>
</li>
<li>
<p><strong>The context for the numbers.</strong> When representing the cost of a single unit of another commodity, it is sometimes the case that the precision at which we want this cost differs from the common precision used for total values of that number.</p>
</li>
</ul>
<p>As of 2025, there is a new configuration option that allows you to specify the intended precision of a particular currency by example, like this:</p>
<pre><code>option "display_precision" "USD:0.01"
option "display_precision" "AUD:0.01"
</code></pre>
<h2 id="computation-operations-at-finite-precision">Computation: Operations At Finite Precision<a id="computation-operations-at-finite-precision"></a><a class="headerlink" href="#computation-operations-at-finite-precision" title="Permanent link"></a></h2>
<p>Finally, when computations occur on <a href="https://en.wikipedia.org/wiki/Decimal_data_type"><u>decimal numbers</u></a>, rounding must occur. All numbers in Beancount are represented internally in decimal form.</p>
<p>This is a topic people who haven't studied computer science may not be familiar with, but an important one. The vast majority of the time computers use floating-point numbers which are binary approximations of real numbers. Rounding occurs naturally due to the limited number of digits available in these representations. To represent and compute with decimal numbers, we use a software implementation that is not subject to the limitation of the hardware and thus is able to represent computations at an arbitrary precision (at a cost—it's a fair bit slower).</p>
<p>With decimal numbers, for some operations resulting in a large number of fractional decimal digits, we must decide which precision to round the results to (lest we spend a lot of space representing very small digits).</p>
<p>Calculations that result in a large number of fractional digits are carried out to 28 decimal places (the default precision from the context of Python’s IEEE decimal implementation). This is plenty sufficient, because the method we propose above rarely trickles these types of numbers throughout the system: the tolerances allows us to post the precise amounts declared by users, and only automatically derived prices and costs will possibly result in precisions calculated to an unrealistic number of digits that could creep into aggregations in the rest of the system.</p>
<p>See the <a href="https://docs.python.org/3/library/decimal.html"><u>Decimal fixed-point and floating-point arithmetic</u></a> and <a href="http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html#689"><u>What Every Computer Scientist Should Know About Floating-Point Arithmetic</u></a> documents for a more thorough discussion of this.</p>
<h2 id="references">References<a id="references"></a><a class="headerlink" href="#references" title="Permanent link"></a></h2>
<p>The <a href="rounding_precision_in_beancount.html"><u>original proposal</u></a> that led to this implementation can be <a href="rounding_precision_in_beancount.html"><u>found here</u></a>. In particular, the proposal highlights on the other systems have attempted to deal with this issue. There are also <a href="https://groups.google.com/forum/#!msg/ledger-cli/m-TgILbfrwA/YjkmOM3LHXIJ"><u>some discussions</u></a> on the mailing-list dedicated to this topic.</p>
<p>Note that for the longest time, Beancount used a fixed tolerance of 0.005 across all currencies. This was eliminated once the method described in this document was implemented.</p>
<p>Also, for Balance and Pad directives, there used to be a “tolerance” option that was set by default to 0.015 of any units. This option has been deprecated with the merging of the changes described in this document.</p>
<h2 id="historical-notes">Historical Notes<a id="historical-notes"></a><a class="headerlink" href="#historical-notes" title="Permanent link"></a></h2>
<p>Here’s an overview of the status of numbers rendering in Beancount as of March 2016, <a href="https://groups.google.com/d/msg/beancount/frfN1zc6TEc/d5OjuDnREgAJ"><u>from the mailing-list</u></a>:</p>
<blockquote>
<p>First, it's important to realize how these numbers are represented in memory. They are using the Decimal representation which beyond being able to accurately representing decimal numbers (as opposed to the approximation that binary floats provides) also contains a specific precision. That is, the number 2.00 is represented differently than the numbers 2.0 and 2.000. The numbers "remember" which precision they are represented up to. This is important. When I say rendering the numbers to their "natural precision" I mean the precision with which they are represented, i.e., 2.0 renders as "2.0", 2.000 renders as "2.000".</p>
<p>Then, there are two DISTINCT topics: (1) tolerances, and (2) precision.</p>
</blockquote>
<ul>
<li>
<p>"Tolerances" are values used to determine how much imprecision is acceptable in balancing transactions. This is used in the verification stage, to determine how much looseness to allow. It should not affect how numbers are rendered.</p>
</li>
<li>
<p>"Precision" is perhaps a bit of a misnomer: By that I'm referring to is how many digits the numbers are to be rendered with.</p>
</li>
</ul>
<blockquote>
<p>Once upon a time - after the shell was already written - these concepts weren't well defined in Beancount and I wasn't dealing with these things consistently. At some point it became clear what I needed to do and I created a class called "DisplayContext" which could contain appropriate settings for rendering the precision of numbers for each currency (each currency tends to have its own most common rendering precision, e.g. two digits for USD, one digit for MXN, no digits for JPY and in reports we're typically fine rounding the actual numbers to that precision). So an instance of this DisplayContext is automatically instantiated in the parser and in order to avoid the user having to set these values manually - for Beancount to "do the right thing" by default - <a href="https://github.com/beancount/beancount/blob/master/beancount/core/display_context.py"><u>it is able to accumulate</u></a> the numbers seen and to deduce the most common and maximum number of digits used from the input, and to use that as the default number of digits for rendering numbers. The most common format/number of digits is used to render the number of units, and the maximum number of digits seen is used to render costs and prices. In addition, this class also has capabilities for aligning to the decimal dot and to insert commas on thousands as well. It separates the control of the formatting from the numbers themselves.</p>
<p>MOST of the code that renders numbers uses the DisplayContext (via the to_string() methods) to convert the numbers into strings, such as the web interface and explicit text reports. But NOT ALL... there's a bit of HISTORY here... the SQL shell uses <a href="https://github.com/beancount/beancount/blob/master/beancount/query/query_render.py"><u>some old special-purpose code</u></a> to render numbers that I never bothered to convert to the DisplayContext class. There's a <a href="https://github.com/beancount/beancount/blob/master/TODO"><u>TODO item</u></a> for it. It needs to get converted at some point, but I've neglected doing this so far because I have much bigger plans for the SQL query engine that involve a full rewrite of it with many improvements and I figured I'd do that then. If you recall, the SQL query engine was a prototype, and actually it works, but it is not well covered by unit tests. My purpose with it was to discover through usage what would be useful and to then write a v2 of it that would be much better.</p>
<p>Now, about that PRINT command... this is not intended as a reporting tool. The printer's purpose is to print input that accurately represents the content of the transactions. In order to do this, it needs to render the numbers at their "natural" precision, so that when they get read back in, they parse into the very same number, that is, with the same number of digits (even if zeros). For this reason, the PRINT command does not attempt to render using the DisplayContext instance derived from the input file - this is on purpose. I could change that, but then round-trip would break: the rounding resulting from formatting using the display context may output transactions which don't balance anymore.</p>
<p>As you can see, it's not an obvious topic... Hopefully this should allow you to understand what comes out of Beancount in terms of the precision of the numbers it renders.</p>
<p>Note: "default_tolerances" has been renamed to "inferred_tolerance_default" recently because the name was too general and confusing. Old name will work but generate a warning.</p>
<p>I just noticed from your comments and some grepping around that the "render_commas" option is not used anymore. I'm not sure how that happened, but I'll go ad fix that right away and set the default value of the DisplayContext derived from the input.</p>
<p>I should probably also convert the SQL shell rendering to use the display context regardless of future plans, so that it renders consistently with all the rest. Not sure I can do that this weekend, but I'll log a ticket, <a href="https://github.com/beancount/beancount/issues/105"><u>here</u></a>.</p>
<p>I hope this helps. You're welcome to ask questions if the above isn't clear. I'm sorry if this isn't entirely obvious... there's been a fair bit of history there and there's a lot of code. I should review the naming of options, I think the tolerance options all have "tolerance" in their name, but there aren't options to override the rendering and when I add them they should all have a common name as well.</p>
</blockquote>
<p>As of May 2025, the configuration settings for tolerances and precision is under review. This has been a pain point for a very long time.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>This stands in contrast to Ledger which attempts to infer the precision based on other transactions recently parsed in the file, in file order. This has the unfortunate effect of creating “cross-talk” between the transactions in terms of what precision can be used.&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>Note that due to the way Beancount represents numbers internally, it is also not able to distinguish between “230” and “230.”; these parse into the same representation for Beancount. Therefore, we are not able to use that distinction in the input to support a precision of 0.5.&#160;<a class="footnote-backref" href="#fnref:2" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>Except for debugging. During debugging we should display the full value with no rounding.&#160;<a class="footnote-backref" href="#fnref:3" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
</ol>
</div>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="beancount_query_language.html" class="btn btn-neutral float-right" title="Beancount Query Language">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="beancount_options_reference.html" class="btn btn-neutral" title="Beancount Options Reference"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="beancount_options_reference.html" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="beancount_query_language.html" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '.';</script>
    <script src="js/theme_extra.js" defer></script>
    <script src="js/theme.js" defer></script>
      <script src="search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
