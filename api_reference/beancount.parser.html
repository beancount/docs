<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="canonical" href="https://beancount.github.io/docs/api_reference/beancount.parser.html">
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>beancount.parser - Beancount Documentation</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link href="../assets/_mkdocstrings.css" rel="stylesheet" />
  <link href="../css/custom.css" rel="stylesheet" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "beancount.parser";
    var mkdocs_page_input_path = "api_reference/beancount.parser.md";
    var mkdocs_page_url = "/docs/api_reference/beancount.parser.html";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="../index.html" class="icon icon-home"> Beancount Documentation</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../index.html">Index</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Outline</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="#">Documentation for Users</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../command_line_accounting_in_context.html">Command Line Accounting in Context</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../the_double_entry_counting_method.html">The Double Entry Counting Method</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../installing_beancount.html">Installing Beancount</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../running_beancount_and_generating_reports.html">Running Beancount and Generating Reports</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../getting_started_with_beancount.html">Getting Started with Beancount</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../beancount_language_syntax.html">Beancount Language Syntax</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../beancount_options_reference.html">Beancount Options Reference</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../precision_tolerances.html">Precision Tolerances</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../beancount_query_language.html">Beancount Query Language</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../beancount_cheat_sheet.html">Beancount Cheat Sheet</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../how_inventories_work.html">How Inventories Work</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../exporting_your_portfolio.html">Exporting Your Portfolio</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../tutorial_example.html">Tutorial & Example</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../beancount_history_and_credits.html">Beancount History and Credits</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../a_comparison_of_beancount_and_ledger_hledger.html">A Comparison of Beancount and Ledger Hledger</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../fetching_prices_in_beancount.html">Fetching Prices in Beancount</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../importing_external_data.html">Importing External Data</a>
                </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="#">Cookbooks & Examples</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../command_line_accounting_cookbook.html">Command Line Accounting Cookbook</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../trading_with_beancount.html">Trading with Beancount</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../stock_vesting_in_beancount.html">Stock Vesting in Beancount</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../sharing_expenses_with_beancount.html">Sharing Expenses with Beancount</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../how_we_share_expenses.html">How We Share Expenses</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../health_care_expenses.html">Health Care Expenses</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../calculating_portolio_returns.html">Calculating Portfolio Returns</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../tracking_medical_claims.html">Tracking Out-of-Network Medical Claims in Beancount</a>
                </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="#">Documentation for Developers</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../beancount_scripting_plugins.html">Beancount Scripting Plugins</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../beancount_design_doc.html">Beancount Design Doc</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../ledgerhub_design_doc.html">Ledgerhub Design Doc</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../external_contributions.html">External Contributions</a>
                </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="#">Enhancement Proposals & Discussions</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../a_proposal_for_an_improvement_on_inventory_booking.html">A Proposal for an Improvement on Inventory Booking</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../settlement_dates_in_beancount.html">Settlement Dates in Beancount</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../balance_assertions_in_beancount.html">Balance Assertions in Beancount</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../fund_accounting_with_beancount.html">Fund Accounting with Beancount</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../rounding_precision_in_beancount.html">Rounding Precision in Beancount</a>
                </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="#">Beancount 3</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../beancount_v3.html">Goals & Design</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../installing_beancount_v3.html">Installing Beancount</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../beancount_v3_dependencies.html">Dependencies</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../beangulp.html">Beangulp</a>
                </li>
    </ul>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">API reference</span></p>
                <ul class="current">
                    <li class="toctree-l1"><a class="reference internal" href="index.html">beancount</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="beancount.core.html">beancount.core</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="beancount.loader.html">beancount.loader</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="beancount.ops.html">beancount.ops</a>
                    </li>
                    <li class="toctree-l1 current"><a class="reference internal current" href="beancount.parser.html">beancount.parser</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#beancount.parser">beancount.parser</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#beancount.parser.booking">booking</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking.BookingError">BookingError</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking.BookingError.__getnewargs__">__getnewargs__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking.BookingError.__new__">__new__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking.BookingError.__replace__">__replace__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking.BookingError.__repr__">__repr__()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking.book">book()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking.convert_lot_specs_to_lots">convert_lot_specs_to_lots()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking.convert_spec_to_cost">convert_spec_to_cost()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking.validate_inventory_booking">validate_inventory_booking()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking.validate_missing_eliminated">validate_missing_eliminated()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#beancount.parser.booking_full">booking_full</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full.CategorizationError">CategorizationError</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_full.CategorizationError.__getnewargs__">__getnewargs__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_full.CategorizationError.__new__">__new__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_full.CategorizationError.__replace__">__replace__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_full.CategorizationError.__repr__">__repr__()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full.InterpolationError">InterpolationError</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_full.InterpolationError.__getnewargs__">__getnewargs__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_full.InterpolationError.__new__">__new__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_full.InterpolationError.__replace__">__replace__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_full.InterpolationError.__repr__">__repr__()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full.MissingType">MissingType</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full.ReductionError">ReductionError</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_full.ReductionError.__getnewargs__">__getnewargs__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_full.ReductionError.__new__">__new__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_full.ReductionError.__replace__">__replace__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_full.ReductionError.__repr__">__repr__()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full.Refer">Refer</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_full.Refer.__getnewargs__">__getnewargs__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_full.Refer.__new__">__new__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_full.Refer.__replace__">__replace__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_full.Refer.__repr__">__repr__()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full.SelfReduxError">SelfReduxError</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_full.SelfReduxError.__getnewargs__">__getnewargs__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_full.SelfReduxError.__new__">__new__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_full.SelfReduxError.__replace__">__replace__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_full.SelfReduxError.__repr__">__repr__()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full.book">book()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full.book_reductions">book_reductions()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full.categorize_by_currency">categorize_by_currency()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full.compute_cost_number">compute_cost_number()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full.convert_costspec_to_cost">convert_costspec_to_cost()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full.get_bucket_currency">get_bucket_currency()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full.has_self_reduction">has_self_reduction()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full.interpolate_group">interpolate_group()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full.replace_currencies">replace_currencies()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_full.unique_label">unique_label()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#beancount.parser.booking_method">booking_method</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_method.AmbiguousMatchError">AmbiguousMatchError</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_method.AmbiguousMatchError.__getnewargs__">__getnewargs__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_method.AmbiguousMatchError.__new__">__new__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_method.AmbiguousMatchError.__replace__">__replace__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.booking_method.AmbiguousMatchError.__repr__">__repr__()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_method.booking_method_AVERAGE">booking_method_AVERAGE()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_method.booking_method_FIFO">booking_method_FIFO()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_method.booking_method_HIFO">booking_method_HIFO()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_method.booking_method_LIFO">booking_method_LIFO()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_method.booking_method_NONE">booking_method_NONE()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_method.booking_method_STRICT">booking_method_STRICT()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_method.booking_method_STRICT_WITH_SIZE">booking_method_STRICT_WITH_SIZE()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.booking_method.handle_ambiguous_matches">handle_ambiguous_matches()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#beancount.parser.cmptest">cmptest</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.cmptest.TestCase">TestCase</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.cmptest.TestCase.assertEqualEntries">assertEqualEntries()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.cmptest.TestCase.assertExcludesEntries">assertExcludesEntries()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.cmptest.TestCase.assertIncludesEntries">assertIncludesEntries()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.cmptest.TestError">TestError</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.cmptest.read_string_or_entries">read_string_or_entries()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#beancount.parser.context">context</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.context.render_entry_context">render_entry_context()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.context.render_file_context">render_file_context()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#beancount.parser.grammar">grammar</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.grammar.Builder">Builder</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.account">account()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.amount">amount()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.balance">balance()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.build_grammar_error">build_grammar_error()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.close">close()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.commodity">commodity()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.compound_amount">compound_amount()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.cost_merge">cost_merge()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.cost_spec">cost_spec()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.custom">custom()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.custom_value">custom_value()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.document">document()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.event">event()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.finalize">finalize()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.get_entries">get_entries()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.get_long_string_maxlines">get_long_string_maxlines()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.get_options">get_options()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.handle_list">handle_list()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.include">include()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.key_value">key_value()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.note">note()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.open">open()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.option">option()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.pad">pad()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.pipe_deprecated_error">pipe_deprecated_error()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.plugin">plugin()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.popmeta">popmeta()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.poptag">poptag()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.posting">posting()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.price">price()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.pushmeta">pushmeta()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.pushtag">pushtag()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.query">query()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.store_result">store_result()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.tag_link_LINK">tag_link_LINK()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.tag_link_TAG">tag_link_TAG()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.tag_link_new">tag_link_new()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.Builder.transaction">transaction()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.grammar.CompoundAmount">CompoundAmount</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.CompoundAmount.__getnewargs__">__getnewargs__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.CompoundAmount.__new__">__new__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.CompoundAmount.__replace__">__replace__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.CompoundAmount.__repr__">__repr__()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.grammar.DeprecatedError">DeprecatedError</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.DeprecatedError.__getnewargs__">__getnewargs__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.DeprecatedError.__new__">__new__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.DeprecatedError.__replace__">__replace__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.DeprecatedError.__repr__">__repr__()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.grammar.KeyValue">KeyValue</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.KeyValue.__getnewargs__">__getnewargs__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.KeyValue.__new__">__new__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.KeyValue.__replace__">__replace__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.KeyValue.__repr__">__repr__()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.grammar.ParserError">ParserError</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.ParserError.__getnewargs__">__getnewargs__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.ParserError.__new__">__new__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.ParserError.__replace__">__replace__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.ParserError.__repr__">__repr__()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.grammar.ParserSyntaxError">ParserSyntaxError</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.ParserSyntaxError.__getnewargs__">__getnewargs__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.ParserSyntaxError.__new__">__new__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.ParserSyntaxError.__replace__">__replace__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.ParserSyntaxError.__repr__">__repr__()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.grammar.TagsLinks">TagsLinks</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.TagsLinks.__getnewargs__">__getnewargs__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.TagsLinks.__new__">__new__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.TagsLinks.__replace__">__replace__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.TagsLinks.__repr__">__repr__()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.grammar.ValueType">ValueType</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.ValueType.__getnewargs__">__getnewargs__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.ValueType.__new__">__new__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.ValueType.__replace__">__replace__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.grammar.ValueType.__repr__">__repr__()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.grammar.valid_account_regexp">valid_account_regexp()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#beancount.parser.hashsrc">hashsrc</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.hashsrc.check_parser_source_files">check_parser_source_files()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.hashsrc.gen_include">gen_include()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.hashsrc.hash_parser_source_files">hash_parser_source_files()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#beancount.parser.lexer">lexer</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.lexer.LexBuilder">LexBuilder</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.lexer.LexBuilder.build_lexer_error">build_lexer_error()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.lexer.LexerError">LexerError</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.lexer.LexerError.__getnewargs__">__getnewargs__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.lexer.LexerError.__new__">__new__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.lexer.LexerError.__replace__">__replace__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.lexer.LexerError.__repr__">__repr__()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.lexer.lex_iter">lex_iter()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.lexer.lex_iter_string">lex_iter_string()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#beancount.parser.options">options</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.options.OptDesc">OptDesc</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.options.OptDesc.__getnewargs__">__getnewargs__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.options.OptDesc.__new__">__new__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.options.OptDesc.__replace__">__replace__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.options.OptDesc.__repr__">__repr__()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.options.OptGroup">OptGroup</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.options.OptGroup.__getnewargs__">__getnewargs__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.options.OptGroup.__new__">__new__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.options.OptGroup.__replace__">__replace__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.options.OptGroup.__repr__">__repr__()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.options.Opt">Opt()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.options.get_account_types">get_account_types()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.options.get_current_accounts">get_current_accounts()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.options.get_previous_accounts">get_previous_accounts()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.options.get_unrealized_account">get_unrealized_account()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.options.list_options">list_options()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.options.options_validate_booking_method">options_validate_booking_method()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.options.options_validate_boolean">options_validate_boolean()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.options.options_validate_plugin">options_validate_plugin()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.options.options_validate_processing_mode">options_validate_processing_mode()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.options.options_validate_tolerance">options_validate_tolerance()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.options.options_validate_tolerance_map">options_validate_tolerance_map()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#beancount.parser.parser">parser</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.parser.is_entry_incomplete">is_entry_incomplete()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.parser.is_posting_incomplete">is_posting_incomplete()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.parser.parse_doc">parse_doc()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.parser.parse_file">parse_file()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.parser.parse_many">parse_many()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.parser.parse_one">parse_one()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.parser.parse_string">parse_string()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#beancount.parser.printer">printer</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.printer.EntryPrinter">EntryPrinter</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.printer.EntryPrinter.__call__">__call__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.printer.EntryPrinter.render_posting_strings">render_posting_strings()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.printer.EntryPrinter.write_entry_source">write_entry_source()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.parser.printer.EntryPrinter.write_metadata">write_metadata()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.printer.align_position_strings">align_position_strings()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.printer.format_entry">format_entry()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.printer.format_error">format_error()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.printer.print_entries">print_entries()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.printer.print_entry">print_entry()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.printer.print_error">print_error()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.printer.print_errors">print_errors()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.printer.render_flag">render_flag()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.printer.render_source">render_source()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#beancount.parser.version">version</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.parser.version.compute_version_string">compute_version_string()</a>
    </li>
        </ul>
    </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="beancount.plugins.html">beancount.plugins</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="beancount.scripts.html">beancount.scripts</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="beancount.tools.html">beancount.tools</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="beancount.utils.html">beancount.utils</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">Beancount Documentation</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
    
      
        
          <li>API reference &raquo;</li>
        
      
    
    <li>beancount.parser</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>

          <div role="main">
            <div class="section">
              
                <h1 id="beancountparser">beancount.parser<a class="headerlink" href="#beancountparser" title="Permanent link"></a></h1>


  <div class="doc doc-object doc-module">

<a id="beancount.parser"></a>
    <div class="doc doc-contents first">

      <p>Parser module for beancount input files.</p>



  <div class="doc doc-children">












  <div class="doc doc-object doc-module">



<h2 id="beancount.parser.booking" class="doc doc-heading">
        <code>beancount.parser.booking</code>



<a href="#beancount.parser.booking" class="headerlink" title="Permanent link"></a></h2>

    <div class="doc doc-contents ">

      <p>Algorithms for 'booking' inventory, that is, the process of finding a
matching lot when reducing the content of an inventory.</p>



  <div class="doc doc-children">









  <div class="doc doc-object doc-class">



<h3 id="beancount.parser.booking.BookingError" class="doc doc-heading">
        <code>
beancount.parser.booking.BookingError            (<span title="tuple">tuple</span>)
        </code>



<a href="#beancount.parser.booking.BookingError" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>BookingError(source, message, entry)</p>




  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.booking.BookingError.__getnewargs__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking.BookingError.__getnewargs__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.booking.BookingError.__getnewargs__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return self as a plain tuple.  Used by copy and pickle.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking.py</code></summary>
          <pre class="highlight"><code class="language-python">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.booking.BookingError.__new__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking.BookingError.__new__(_cls, source, message, entry)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
      <small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
  </span>

<a href="#beancount.parser.booking.BookingError.__new__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Create new instance of BookingError(source, message, entry)</p>

    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.booking.BookingError.__replace__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking.BookingError.__replace__(/, self, **kwds)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.booking.BookingError.__replace__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a new BookingError object replacing specified fields with new values</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking.py</code></summary>
          <pre class="highlight"><code class="language-python">def _replace(self, /, **kwds):
    result = self._make(_map(kwds.pop, field_names, self))
    if kwds:
        raise TypeError(f'Got unexpected field names: {list(kwds)!r}')
    return result
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.booking.BookingError.__repr__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking.BookingError.__repr__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.booking.BookingError.__repr__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a nicely formatted representation string</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking.py</code></summary>
          <pre class="highlight"><code class="language-python">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>




  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.booking.book" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking.book(incomplete_entries, options_map, initial_balances=None)</code>


<a href="#beancount.parser.booking.book" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Book inventory lots and complete all positions with incomplete numbers.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>incomplete_entries</strong> – A list of directives, with some postings possibly left
with incomplete amounts as produced by the parser.</p></li>
            <li><p><strong>options_map</strong> – An options dict as produced by the parser.</p></li>
            <li><p><strong>initial_balances</strong> – A dict of (account, inventory) pairs to start booking from.
This is useful when attempting to book on top of an existing state.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p><code>A pair of
  entries</code> – A list of completed entries with all their postings completed.
  errors: New errors produced during interpolation.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking.py</code></summary>
          <pre class="highlight"><code class="language-python">def book(incomplete_entries, options_map, initial_balances=None):
    """Book inventory lots and complete all positions with incomplete numbers.

    Args:
      incomplete_entries: A list of directives, with some postings possibly left
        with incomplete amounts as produced by the parser.
      options_map: An options dict as produced by the parser.
      initial_balances: A dict of (account, inventory) pairs to start booking from.
        This is useful when attempting to book on top of an existing state.
    Returns:
      A pair of
        entries: A list of completed entries with all their postings completed.
        errors: New errors produced during interpolation.
    """
    # Get the list of booking methods for each account.
    booking_methods = collections.defaultdict(lambda: options_map["booking_method"])
    for entry in incomplete_entries:
        if isinstance(entry, data.Open) and entry.booking:
            booking_methods[entry.account] = entry.booking

    # Do the booking here!
    entries, booking_errors = booking_full.book(incomplete_entries, options_map,
                                                booking_methods, initial_balances)

    # Check for MISSING elements remaining.
    missing_errors = validate_missing_eliminated(entries, options_map)

    return entries, (booking_errors + missing_errors)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.booking.convert_lot_specs_to_lots" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking.convert_lot_specs_to_lots(entries)</code>


<a href="#beancount.parser.booking.convert_lot_specs_to_lots" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>For all the entries, convert the posting's position's CostSpec to Cost
instances. In the simple method, the data provided in the CostSpec must
unambiguously provide a way to compute the cost amount.</p>
<p>This essentially replicates the way the old parser used to work, but
allowing positions to have the fuzzy lot specifications instead of the
resolved ones. We used to simply compute the costs locally, and this gets
rid of the CostSpec to produce the Cost without fuzzy matching. This is only
there for the sake of transition to the new matching logic.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> – A list of incomplete directives as per the parser.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A list of entries whose postings's position costs have been converted to
Cost instances but that may still be incomplete.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Exceptions:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><code>ValueError</code> – If there's a unacceptable number.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking.py</code></summary>
          <pre class="highlight"><code class="language-python">def convert_lot_specs_to_lots(entries):
    """For all the entries, convert the posting's position's CostSpec to Cost
    instances. In the simple method, the data provided in the CostSpec must
    unambiguously provide a way to compute the cost amount.

    This essentially replicates the way the old parser used to work, but
    allowing positions to have the fuzzy lot specifications instead of the
    resolved ones. We used to simply compute the costs locally, and this gets
    rid of the CostSpec to produce the Cost without fuzzy matching. This is only
    there for the sake of transition to the new matching logic.

    Args:
      entries: A list of incomplete directives as per the parser.
    Returns:
      A list of entries whose postings's position costs have been converted to
      Cost instances but that may still be incomplete.
    Raises:
      ValueError: If there's a unacceptable number.
    """
    new_entries = []
    errors = []
    for entry in entries:
        if not isinstance(entry, data.Transaction):
            new_entries.append(entry)
            continue

        new_postings = []
        for posting in entry.postings:
            try:
                units = posting.units
                cost_spec = posting.cost
                cost = convert_spec_to_cost(units, cost_spec)
                if cost_spec is not None and cost is None:
                    errors.append(
                        BookingError(entry.meta,
                                     "Cost syntax not supported; cost spec ignored",
                                     None))

                if cost and isinstance(units, amount.Amount):
                    # If there is a cost, we don't allow either a cost value of
                    # zero, nor a zero number of units. Note that we allow a price
                    # of zero as the only special case (for conversion entries), but
                    # never for costs.
                    if units.number == ZERO:
                        raise ValueError('Amount is zero: "{}"'.format(units))
                    if cost.number is not None and cost.number &lt; ZERO:
                        raise ValueError('Cost is negative: "{}"'.format(cost))
            except ValueError as exc:
                errors.append(BookingError(entry.meta, str(exc), None))
                cost = None
            new_postings.append(posting._replace(cost=cost))
        new_entries.append(entry._replace(postings=new_postings))
    return new_entries, errors
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.booking.convert_spec_to_cost" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking.convert_spec_to_cost(units, cost_spec)</code>


<a href="#beancount.parser.booking.convert_spec_to_cost" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Convert a posting's CostSpec instance to a Cost.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>units</strong> – An instance of Amount.</p></li>
            <li><p><strong>cost_spec</strong> – An instance of CostSpec.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>An instance of Cost.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking.py</code></summary>
          <pre class="highlight"><code class="language-python">def convert_spec_to_cost(units, cost_spec):
    """Convert a posting's CostSpec instance to a Cost.

    Args:
      units: An instance of Amount.
      cost_spec: An instance of CostSpec.
    Returns:
      An instance of Cost.
    """
    cost = cost_spec
    errors = []
    if isinstance(units, amount.Amount):
        currency = units.currency
        if cost_spec is not None:
            number_per, number_total, cost_currency, date, label, merge = cost_spec

            # Compute the cost.
            if number_per is not MISSING or number_total is not None:
                if number_total is not None:
                    # Compute the per-unit cost if there is some total cost
                    # component involved.
                    units_num = units.number
                    cost_total = number_total
                    if number_per is not MISSING:
                        cost_total += number_per * units_num
                    unit_cost = cost_total / abs(units_num)
                else:
                    unit_cost = number_per
                cost = position.Cost(unit_cost, cost_currency, date, label)
            else:
                cost = None
    return cost
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.booking.validate_inventory_booking" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking.validate_inventory_booking(entries, unused_options_map, booking_methods)</code>


<a href="#beancount.parser.booking.validate_inventory_booking" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Validate that no position at cost is allowed to go negative.</p>
<p>This routine checks that when a posting reduces a position, existing or not,
that the subsequent inventory does not result in a position with a negative
number of units. A negative number of units would only be required for short
trades of trading spreads on futures, and right now this is not supported.
It would not be difficult to support this, however, but we want to be strict
about it, because being pedantic about this is otherwise a great way to
detect user data entry mistakes.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> – A list of directives.</p></li>
            <li><p><strong>unused_options_map</strong> – An options map.</p></li>
            <li><p><strong>booking_methods</strong> – A mapping of account name to booking method, accumulated
in the main loop.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A list of errors.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking.py</code></summary>
          <pre class="highlight"><code class="language-python">def validate_inventory_booking(entries, unused_options_map, booking_methods):
    """Validate that no position at cost is allowed to go negative.

    This routine checks that when a posting reduces a position, existing or not,
    that the subsequent inventory does not result in a position with a negative
    number of units. A negative number of units would only be required for short
    trades of trading spreads on futures, and right now this is not supported.
    It would not be difficult to support this, however, but we want to be strict
    about it, because being pedantic about this is otherwise a great way to
    detect user data entry mistakes.

    Args:
      entries: A list of directives.
      unused_options_map: An options map.
      booking_methods: A mapping of account name to booking method, accumulated
        in the main loop.
    Returns:
      A list of errors.

    """
    errors = []
    balances = collections.defaultdict(inventory.Inventory)
    for entry in entries:
        if isinstance(entry, data.Transaction):
            for posting in entry.postings:
                # Update the balance of each posting on its respective account
                # without allowing booking to a negative position, and if an error
                # is encountered, catch it and return it.
                running_balance = balances[posting.account]
                position_, _ = running_balance.add_position(posting)

                # Skip this check if the booking method is set to ignore it.
                if booking_methods.get(posting.account, None) == data.Booking.NONE:
                    continue

                # Check if the resulting inventory is mixed, which is not
                # allowed under the STRICT method.
                if running_balance.is_mixed():
                    errors.append(
                        BookingError(
                            entry.meta,
                            ("Reducing position results in inventory with positive "
                             "and negative lots: {}").format(position_),
                            entry))

    return errors
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.booking.validate_missing_eliminated" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking.validate_missing_eliminated(entries, unused_options_map)</code>


<a href="#beancount.parser.booking.validate_missing_eliminated" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Validate that all the missing bits of postings have been eliminated.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> – A list of directives.</p></li>
            <li><p><strong>unused_options_map</strong> – An options map.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A list of errors.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking.py</code></summary>
          <pre class="highlight"><code class="language-python">def validate_missing_eliminated(entries, unused_options_map):
    """Validate that all the missing bits of postings have been eliminated.

    Args:
      entries: A list of directives.
      unused_options_map: An options map.
    Returns:
      A list of errors.
    """
    errors = []
    for entry in entries:
        if isinstance(entry, data.Transaction):
            for posting in entry.postings:
                units = posting.units
                cost = posting.cost
                if (MISSING in (units.number, units.currency) or
                    cost is not None and MISSING in (cost.number, cost.currency,
                                                     cost.date, cost.label)):
                    errors.append(
                        BookingError(entry.meta,
                                     "Transaction has incomplete elements",
                                     entry))
                    break
    return errors
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="beancount.parser.booking_full" class="doc doc-heading">
        <code>beancount.parser.booking_full</code>



<a href="#beancount.parser.booking_full" class="headerlink" title="Permanent link"></a></h2>

    <div class="doc doc-contents ">

      <p>Full (new) booking implementation.</p>
<p>Problem description:</p>
<p>Interpolation and booking feed on each other, that is, numbers filled in from
interpolation might affect the booking process, and numbers derived from the
booking process may help carry out interpolation that would otherwise be
under-defined. Here's an example of interpolation helping the booking process:</p>
<p>Assume the ante-inventory of Assets:Investments contains two lots of shares of
HOOL, one at 100.00 USD and the other at 101.00 USD and apply this transaction:</p>
<pre><code>2015-09-30 *
  Assets:Investments   -10 HOOL {USD}
  Assets:Cash               1000 USD
  Income:Gains              -200 USD
</code></pre>
<p>Interpolation is unambiguously able to back out a cost of 100 USD / HOOL, which
would then result in an unambiguous booking result.</p>
<p>On the other hand, consider this transaction:</p>
<pre><code>2015-09-30 *
  Assets:Investments    -10 HOOL {USD}
  Assets:Cash               1000 USD
  Income:Gains
</code></pre>
<p>Now the interpolation cannot succeed. If the Assets:Investments account is
configured to use the FIFO method, the 10 oldest shares would be selected for
the cost, and we could then interpolate the capital gains correctly.</p>
<p>First observation: The second case is much more frequent than the first, and the
first is easily resolved manually by requiring a particular cost be specified.
Moreover, in many cases there isn't just a single lot of shares to be reduced
from and figuring out the correct set of shares given a target cost is an
underspecified problem.</p>
<p>Second observation: Booking can only be achieved for inventory reductions, not
for augmentations. Therefore, we should carry out booking on inventory
reductions and fail early if reduction is undefined there, and leave inventory
augmentations with missing numbers undefined, so that interpolation can fill
them in at a later stage.</p>
<p>Note that one case we'd like to but may not be able to handle is of a reduction
with interpolated price, like this:</p>
<pre><code>2015-09-30 *
  Assets:Investments        -10 HOOL {100.00 # USD}
  Expenses:Commission      9.95 USD
  Assets:Cash            990.05 USD
</code></pre>
<p>Therefore we choose to</p>
<p>1) Carry out booking first, on inventory reductions only, and leave inventory
   augmentations as they are, possibly undefined. The 'cost' attributed of
   booked postings are converted from CostSpec to Cost. Augmented postings with
   missing amounts are left as CostSpec instances in order to allow for
   interpolation of total vs. per-unit amount.</p>
<p>2) Compute interpolations on the resulting postings. Undefined costs for
   inventory augmentations may be filled in by interpolations at this stage (if
   possible).</p>
<p>3) Finally, convert the interpolated CostSpec instances to Cost instances.</p>
<p>Improving on this algorithm would require running a loop over the booking and
interpolation steps until all numbers are resolved or no more inference can
occur. We may consider that for later, as an experimental feature. My hunch is
that there are so few cases for which this would be useful that we won't bother
improving on the algorithm above.</p>



  <div class="doc doc-children">









  <div class="doc doc-object doc-class">



<h3 id="beancount.parser.booking_full.CategorizationError" class="doc doc-heading">
        <code>
beancount.parser.booking_full.CategorizationError            (<span title="tuple">tuple</span>)
        </code>



<a href="#beancount.parser.booking_full.CategorizationError" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>CategorizationError(source, message, entry)</p>




  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.booking_full.CategorizationError.__getnewargs__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_full.CategorizationError.__getnewargs__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.booking_full.CategorizationError.__getnewargs__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return self as a plain tuple.  Used by copy and pickle.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
          <pre class="highlight"><code class="language-python">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.booking_full.CategorizationError.__new__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_full.CategorizationError.__new__(_cls, source, message, entry)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
      <small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
  </span>

<a href="#beancount.parser.booking_full.CategorizationError.__new__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Create new instance of CategorizationError(source, message, entry)</p>

    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.booking_full.CategorizationError.__replace__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_full.CategorizationError.__replace__(/, self, **kwds)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.booking_full.CategorizationError.__replace__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a new CategorizationError object replacing specified fields with new values</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
          <pre class="highlight"><code class="language-python">def _replace(self, /, **kwds):
    result = self._make(_map(kwds.pop, field_names, self))
    if kwds:
        raise TypeError(f'Got unexpected field names: {list(kwds)!r}')
    return result
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.booking_full.CategorizationError.__repr__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_full.CategorizationError.__repr__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.booking_full.CategorizationError.__repr__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a nicely formatted representation string</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
          <pre class="highlight"><code class="language-python">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h3 id="beancount.parser.booking_full.InterpolationError" class="doc doc-heading">
        <code>
beancount.parser.booking_full.InterpolationError            (<span title="tuple">tuple</span>)
        </code>



<a href="#beancount.parser.booking_full.InterpolationError" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>InterpolationError(source, message, entry)</p>




  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.booking_full.InterpolationError.__getnewargs__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_full.InterpolationError.__getnewargs__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.booking_full.InterpolationError.__getnewargs__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return self as a plain tuple.  Used by copy and pickle.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
          <pre class="highlight"><code class="language-python">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.booking_full.InterpolationError.__new__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_full.InterpolationError.__new__(_cls, source, message, entry)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
      <small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
  </span>

<a href="#beancount.parser.booking_full.InterpolationError.__new__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Create new instance of InterpolationError(source, message, entry)</p>

    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.booking_full.InterpolationError.__replace__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_full.InterpolationError.__replace__(/, self, **kwds)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.booking_full.InterpolationError.__replace__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a new InterpolationError object replacing specified fields with new values</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
          <pre class="highlight"><code class="language-python">def _replace(self, /, **kwds):
    result = self._make(_map(kwds.pop, field_names, self))
    if kwds:
        raise TypeError(f'Got unexpected field names: {list(kwds)!r}')
    return result
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.booking_full.InterpolationError.__repr__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_full.InterpolationError.__repr__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.booking_full.InterpolationError.__repr__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a nicely formatted representation string</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
          <pre class="highlight"><code class="language-python">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h3 id="beancount.parser.booking_full.MissingType" class="doc doc-heading">
        <code>
beancount.parser.booking_full.MissingType            (<span title="enum.Enum">Enum</span>)
        </code>



<a href="#beancount.parser.booking_full.MissingType" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>The type of missing number.</p>




  <div class="doc doc-children">















  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h3 id="beancount.parser.booking_full.ReductionError" class="doc doc-heading">
        <code>
beancount.parser.booking_full.ReductionError            (<span title="tuple">tuple</span>)
        </code>



<a href="#beancount.parser.booking_full.ReductionError" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>ReductionError(source, message, entry)</p>




  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.booking_full.ReductionError.__getnewargs__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_full.ReductionError.__getnewargs__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.booking_full.ReductionError.__getnewargs__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return self as a plain tuple.  Used by copy and pickle.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
          <pre class="highlight"><code class="language-python">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.booking_full.ReductionError.__new__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_full.ReductionError.__new__(_cls, source, message, entry)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
      <small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
  </span>

<a href="#beancount.parser.booking_full.ReductionError.__new__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Create new instance of ReductionError(source, message, entry)</p>

    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.booking_full.ReductionError.__replace__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_full.ReductionError.__replace__(/, self, **kwds)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.booking_full.ReductionError.__replace__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a new ReductionError object replacing specified fields with new values</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
          <pre class="highlight"><code class="language-python">def _replace(self, /, **kwds):
    result = self._make(_map(kwds.pop, field_names, self))
    if kwds:
        raise TypeError(f'Got unexpected field names: {list(kwds)!r}')
    return result
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.booking_full.ReductionError.__repr__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_full.ReductionError.__repr__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.booking_full.ReductionError.__repr__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a nicely formatted representation string</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
          <pre class="highlight"><code class="language-python">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h3 id="beancount.parser.booking_full.Refer" class="doc doc-heading">
        <code>
beancount.parser.booking_full.Refer            (<span title="tuple">tuple</span>)
        </code>



<a href="#beancount.parser.booking_full.Refer" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Refer(index, units_currency, cost_currency, price_currency)</p>




  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.booking_full.Refer.__getnewargs__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_full.Refer.__getnewargs__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.booking_full.Refer.__getnewargs__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return self as a plain tuple.  Used by copy and pickle.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
          <pre class="highlight"><code class="language-python">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.booking_full.Refer.__new__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_full.Refer.__new__(_cls, index, units_currency, cost_currency, price_currency)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
      <small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
  </span>

<a href="#beancount.parser.booking_full.Refer.__new__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Create new instance of Refer(index, units_currency, cost_currency, price_currency)</p>

    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.booking_full.Refer.__replace__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_full.Refer.__replace__(/, self, **kwds)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.booking_full.Refer.__replace__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a new Refer object replacing specified fields with new values</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
          <pre class="highlight"><code class="language-python">def _replace(self, /, **kwds):
    result = self._make(_map(kwds.pop, field_names, self))
    if kwds:
        raise TypeError(f'Got unexpected field names: {list(kwds)!r}')
    return result
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.booking_full.Refer.__repr__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_full.Refer.__repr__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.booking_full.Refer.__repr__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a nicely formatted representation string</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
          <pre class="highlight"><code class="language-python">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h3 id="beancount.parser.booking_full.SelfReduxError" class="doc doc-heading">
        <code>
beancount.parser.booking_full.SelfReduxError            (<span title="tuple">tuple</span>)
        </code>



<a href="#beancount.parser.booking_full.SelfReduxError" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>SelfReduxError(source, message, entry)</p>




  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.booking_full.SelfReduxError.__getnewargs__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_full.SelfReduxError.__getnewargs__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.booking_full.SelfReduxError.__getnewargs__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return self as a plain tuple.  Used by copy and pickle.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
          <pre class="highlight"><code class="language-python">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.booking_full.SelfReduxError.__new__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_full.SelfReduxError.__new__(_cls, source, message, entry)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
      <small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
  </span>

<a href="#beancount.parser.booking_full.SelfReduxError.__new__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Create new instance of SelfReduxError(source, message, entry)</p>

    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.booking_full.SelfReduxError.__replace__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_full.SelfReduxError.__replace__(/, self, **kwds)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.booking_full.SelfReduxError.__replace__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a new SelfReduxError object replacing specified fields with new values</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
          <pre class="highlight"><code class="language-python">def _replace(self, /, **kwds):
    result = self._make(_map(kwds.pop, field_names, self))
    if kwds:
        raise TypeError(f'Got unexpected field names: {list(kwds)!r}')
    return result
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.booking_full.SelfReduxError.__repr__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_full.SelfReduxError.__repr__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.booking_full.SelfReduxError.__repr__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a nicely formatted representation string</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
          <pre class="highlight"><code class="language-python">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>




  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.booking_full.book" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_full.book(entries, options_map, methods, initial_balances=None)</code>


<a href="#beancount.parser.booking_full.book" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Interpolate missing data from the entries using the full historical algorithm.
See the internal implementation _book() for details.
This method only stripes some of the return values.</p>
<p>See _book() for arguments and return values.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
          <pre class="highlight"><code class="language-python">def book(entries, options_map, methods, initial_balances=None):
    """Interpolate missing data from the entries using the full historical algorithm.
    See the internal implementation _book() for details.
    This method only stripes some of the return values.

    See _book() for arguments and return values.
    """
    entries, errors, _ = _book(entries, options_map, methods, initial_balances)
    return entries, errors
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.booking_full.book_reductions" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_full.book_reductions(entry, group_postings, balances, methods)</code>


<a href="#beancount.parser.booking_full.book_reductions" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Book inventory reductions against the ante-balances.</p>
<p>This function accepts a dict of (account, Inventory balance) and for each
posting that is a reduction against its inventory, attempts to find a
corresponding lot or list of lots to reduce the balance with.</p>
<ul>
<li>
<p>For reducing lots, the CostSpec instance of the posting is replaced by a
  Cost instance.</p>
</li>
<li>
<p>For augmenting lots, the CostSpec instance of the posting is left alone,
  except for its date, which is inherited from the parent Transaction.</p>
</li>
</ul>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entry</strong> – An instance of Transaction. This is only used to refer to when
logging errors.</p></li>
            <li><p><strong>group_postings</strong> – A list of Posting instances for the group.</p></li>
            <li><p><strong>balances</strong> – A dict of account name to inventory contents.</p></li>
            <li><p><strong>methods</strong> – A mapping of account name to their corresponding booking
method enum.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p><code>A pair of
  booked_postings</code> – A list of booked postings, with reducing lots resolved
    against specific position in the corresponding accounts'
    ante-inventory balances. Note single reducing posting in the input may
    result in multiple postings in the output. Also note that augmenting
    postings held-at-cost will still refer to 'cost' instances of
    CostSpec, left to be interpolated later.
  errors: A list of errors, if there were any.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
          <pre class="highlight"><code class="language-python">def book_reductions(entry, group_postings, balances,
                    methods):
    """Book inventory reductions against the ante-balances.

    This function accepts a dict of (account, Inventory balance) and for each
    posting that is a reduction against its inventory, attempts to find a
    corresponding lot or list of lots to reduce the balance with.

    * For reducing lots, the CostSpec instance of the posting is replaced by a
      Cost instance.

    * For augmenting lots, the CostSpec instance of the posting is left alone,
      except for its date, which is inherited from the parent Transaction.

    Args:
      entry: An instance of Transaction. This is only used to refer to when
        logging errors.
      group_postings: A list of Posting instances for the group.
      balances: A dict of account name to inventory contents.
      methods: A mapping of account name to their corresponding booking
        method enum.
    Returns:
      A pair of
        booked_postings: A list of booked postings, with reducing lots resolved
          against specific position in the corresponding accounts'
          ante-inventory balances. Note single reducing posting in the input may
          result in multiple postings in the output. Also note that augmenting
          postings held-at-cost will still refer to 'cost' instances of
          CostSpec, left to be interpolated later.
        errors: A list of errors, if there were any.
    """
    errors = []

    # A local copy of the balances dictionary which is updated just for the
    # duration of this function's updates, in order to take into account the
    # cumulative effect of all the postings inferred here
    local_balances = {}

    empty = inventory.Inventory()
    booked_postings = []
    for posting in group_postings:
        # Process a single posting.
        units = posting.units
        costspec = posting.cost
        account = posting.account

        # Note: We ensure there is no mutation on 'balances' to keep this
        # function without side-effects. Note that we may be able to optimize
        # performance later on by giving up this property.
        #
        # Also note that if there is no existing balance, then won't be any lot
        # reduction because none of the postings will be able to match against
        # any currencies of the balance.
        if account not in local_balances:
            previous_balance = balances.get(account, empty)
            local_balances[account] = copy.copy(previous_balance)
        balance = local_balances[account]

        # Check if this is a lot held at cost.
        if costspec is None or units.number is MISSING:
            # This posting is not held at cost; we do nothing.
            booked_postings.append(posting)
        else:
            # This posting is held at cost; figure out if it's a reduction or an
            # augmentation.
            method = methods[account]
            if (method is not Booking.NONE and
                balance is not None and
                balance.is_reduced_by(units)):
                # This posting is a reduction.

                # Match the positions.
                cost_number = compute_cost_number(costspec, units)
                matches = []
                for position in balance:
                    # Skip inventory contents of a different currency.
                    if (units.currency and
                        position.units.currency != units.currency):
                        continue
                    # Skip balance positions not held at cost.
                    if position.cost is None:
                        continue
                    if (cost_number is not None and
                        position.cost.number != cost_number):
                        continue
                    if (isinstance(costspec.currency, str) and
                        position.cost.currency != costspec.currency):
                        continue
                    if (costspec.date and
                        position.cost.date != costspec.date):
                        continue
                    if (costspec.label and
                        position.cost.label != costspec.label):
                        continue
                    matches.append(position)

                # Check for ambiguous matches.
                if len(matches) == 0:
                    errors.append(
                        ReductionError(entry.meta,
                                       'No position matches "{}" against balance {}'.format(
                                           posting, balance),
                                       entry))
                    return [], errors  # This is irreconcilable, remove these postings.

                # TODO(blais): We'll have to change this, as we want to allow
                # positions crossing from negative to positive and vice-versa in
                # a simple application. See {d3cbd78f1029}.
                reduction_postings, matched_postings, ambi_errors = (
                    booking_method.handle_ambiguous_matches(entry, posting, matches,
                                                            method))
                if ambi_errors:
                    errors.extend(ambi_errors)
                    return [], errors

                # Add the reductions to the resulting list of booked postings.
                booked_postings.extend(reduction_postings)

                # Update the local balance in order to avoid matching against
                # the same postings twice when processing multiple postings in
                # the same transaction. Note that we only do this for postings
                # held at cost because the other postings may need interpolation
                # in order to be resolved properly.
                for posting in reduction_postings:
                    balance.add_position(posting)
            else:
                # This posting is an augmentation.
                #
                # Note that we do not convert the CostSpec instances to Cost
                # instances, because we want to let the subsequent interpolation
                # process able to interpolate either the cost per-unit or the
                # total cost, separately.

                # Put in the date of the parent Transaction if there is no
                # explicit date specified on the spec.
                if costspec.date is None:
                    dated_costspec = costspec._replace(date=entry.date)
                    posting = posting._replace(cost=dated_costspec)

                # FIXME: Insert unique ids for trade tracking; right now this
                # creates ambiguous matches errors (and it shouldn't).
                # # Insert a unique label if there isn't one.
                # if posting.cost is not None and posting.cost.label is None:
                #     posting = posting._replace(
                #         cost=posting.cost._replace(label=unique_label()))

                booked_postings.append(posting)

    return booked_postings, errors
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.booking_full.categorize_by_currency" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_full.categorize_by_currency(entry, balances)</code>


<a href="#beancount.parser.booking_full.categorize_by_currency" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Group the postings by the currency they declare.</p>
<p>This is used to prepare the postings for the next stages: Interpolation and
booking will then be carried out separately on each currency group. At the
outset of this routine, we should have distinct groups of currencies without
any ambiguities regarding which currency they need to balance against.</p>
<p>Here's how this works.</p>
<ul>
<li>
<p>First we apply the constraint that cost-currency and price-currency must
  match, if there is both a cost and a price. This reduces the space of
  possibilities somewhat.</p>
</li>
<li>
<p>If the currency is explicitly specified, we put the posting in that
  currency's bucket.</p>
</li>
<li>
<p>If not, we have a few methods left to disambiguate the currency:</p>
</li>
<li>
<p>We look at the remaining postings... if they are all of a single
     currency, the posting must be in that currency too.</p>
</li>
<li>
<p>If we cannot do that, we inspect the contents of the inventory of the
     account for the posting. If all the contents are of a single currency,
     we use that one.</p>
</li>
</ul>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>postings</strong> – A list of incomplete postings to categorize.</p></li>
            <li><p><strong>balances</strong> – A dict of currency to inventory contents before the transaction is
applied.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p><code>A list of (currency string, list of tuples) items describing each postings
and its interpolated currencies, and a list of generated errors for
currency interpolation. The entry's original postings are left unmodified.
Each tuple in the value-list contains</code> – index: The posting index in the original entry.
  units_currency: The interpolated currency for units.
  cost_currency: The interpolated currency for cost.
  price_currency: The interpolated currency for price.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
          <pre class="highlight"><code class="language-python">def categorize_by_currency(entry, balances):
    """Group the postings by the currency they declare.

    This is used to prepare the postings for the next stages: Interpolation and
    booking will then be carried out separately on each currency group. At the
    outset of this routine, we should have distinct groups of currencies without
    any ambiguities regarding which currency they need to balance against.

    Here's how this works.

    - First we apply the constraint that cost-currency and price-currency must
      match, if there is both a cost and a price. This reduces the space of
      possibilities somewhat.

    - If the currency is explicitly specified, we put the posting in that
      currency's bucket.

    - If not, we have a few methods left to disambiguate the currency:

      1. We look at the remaining postings... if they are all of a single
         currency, the posting must be in that currency too.

      2. If we cannot do that, we inspect the contents of the inventory of the
         account for the posting. If all the contents are of a single currency,
         we use that one.

    Args:
      postings: A list of incomplete postings to categorize.
      balances: A dict of currency to inventory contents before the transaction is
        applied.
    Returns:
      A list of (currency string, list of tuples) items describing each postings
      and its interpolated currencies, and a list of generated errors for
      currency interpolation. The entry's original postings are left unmodified.
      Each tuple in the value-list contains:
        index: The posting index in the original entry.
        units_currency: The interpolated currency for units.
        cost_currency: The interpolated currency for cost.
        price_currency: The interpolated currency for price.
    """
    errors = []

    groups = collections.defaultdict(list)
    sortdict = {}
    auto_postings = []
    unknown = []
    for index, posting in enumerate(entry.postings):
        units = posting.units
        cost = posting.cost
        price = posting.price

        # Extract and override the currencies locally.
        units_currency = (units.currency
                          if units is not MISSING and units is not None
                          else None)
        cost_currency = (cost.currency
                         if cost is not MISSING and cost is not None
                         else None)
        price_currency = (price.currency
                          if price is not MISSING and price is not None
                          else None)

        # First we apply the constraint that cost-currency and price-currency
        # must match, if there is both a cost and a price. This reduces the
        # space of possibilities somewhat.
        if cost_currency is MISSING and isinstance(price_currency, str):
            cost_currency = price_currency
        if price_currency is MISSING and isinstance(cost_currency, str):
            price_currency = cost_currency

        refer = Refer(index, units_currency, cost_currency, price_currency)

        if units is MISSING and price_currency is None:
            # Bucket auto-postings separately from unknown.
            auto_postings.append(refer)
        else:
            # Bucket with what we know so far.
            currency = get_bucket_currency(refer)
            if currency is not None:
                sortdict.setdefault(currency, index)
                groups[currency].append(refer)
            else:
                # If we need to infer the currency, store in unknown.
                unknown.append(refer)

    # We look at the remaining postings... if they are all of a single currency,
    # the posting must be in that currency too.
    if unknown and len(unknown) == 1 and len(groups) == 1:
        (index, units_currency, cost_currency, price_currency) = unknown.pop()

        other_currency = next(iter(groups.keys()))
        if price_currency is None and cost_currency is None:
            # Infer to the units currency.
            units_currency = other_currency
        else:
            # Infer to the cost and price currencies.
            if price_currency is MISSING:
                price_currency = other_currency
            if cost_currency is MISSING:
                cost_currency = other_currency

        refer = Refer(index, units_currency, cost_currency, price_currency)
        currency = get_bucket_currency(refer)
        assert currency is not None
        sortdict.setdefault(currency, index)
        groups[currency].append(refer)

    # Finally, try to resolve all the unknown legs using the inventory contents
    # of each account.
    for refer in unknown:
        (index, units_currency, cost_currency, price_currency) = refer
        posting = entry.postings[index]
        balance = balances.get(posting.account, None)
        if balance is None:
            balance = inventory.Inventory()

        if units_currency is MISSING:
            balance_currencies = balance.currencies()
            if len(balance_currencies) == 1:
                units_currency = balance_currencies.pop()

        if cost_currency is MISSING or price_currency is MISSING:
            balance_cost_currencies = balance.cost_currencies()
            if len(balance_cost_currencies) == 1:
                balance_cost_currency = balance_cost_currencies.pop()
                if price_currency is MISSING:
                    price_currency = balance_cost_currency
                if cost_currency is MISSING:
                    cost_currency = balance_cost_currency

        refer = Refer(index, units_currency, cost_currency, price_currency)
        currency = get_bucket_currency(refer)
        if currency is not None:
            sortdict.setdefault(currency, index)
            groups[currency].append(refer)
        else:
            errors.append(
                CategorizationError(posting.meta,
                                    "Failed to categorize posting {}".format(index + 1),
                                    entry))

    # Fill in missing units currencies if some remain as missing. This may occur
    # if we used the cost or price to bucket the currency but the units currency
    # was missing.
    for currency, refers in groups.items():
        for rindex, refer in enumerate(refers):
            if refer.units_currency is MISSING:
                posting = entry.postings[refer.index]
                balance = balances.get(posting.account, None)
                if balance is None:
                    continue
                balance_currencies = balance.currencies()
                if len(balance_currencies) == 1:
                    refers[rindex] = refer._replace(units_currency=balance_currencies.pop())

    # Deal with auto-postings.
    if len(auto_postings) &gt; 1:
        refer = auto_postings[-1]
        posting = entry.postings[refer.index]
        errors.append(
            CategorizationError(posting.meta,
                                "You may not have more than one auto-posting per currency",
                                entry))
        auto_postings = auto_postings[0:1]
    for refer in auto_postings:
        for currency, glist in groups.items():
            sortdict.setdefault(currency, refer.index)
            glist.append(Refer(refer.index, currency, None, None))

    # Issue error for all currencies which we could not resolve.
    for currency, refers in groups.items():
        for refer in refers:
            posting = entry.postings[refer.index]
            for currency, name in [(refer.units_currency, 'units'),
                                   (refer.cost_currency, 'cost'),
                                   (refer.price_currency, 'price')]:
                if currency is MISSING:
                    errors.append(CategorizationError(
                        posting.meta,
                        "Could not resolve {} currency".format(name),
                        entry))

    sorted_groups = sorted(groups.items(), key=lambda item: sortdict[item[0]])
    return sorted_groups, errors
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.booking_full.compute_cost_number" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_full.compute_cost_number(costspec, units)</code>


<a href="#beancount.parser.booking_full.compute_cost_number" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Given a CostSpec, return the cost number, if possible to compute.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>costspec</strong> – A parsed instance of CostSpec.</p></li>
            <li><p><strong>units</strong> – An instance of Amount for the units of the position.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>If it is not possible to calculate the cost, return None.
Otherwise, returns a Decimal instance, the per-unit cost.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
          <pre class="highlight"><code class="language-python">def compute_cost_number(costspec, units):
    """Given a CostSpec, return the cost number, if possible to compute.

    Args:
      costspec: A parsed instance of CostSpec.
      units: An instance of Amount for the units of the position.
    Returns:
      If it is not possible to calculate the cost, return None.
      Otherwise, returns a Decimal instance, the per-unit cost.
    """
    number_per = costspec.number_per
    number_total = costspec.number_total
    if MISSING in (number_per, number_total):
        return None
    if number_total is not None:
        # Compute the per-unit cost if there is some total cost
        # component involved.
        cost_total = number_total
        units_number = abs(units.number)
        if number_per is not None:
            cost_total += number_per * units_number
        unit_cost = cost_total / units_number
    elif number_per is None:
        return None
    else:
        unit_cost = number_per
    return unit_cost
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.booking_full.convert_costspec_to_cost" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_full.convert_costspec_to_cost(posting)</code>


<a href="#beancount.parser.booking_full.convert_costspec_to_cost" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Convert an instance of CostSpec to Cost, if present on the posting.</p>
<p>If the posting has no cost, it itself is just returned.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>posting</strong> – An instance of Posting.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>An instance of Posting with a possibly replaced 'cost' attribute.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
          <pre class="highlight"><code class="language-python">def convert_costspec_to_cost(posting):
    """Convert an instance of CostSpec to Cost, if present on the posting.

    If the posting has no cost, it itself is just returned.

    Args:
      posting: An instance of Posting.
    Returns:
      An instance of Posting with a possibly replaced 'cost' attribute.
    """
    cost = posting.cost
    if isinstance(cost, position.CostSpec):
        if cost is not None:
            number_per = cost.number_per
            number_total = cost.number_total
            if number_total is not None:
                # Compute the per-unit cost if there is some total cost
                # component involved.
                units_number = abs(posting.units.number)
                cost_total = number_total
                if number_per is not MISSING:
                    cost_total += number_per * units_number
                unit_cost = cost_total / units_number
            else:
                unit_cost = number_per
            new_cost = Cost(unit_cost, cost.currency, cost.date, cost.label)
            posting = posting._replace(units=posting.units, cost=new_cost)
    return posting
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.booking_full.get_bucket_currency" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_full.get_bucket_currency(refer)</code>


<a href="#beancount.parser.booking_full.get_bucket_currency" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Given currency references for a posting, return the bucket currency.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>refer</strong> – An instance of Refer.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A currency string.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
          <pre class="highlight"><code class="language-python">def get_bucket_currency(refer):
    """Given currency references for a posting, return the bucket currency.

    Args:
      refer: An instance of Refer.
    Returns:
      A currency string.
    """
    currency = None
    if isinstance(refer.cost_currency, str):
        currency = refer.cost_currency
    elif isinstance(refer.price_currency, str):
        currency = refer.price_currency
    elif (refer.cost_currency is None and
          refer.price_currency is None and
          isinstance(refer.units_currency, str)):
        currency = refer.units_currency
    return currency
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.booking_full.has_self_reduction" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_full.has_self_reduction(postings, methods)</code>


<a href="#beancount.parser.booking_full.has_self_reduction" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Return true if the postings potentially reduce each other at cost.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>postings</strong> – A list of postings with uninterpolated CostSpec cost instances.</p></li>
            <li><p><strong>methods</strong> – A mapping of account name to their corresponding booking
method.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A boolean, true if there's a potential for self-reduction.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
          <pre class="highlight"><code class="language-python">def has_self_reduction(postings, methods):
    """Return true if the postings potentially reduce each other at cost.

    Args:
      postings: A list of postings with uninterpolated CostSpec cost instances.
      methods: A mapping of account name to their corresponding booking
        method.
    Returns:
      A boolean, true if there's a potential for self-reduction.
    """
    # A mapping of (currency, cost-currency) and sign.
    cost_changes = {}
    for posting in postings:
        cost = posting.cost
        if cost is None:
            continue
        if methods[posting.account] is Booking.NONE:
            continue
        key = (posting.account, posting.units.currency)
        sign = 1 if posting.units.number &gt; ZERO else -1
        if cost_changes.setdefault(key, sign) != sign:
            return True
    return False
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.booking_full.interpolate_group" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_full.interpolate_group(postings, balances, currency, tolerances)</code>


<a href="#beancount.parser.booking_full.interpolate_group" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Interpolate missing numbers in the set of postings.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>postings</strong> – A list of Posting instances.</p></li>
            <li><p><strong>balances</strong> – A dict of account to its ante-inventory.</p></li>
            <li><p><strong>currency</strong> – The weight currency of this group, used for reporting errors.</p></li>
            <li><p><strong>tolerances</strong> – A dict of currency to tolerance values.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p><code>A tuple of
  postings</code> – A list of new posting instances.
  errors: A list of errors generated during interpolation.
  interpolated: A boolean, true if we did have to interpolate.</p>
<p>In the case of an error, this returns the original list of postings, which
is still incomplete. If an error is returned, you should probably skip the
transaction altogether, or just not include the postings in it. (An
alternative behaviour would be to return only the list of valid postings,
but that would likely result in an unbalanced transaction. We do it this
way by choice.)</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
          <pre class="highlight"><code class="language-python">def interpolate_group(postings, balances, currency, tolerances):
    """Interpolate missing numbers in the set of postings.

    Args:
      postings: A list of Posting instances.
      balances: A dict of account to its ante-inventory.
      currency: The weight currency of this group, used for reporting errors.
      tolerances: A dict of currency to tolerance values.
    Returns:
      A tuple of
        postings: A list of new posting instances.
        errors: A list of errors generated during interpolation.
        interpolated: A boolean, true if we did have to interpolate.

      In the case of an error, this returns the original list of postings, which
      is still incomplete. If an error is returned, you should probably skip the
      transaction altogether, or just not include the postings in it. (An
      alternative behaviour would be to return only the list of valid postings,
      but that would likely result in an unbalanced transaction. We do it this
      way by choice.)
    """
    errors = []

    # Figure out which type of amount is missing, by creating a list of
    # incomplete postings and which type of units is missing.
    incomplete = []
    for index, posting in enumerate(postings):
        units = posting.units
        cost = posting.cost
        price = posting.price

        # Identify incomplete parts of the Posting components.
        if units.number is MISSING:
            incomplete.append((MissingType.UNITS, index))

        if isinstance(cost, CostSpec):
            if cost and cost.number_per is MISSING:
                incomplete.append((MissingType.COST_PER, index))
            if cost and cost.number_total is MISSING:
                incomplete.append((MissingType.COST_TOTAL, index))
        else:
            # Check that a resolved instance of Cost never needs interpolation.
            #
            # Note that in theory we could support the interpolation of regular
            # per-unit costs in these if we wanted to; but because they're all
            # reducing postings that have been booked earlier, those never need
            # to be interpolated.
            if cost is not None:
                assert isinstance(cost.number, Decimal), (
                    "Internal error: cost has no number: {}; on postings: {}".format(
                        cost, postings))

        if price and price.number is MISSING:
            incomplete.append((MissingType.PRICE, index))

    # The replacement posting for the incomplete posting of this group.
    new_posting = None

    if len(incomplete) == 0:
        # If there are no missing numbers, just convert the CostSpec to Cost and
        # return that.
        out_postings = [convert_costspec_to_cost(posting)
                        for posting in postings]

    elif len(incomplete) &gt; 1:
        # If there is more than a single value to be interpolated, generate an
        # error and return no postings.
        _, posting_index = incomplete[0]
        errors.append(InterpolationError(
            postings[posting_index].meta,
            "Too many missing numbers for currency group '{}'".format(currency),
            None))
        out_postings = []

    else:
        # If there is a single missing number, calculate it and fill it in here.
        missing, index = incomplete[0]
        incomplete_posting = postings[index]

        # Convert augmenting postings' costs from CostSpec to corresponding Cost
        # instances, except for the incomplete posting.
        new_postings = [(posting
                         if posting is incomplete_posting
                         else convert_costspec_to_cost(posting))
                        for posting in postings]

        # Compute the balance of the other postings.
        residual = interpolate.compute_residual(posting
                                                for posting in new_postings
                                                if posting is not incomplete_posting)
        assert len(residual) &lt; 2, "Internal error in grouping postings by currencies."
        if not residual.is_empty():
            respos = next(iter(residual))
            assert respos.cost is None, (
                "Internal error; cost appears in weight calculation.")
            assert respos.units.currency == currency, (
                "Internal error; residual different than currency group.")
            weight = -respos.units.number
            weight_currency = respos.units.currency
        else:
            weight = ZERO
            weight_currency = currency

        if missing == MissingType.UNITS:
            units = incomplete_posting.units
            cost = incomplete_posting.cost
            if cost:
                # Handle the special case where we only have total cost.
                if cost.number_per == ZERO:
                    errors.append(InterpolationError(
                        incomplete_posting.meta,
                        "Cannot infer per-unit cost only from total", None))
                    return postings, errors, True

                assert cost.currency == weight_currency, (
                    "Internal error; residual currency different than missing currency.")
                cost_total = cost.number_total or ZERO
                units_number = (weight - cost_total) / cost.number_per

            elif incomplete_posting.price:
                assert incomplete_posting.price.currency == weight_currency, (
                    "Internal error; residual currency different than missing currency.")
                units_number = weight / incomplete_posting.price.number

            else:
                assert units.currency == weight_currency, (
                    "Internal error; residual currency different than missing currency.")
                units_number = weight

            # Quantize the interpolated units if necessary.
            units_number = interpolate.quantize_with_tolerance(tolerances,
                                                               units.currency,
                                                               units_number)

            if weight != ZERO:
                new_pos = Position(Amount(units_number, units.currency), cost)
                new_posting = incomplete_posting._replace(units=new_pos.units,
                                                          cost=new_pos.cost)
            else:
                new_posting = None

        elif missing == MissingType.COST_PER:
            units = incomplete_posting.units
            cost = incomplete_posting.cost
            assert cost.currency == weight_currency, (
                "Internal error; residual currency different than missing currency.")
            if units.number != ZERO:
                number_per = (weight - (cost.number_total or ZERO)) / units.number
                new_cost = cost._replace(number_per=number_per)
                new_pos = Position(units, new_cost)
                new_posting = incomplete_posting._replace(units=new_pos.units,
                                                          cost=new_pos.cost)
            else:
                new_posting = None

        elif missing == MissingType.COST_TOTAL:
            units = incomplete_posting.units
            cost = incomplete_posting.cost
            assert cost.currency == weight_currency, (
                "Internal error; residual currency different than missing currency.")
            number_total = (weight - cost.number_per * units.number)
            new_cost = cost._replace(number_total=number_total)
            new_pos = Position(units, new_cost)
            new_posting = incomplete_posting._replace(units=new_pos.units,
                                                      cost=new_pos.cost)

        elif missing == MissingType.PRICE:
            units = incomplete_posting.units
            cost = incomplete_posting.cost
            if cost is not None:
                errors.append(InterpolationError(
                    incomplete_posting.meta,
                    "Cannot infer price for postings with units held at cost", None))
                return postings, errors, True
            else:
                price = incomplete_posting.price
                assert price.currency == weight_currency, (
                    "Internal error; residual currency different than missing currency.")
                new_price_number = abs(weight / units.number)
                new_posting = incomplete_posting._replace(price=Amount(new_price_number,
                                                                       price.currency))

        else:
            assert False, "Internal error; Invalid missing type."

        # Replace the number in the posting.
        if new_posting is not None:
            # Set meta-data on the new posting to indicate it was interpolated.
            if new_posting.meta is None:
                new_posting = new_posting._replace(meta={})
            new_posting.meta[interpolate.AUTOMATIC_META] = True

            # Convert augmenting posting costs from CostSpec to a corresponding
            # Cost instance.
            new_postings[index] = convert_costspec_to_cost(new_posting)
        else:
            del new_postings[index]
        out_postings = new_postings

    assert all(not isinstance(posting.cost, CostSpec)
               for posting in out_postings)

    # Check that units are non-zero and that no cost remains negative; issue an
    # error if this is the case.
    for posting in out_postings:
        if posting.cost is None:
            continue
        # If there is a cost, we don't allow either a cost value of zero,
        # nor a zero number of units. Note that we allow a price of zero as
        # the only special case allowed (for conversion entries), but never
        # for costs.
        if posting.units.number == ZERO:
            errors.append(InterpolationError(
                posting.meta,
                'Amount is zero: "{}"'.format(posting.units), None))
        if posting.cost.number is not None and posting.cost.number &lt; ZERO:
            errors.append(InterpolationError(
                posting.meta,
                'Cost is negative: "{}"'.format(posting.cost), None))

    return out_postings, errors, (new_posting is not None)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.booking_full.replace_currencies" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_full.replace_currencies(postings, refer_groups)</code>


<a href="#beancount.parser.booking_full.replace_currencies" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Replace resolved currencies in the entry's Postings.</p>
<p>This essentially applies the findings of categorize_by_currency() to produce
new postings with all currencies resolved.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>postings</strong> – A list of Posting instances to replace.</p></li>
            <li><p><strong>refer_groups</strong> – A list of (currency, list of posting references) items as
returned by categorize_by_currency().</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A new list of items of (currency, list of Postings), postings for which the
currencies have been replaced by their interpolated currency values.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
          <pre class="highlight"><code class="language-python">def replace_currencies(postings, refer_groups):
    """Replace resolved currencies in the entry's Postings.

    This essentially applies the findings of categorize_by_currency() to produce
    new postings with all currencies resolved.

    Args:
      postings: A list of Posting instances to replace.
      refer_groups: A list of (currency, list of posting references) items as
        returned by categorize_by_currency().
    Returns:
      A new list of items of (currency, list of Postings), postings for which the
      currencies have been replaced by their interpolated currency values.
    """
    new_groups = []
    for currency, refers in refer_groups:
        new_postings = []
        for refer in sorted(refers, key=lambda r: r.index):
            posting = postings[refer.index]
            units = posting.units
            if units is MISSING or units is None:
                posting = posting._replace(units=Amount(MISSING, refer.units_currency))
            else:
                replace = False
                cost = posting.cost
                price = posting.price
                if units.currency is MISSING:
                    units = Amount(units.number, refer.units_currency)
                    replace = True
                if cost and cost.currency is MISSING:
                    cost = cost._replace(currency=refer.cost_currency)
                    replace = True
                if price and price.currency is MISSING:
                    price = Amount(price.number, refer.price_currency)
                    replace = True
                if replace:
                    posting = posting._replace(units=units, cost=cost, price=price)
            new_postings.append(posting)
        new_groups.append((currency, new_postings))
    return new_groups
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.booking_full.unique_label" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_full.unique_label()</code>


<a href="#beancount.parser.booking_full.unique_label" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Return a globally unique label for cost entries.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_full.py</code></summary>
          <pre class="highlight"><code class="language-python">def unique_label() -&gt; str:
    "Return a globally unique label for cost entries."
    return str(uuid.uuid4())
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="beancount.parser.booking_method" class="doc doc-heading">
        <code>beancount.parser.booking_method</code>



<a href="#beancount.parser.booking_method" class="headerlink" title="Permanent link"></a></h2>

    <div class="doc doc-contents ">

      <p>Implementations of all the particular booking methods.
This code is used by the full booking algorithm.</p>



  <div class="doc doc-children">









  <div class="doc doc-object doc-class">



<h3 id="beancount.parser.booking_method.AmbiguousMatchError" class="doc doc-heading">
        <code>
beancount.parser.booking_method.AmbiguousMatchError            (<span title="tuple">tuple</span>)
        </code>



<a href="#beancount.parser.booking_method.AmbiguousMatchError" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>AmbiguousMatchError(source, message, entry)</p>




  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.booking_method.AmbiguousMatchError.__getnewargs__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_method.AmbiguousMatchError.__getnewargs__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.booking_method.AmbiguousMatchError.__getnewargs__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return self as a plain tuple.  Used by copy and pickle.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_method.py</code></summary>
          <pre class="highlight"><code class="language-python">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.booking_method.AmbiguousMatchError.__new__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_method.AmbiguousMatchError.__new__(_cls, source, message, entry)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
      <small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
  </span>

<a href="#beancount.parser.booking_method.AmbiguousMatchError.__new__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Create new instance of AmbiguousMatchError(source, message, entry)</p>

    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.booking_method.AmbiguousMatchError.__replace__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_method.AmbiguousMatchError.__replace__(/, self, **kwds)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.booking_method.AmbiguousMatchError.__replace__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a new AmbiguousMatchError object replacing specified fields with new values</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_method.py</code></summary>
          <pre class="highlight"><code class="language-python">def _replace(self, /, **kwds):
    result = self._make(_map(kwds.pop, field_names, self))
    if kwds:
        raise TypeError(f'Got unexpected field names: {list(kwds)!r}')
    return result
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.booking_method.AmbiguousMatchError.__repr__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_method.AmbiguousMatchError.__repr__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.booking_method.AmbiguousMatchError.__repr__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a nicely formatted representation string</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_method.py</code></summary>
          <pre class="highlight"><code class="language-python">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>




  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.booking_method.booking_method_AVERAGE" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_method.booking_method_AVERAGE(entry, posting, matches)</code>


<a href="#beancount.parser.booking_method.booking_method_AVERAGE" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>AVERAGE booking method implementation.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_method.py</code></summary>
          <pre class="highlight"><code class="language-python">def booking_method_AVERAGE(entry, posting, matches):
    """AVERAGE booking method implementation."""
    booked_reductions = []
    booked_matches = []
    errors = [AmbiguousMatchError(entry.meta, "AVERAGE method is not supported", entry)]
    return booked_reductions, booked_matches, errors, False

    # FIXME: Future implementation here.
    # pylint: disable=unreachable
    if False: # pylint: disable=using-constant-test
        # DISABLED - This is the code for AVERAGE, which is currently disabled.

        # If there is more than a single match we need to ultimately merge the
        # postings. Also, if the reducing posting provides a specific cost, we
        # need to update the cost basis as well. Both of these cases are carried
        # out by removing all the matches and readding them later on.
        if len(matches) == 1 and (
                not isinstance(posting.cost.number_per, Decimal) and
                not isinstance(posting.cost.number_total, Decimal)):
            # There is no cost. Just reduce the one leg. This should be the
            # normal case if we always merge augmentations and the user lets
            # Beancount deal with the cost.
            match = matches[0]
            sign = -1 if posting.units.number &lt; ZERO else 1
            number = min(abs(match.units.number), abs(posting.units.number))
            match_units = Amount(number * sign, match.units.currency)
            booked_reductions.append(posting._replace(units=match_units, cost=match.cost))
            insufficient = (match_units.number != posting.units.number)
        else:
            # Merge the matching postings to a single one.
            merged_units = inventory.Inventory()
            merged_cost = inventory.Inventory()
            for match in matches:
                merged_units.add_amount(match.units)
                merged_cost.add_amount(convert.get_weight(match))
            if len(merged_units) != 1 or len(merged_cost) != 1:
                errors.append(
                    AmbiguousMatchError(
                        entry.meta,
                        'Cannot merge positions in multiple currencies: {}'.format(
                            ', '.join(position.to_string(match_posting)
                                      for match_posting in matches)), entry))
            else:
                if (isinstance(posting.cost.number_per, Decimal) or
                    isinstance(posting.cost.number_total, Decimal)):
                    errors.append(
                        AmbiguousMatchError(
                            entry.meta,
                            "Explicit cost reductions aren't supported yet: {}".format(
                                position.to_string(posting)), entry))
                else:
                    # Insert postings to remove all the matches.
                    booked_reductions.extend(
                        posting._replace(units=-match.units, cost=match.cost,
                                         flag=flags.FLAG_MERGING)
                        for match in matches)
                    units = merged_units[0].units
                    date = matches[0].cost.date  ## FIXME: Select which one,
                                                 ## oldest or latest.
                    cost_units = merged_cost[0].units
                    cost = Cost(cost_units.number/units.number, cost_units.currency,
                                date, None)

                    # Insert a posting to refill those with a replacement match.
                    booked_reductions.append(
                        posting._replace(units=units, cost=cost, flag=flags.FLAG_MERGING))

                    # Now, match the reducing request against this lot.
                    booked_reductions.append(
                        posting._replace(units=posting.units, cost=cost))
                    insufficient = abs(posting.units.number) &gt; abs(units.number)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.booking_method.booking_method_FIFO" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_method.booking_method_FIFO(entry, posting, matches)</code>


<a href="#beancount.parser.booking_method.booking_method_FIFO" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>FIFO booking method implementation.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_method.py</code></summary>
          <pre class="highlight"><code class="language-python">def booking_method_FIFO(entry, posting, matches):
    """FIFO booking method implementation."""
    return _booking_method_xifo(entry, posting, matches, "date", False)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.booking_method.booking_method_HIFO" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_method.booking_method_HIFO(entry, posting, matches)</code>


<a href="#beancount.parser.booking_method.booking_method_HIFO" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>HIFO booking method implementation.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_method.py</code></summary>
          <pre class="highlight"><code class="language-python">def booking_method_HIFO(entry, posting, matches):
    """HIFO booking method implementation."""
    return _booking_method_xifo(entry, posting, matches, "number", True)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.booking_method.booking_method_LIFO" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_method.booking_method_LIFO(entry, posting, matches)</code>


<a href="#beancount.parser.booking_method.booking_method_LIFO" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>LIFO booking method implementation.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_method.py</code></summary>
          <pre class="highlight"><code class="language-python">def booking_method_LIFO(entry, posting, matches):
    """LIFO booking method implementation."""
    return _booking_method_xifo(entry, posting, matches, "date", True)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.booking_method.booking_method_NONE" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_method.booking_method_NONE(entry, posting, matches)</code>


<a href="#beancount.parser.booking_method.booking_method_NONE" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>NONE booking method implementation.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_method.py</code></summary>
          <pre class="highlight"><code class="language-python">def booking_method_NONE(entry, posting, matches):
    """NONE booking method implementation."""

    # This never needs to match against any existing positions... we
    # disregard the matches, there's never any error. Note that this never
    # gets called in practice, we want to treat NONE postings as
    # augmentations. Default behaviour is to return them with their original
    # CostSpec, and the augmentation code will handle signaling an error if
    # there is insufficient detail to carry out the conversion to an
    # instance of Cost.

    # Note that it's an interesting question whether a reduction on an
    # account with NONE method which happens to match a single position
    # ought to be matched against it. We don't allow it for now.

    return [posting], [], False
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.booking_method.booking_method_STRICT" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_method.booking_method_STRICT(entry, posting, matches)</code>


<a href="#beancount.parser.booking_method.booking_method_STRICT" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Strict booking method. This method fails if there are ambiguous matches.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_method.py</code></summary>
          <pre class="highlight"><code class="language-python">def booking_method_STRICT(entry, posting, matches):
    """Strict booking method. This method fails if there are ambiguous matches.
    """
    booked_reductions = []
    booked_matches = []
    errors = []
    insufficient = False

    # In strict mode, we require at most a single matching posting.
    if len(matches) &gt; 1:
        # If the total requested to reduce matches the sum of all the
        # ambiguous postings, match against all of them.
        sum_matches = sum(p.units.number for p in matches)
        if sum_matches == -posting.units.number:
            booked_reductions.extend(
                posting._replace(units=-match.units, cost=match.cost)
                for match in matches)
        else:
            errors.append(
                AmbiguousMatchError(entry.meta,
                                    'Ambiguous matches for "{}": {}'.format(
                                        position.to_string(posting),
                                        ', '.join(position.to_string(match_posting)
                                                  for match_posting in matches)),
                                    entry))
    else:
        # Replace the posting's units and cost values.
        match = matches[0]
        sign = -1 if posting.units.number &lt; ZERO else 1
        number = min(abs(match.units.number), abs(posting.units.number))
        match_units = Amount(number * sign, match.units.currency)
        booked_reductions.append(posting._replace(units=match_units, cost=match.cost))
        booked_matches.append(match)
        insufficient = (match_units.number != posting.units.number)

    return booked_reductions, booked_matches, errors, insufficient
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.booking_method.booking_method_STRICT_WITH_SIZE" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_method.booking_method_STRICT_WITH_SIZE(entry, posting, matches)</code>


<a href="#beancount.parser.booking_method.booking_method_STRICT_WITH_SIZE" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Strict booking method, but disambiguate further with sizes.</p>
<p>This booking method applies the same algorithm as the STRICT method, but if
only one of the ambiguous lots matches the desired size, select that one
automatically.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_method.py</code></summary>
          <pre class="highlight"><code class="language-python">def booking_method_STRICT_WITH_SIZE(entry, posting, matches):
    """Strict booking method, but disambiguate further with sizes.

    This booking method applies the same algorithm as the STRICT method, but if
    only one of the ambiguous lots matches the desired size, select that one
    automatically.
    """
    (booked_reductions, booked_matches, errors,
     insufficient) = booking_method_STRICT(entry, posting, matches)

    # If we couldn't match strictly, attempt to find a match with the same
    # number of units. If there is one or more of these, accept the oldest lot.
    if errors and len(matches) &gt; 1:
        number = -posting.units.number
        matching_units = [match
                          for match in matches
                          if number == match.units.number]
        if matching_units:
            matching_units.sort(key=lambda match: match.cost.date)

            # Replace the posting's units and cost values.
            match = matching_units[0]
            booked_reductions.append(posting._replace(units=-match.units, cost=match.cost))
            booked_matches.append(match)
            insufficient = False
            errors = []

    return booked_reductions, booked_matches, errors, insufficient
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.booking_method.handle_ambiguous_matches" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.booking_method.handle_ambiguous_matches(entry, posting, matches, method)</code>


<a href="#beancount.parser.booking_method.handle_ambiguous_matches" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Handle ambiguous matches by dispatching to a particular method.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entry</strong> – The parent Transaction instance.</p></li>
            <li><p><strong>posting</strong> – An instance of Posting, the reducing posting which we're
attempting to match.</p></li>
            <li><p><strong>matches</strong> – A list of matching Position instances from the ante-inventory.
Those positions are known to already match the 'posting' spec.</p></li>
            <li><p><strong>methods</strong> – A mapping of account name to their corresponding booking
method.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p><code>A triple of
  booked_reductions</code> – A list of matched Posting instances, whose 'cost'
    attributes are ensured to be of type Cost.
  errors: A list of errors to be generated.
  insufficient: A boolean, true if we could not find enough matches to
  cover the entire position.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/booking_method.py</code></summary>
          <pre class="highlight"><code class="language-python">def handle_ambiguous_matches(entry, posting, matches, method):
    """Handle ambiguous matches by dispatching to a particular method.

    Args:
      entry: The parent Transaction instance.
      posting: An instance of Posting, the reducing posting which we're
        attempting to match.
      matches: A list of matching Position instances from the ante-inventory.
        Those positions are known to already match the 'posting' spec.
      methods: A mapping of account name to their corresponding booking
        method.
    Returns:
      A triple of
        booked_reductions: A list of matched Posting instances, whose 'cost'
          attributes are ensured to be of type Cost.
        errors: A list of errors to be generated.
        insufficient: A boolean, true if we could not find enough matches to
        cover the entire position.
    """
    assert isinstance(method, Booking), (
        "Invalid type: {}".format(method))
    assert matches, "Internal error: Invalid call with no matches"

    #method = globals()['booking_method_{}'.format(method.name)]
    method = _BOOKING_METHODS[method]
    (booked_reductions,
     booked_matches, errors, insufficient) = method(entry, posting, matches)
    if insufficient:
        errors.append(
            AmbiguousMatchError(entry.meta,
                                'Not enough lots to reduce "{}": {}'.format(
                                    position.to_string(posting),
                                    ', '.join(position.to_string(match_posting)
                                              for match_posting in matches)),
                                entry))

    return booked_reductions, booked_matches, errors
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="beancount.parser.cmptest" class="doc doc-heading">
        <code>beancount.parser.cmptest</code>



<a href="#beancount.parser.cmptest" class="headerlink" title="Permanent link"></a></h2>

    <div class="doc doc-contents ">

      <p>Support utilities for testing scripts.</p>



  <div class="doc doc-children">









  <div class="doc doc-object doc-class">



<h3 id="beancount.parser.cmptest.TestCase" class="doc doc-heading">
        <code>
beancount.parser.cmptest.TestCase            (<span title="unittest.case.TestCase">TestCase</span>)
        </code>



<a href="#beancount.parser.cmptest.TestCase" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">





  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.cmptest.TestCase.assertEqualEntries" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.cmptest.TestCase.assertEqualEntries(self, expected_entries, actual_entries, allow_incomplete=False)</code>


<a href="#beancount.parser.cmptest.TestCase.assertEqualEntries" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Check that two lists of entries are equal.</p>
<p>Entries can be provided either as a list of directives or as a
string.  In the latter case, the string is parsed with
beancount.parser.parse_string() and the resulting directives
list is used. If allow_incomplete is True, light-weight
booking is performed before comparing the directive lists,
allowing to compare transactions with incomplete postings.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>expected_entries</strong> – Expected entries.</p></li>
            <li><p><strong>actual_entries</strong> – Actual entries.</p></li>
            <li><p><strong>allow_incomplete</strong> – Perform booking before comparison.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Exceptions:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><code>AssertionError</code> – If the exception fails.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/cmptest.py</code></summary>
          <pre class="highlight"><code class="language-python">def assertEqualEntries(self, expected_entries, actual_entries, allow_incomplete=False):
    """Check that two lists of entries are equal.

    Entries can be provided either as a list of directives or as a
    string.  In the latter case, the string is parsed with
    beancount.parser.parse_string() and the resulting directives
    list is used. If allow_incomplete is True, light-weight
    booking is performed before comparing the directive lists,
    allowing to compare transactions with incomplete postings.

    Args:
      expected_entries: Expected entries.
      actual_entries: Actual entries.
      allow_incomplete: Perform booking before comparison.

    Raises:
      AssertionError: If the exception fails.

    """
    expected_entries = read_string_or_entries(expected_entries, allow_incomplete)
    actual_entries = read_string_or_entries(actual_entries, allow_incomplete)

    same, expected_missing, actual_missing = \
        compare.compare_entries(expected_entries, actual_entries)
    if not same:
        assert expected_missing or actual_missing, \
            "Missing is missing: {}, {}".format(expected_missing, actual_missing)
        oss = io.StringIO()
        if expected_missing:
            oss.write("Present in expected set and not in actual set:\n\n")
            for entry in expected_missing:
                oss.write(printer.format_entry(entry))
                oss.write('\n')
        if actual_missing:
            oss.write("Present in actual set and not in expected set:\n\n")
            for entry in actual_missing:
                oss.write(printer.format_entry(entry))
                oss.write('\n')
        self.fail(oss.getvalue())
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.cmptest.TestCase.assertExcludesEntries" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.cmptest.TestCase.assertExcludesEntries(self, subset_entries, entries, allow_incomplete=False)</code>


<a href="#beancount.parser.cmptest.TestCase.assertExcludesEntries" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Check that subset_entries is not included in entries.</p>
<p>Entries can be provided either as a list of directives or as a
string. In the latter case, the string is parsed with
beancount.parser.parse_string() and the resulting directives
list is used. If allow_incomplete is True, light-weight
booking is performed before comparing the directive lists,
allowing to compare transactions with incomplete postings.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>subset_entries</strong> – Subset entries.</p></li>
            <li><p><strong>entries</strong> – Entries.</p></li>
            <li><p><strong>allow_incomplete</strong> – Perform booking before comparison.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Exceptions:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><code>AssertionError</code> – If the exception fails.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/cmptest.py</code></summary>
          <pre class="highlight"><code class="language-python">def assertExcludesEntries(self, subset_entries, entries, allow_incomplete=False):
    """Check that subset_entries is not included in entries.

    Entries can be provided either as a list of directives or as a
    string. In the latter case, the string is parsed with
    beancount.parser.parse_string() and the resulting directives
    list is used. If allow_incomplete is True, light-weight
    booking is performed before comparing the directive lists,
    allowing to compare transactions with incomplete postings.

    Args:
      subset_entries: Subset entries.
      entries: Entries.
      allow_incomplete: Perform booking before comparison.

    Raises:
      AssertionError: If the exception fails.

    """
    subset_entries = read_string_or_entries(subset_entries, allow_incomplete)
    entries = read_string_or_entries(entries)

    excludes, extra = compare.excludes_entries(subset_entries, entries)
    if not excludes:
        assert extra, "Extra is empty: {}".format(extra)
        oss = io.StringIO()
        if extra:
            oss.write("Extra from from first/excluded set:\n\n")
            for entry in extra:
                oss.write(printer.format_entry(entry))
                oss.write('\n')
        self.fail(oss.getvalue())
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.cmptest.TestCase.assertIncludesEntries" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.cmptest.TestCase.assertIncludesEntries(self, subset_entries, entries, allow_incomplete=False)</code>


<a href="#beancount.parser.cmptest.TestCase.assertIncludesEntries" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Check that subset_entries is included in entries.</p>
<p>Entries can be provided either as a list of directives or as a
string.  In the latter case, the string is parsed with
beancount.parser.parse_string() and the resulting directives
list is used. If allow_incomplete is True, light-weight
booking is performed before comparing the directive lists,
allowing to compare transactions with incomplete postings.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>subset_entries</strong> – Subset entries.</p></li>
            <li><p><strong>entries</strong> – Entries.</p></li>
            <li><p><strong>allow_incomplete</strong> – Perform booking before comparison.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Exceptions:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><code>AssertionError</code> – If the exception fails.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/cmptest.py</code></summary>
          <pre class="highlight"><code class="language-python">def assertIncludesEntries(self, subset_entries, entries, allow_incomplete=False):
    """Check that subset_entries is included in entries.

    Entries can be provided either as a list of directives or as a
    string.  In the latter case, the string is parsed with
    beancount.parser.parse_string() and the resulting directives
    list is used. If allow_incomplete is True, light-weight
    booking is performed before comparing the directive lists,
    allowing to compare transactions with incomplete postings.

    Args:
      subset_entries: Subset entries.
      entries: Entries.
      allow_incomplete: Perform booking before comparison.

    Raises:
      AssertionError: If the exception fails.

    """
    subset_entries = read_string_or_entries(subset_entries, allow_incomplete)
    entries = read_string_or_entries(entries)

    includes, missing = compare.includes_entries(subset_entries, entries)
    if not includes:
        assert missing, "Missing is empty: {}".format(missing)
        oss = io.StringIO()
        if missing:
            oss.write("Missing from from expected set:\n\n")
            for entry in missing:
                oss.write(printer.format_entry(entry))
                oss.write('\n')
        self.fail(oss.getvalue())
</code></pre>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h3 id="beancount.parser.cmptest.TestError" class="doc doc-heading">
        <code>
beancount.parser.cmptest.TestError            (<span title="Exception">Exception</span>)
        </code>



<a href="#beancount.parser.cmptest.TestError" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Errors within the test implementation itself. These should never occur.</p>



    </div>

  </div>




  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.cmptest.read_string_or_entries" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.cmptest.read_string_or_entries(entries_or_str, allow_incomplete=False)</code>


<a href="#beancount.parser.cmptest.read_string_or_entries" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Read a string of entries or just entries.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries_or_str</strong> – Either a list of directives, or a string containing directives.</p></li>
            <li><p><strong>allow_incomplete</strong> – A boolean, true if we allow incomplete inputs and perform
light-weight booking.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A list of directives.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/cmptest.py</code></summary>
          <pre class="highlight"><code class="language-python">def read_string_or_entries(entries_or_str, allow_incomplete=False):
    """Read a string of entries or just entries.

    Args:
      entries_or_str: Either a list of directives, or a string containing directives.
      allow_incomplete: A boolean, true if we allow incomplete inputs and perform
        light-weight booking.
    Returns:
      A list of directives.
    """
    if isinstance(entries_or_str, str):
        entries, errors, options_map = parser.parse_string(
            textwrap.dedent(entries_or_str))

        if allow_incomplete:
            # Do a simplistic local conversion in order to call the comparison.
            entries = [_local_booking(entry) for entry in entries]
        else:
            # Don't accept incomplete entries either.
            if any(parser.is_entry_incomplete(entry) for entry in entries):
                raise TestError("Entries in assertions may not use interpolation.")

            entries, booking_errors = booking.book(entries, options_map)
            errors = errors + booking_errors

        # Don't tolerate errors.
        if errors:
            oss = io.StringIO()
            printer.print_errors(errors, file=oss)
            raise TestError("Unexpected errors in expected: {}".format(oss.getvalue()))

    else:
        assert isinstance(entries_or_str, list), "Expecting list: {}".format(entries_or_str)
        entries = entries_or_str

    return entries
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="beancount.parser.context" class="doc doc-heading">
        <code>beancount.parser.context</code>



<a href="#beancount.parser.context" class="headerlink" title="Permanent link"></a></h2>

    <div class="doc doc-contents ">

      <p>Produce a rendering of the account balances just before and after a
particular entry is applied.</p>



  <div class="doc doc-children">










  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.context.render_entry_context" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.context.render_entry_context(entries, options_map, entry, parsed_entry=None)</code>


<a href="#beancount.parser.context.render_entry_context" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Render the context before and after a particular transaction is applied.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> – A list of directives.</p></li>
            <li><p><strong>options_map</strong> – A dict of options, as produced by the parser.</p></li>
            <li><p><strong>entry</strong> – The entry instance which should be rendered. (Note that this object is
expected to be in the set of entries, not just structurally equal.)</p></li>
            <li><p><strong>parsed_entry</strong> – An optional incomplete, parsed but not booked nor interpolated
entry. If this is provided, this is used for inspecting the list of prior
accounts and it is also rendered.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A multiline string of text, which consists of the context before the
transaction is applied, the transaction itself, and the context after it
is applied. You can just print that, it is in form that is intended to be
consumed by the user.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/context.py</code></summary>
          <pre class="highlight"><code class="language-python">def render_entry_context(entries, options_map, entry, parsed_entry=None):
    """Render the context before and after a particular transaction is applied.

    Args:
      entries: A list of directives.
      options_map: A dict of options, as produced by the parser.
      entry: The entry instance which should be rendered. (Note that this object is
        expected to be in the set of entries, not just structurally equal.)
      parsed_entry: An optional incomplete, parsed but not booked nor interpolated
        entry. If this is provided, this is used for inspecting the list of prior
        accounts and it is also rendered.
    Returns:
      A multiline string of text, which consists of the context before the
      transaction is applied, the transaction itself, and the context after it
      is applied. You can just print that, it is in form that is intended to be
      consumed by the user.
    """
    oss = io.StringIO()
    pr = functools.partial(print, file=oss)
    header = "** {} --------------------------------"

    meta = entry.meta
    pr(header.format("Transaction Id"))
    pr()
    pr("Hash:{}".format(compare.hash_entry(entry)))
    pr("Location: {}:{}".format(meta["filename"], meta["lineno"]))
    pr()
    pr()

    # Get the list of accounts sorted by the order in which they appear in the
    # closest entry.
    order = {}
    if parsed_entry is None:
        parsed_entry = entry
    if isinstance(parsed_entry, data.Transaction):
        order = {posting.account: index
                 for index, posting in enumerate(parsed_entry.postings)}
    accounts = sorted(getters.get_entry_accounts(parsed_entry),
                      key=lambda account: order.get(account, 10000))

    # Accumulate the balances of these accounts up to the entry.
    balance_before, balance_after = interpolate.compute_entry_context(
        entries, entry, additional_accounts=accounts)

    # Create a format line for printing the contents of account balances.
    max_account_width = max(map(len, accounts)) if accounts else 1
    position_line = '{{:1}} {{:{width}}}  {{:&gt;49}}'.format(width=max_account_width)

    # Print the context before.
    pr(header.format("Balances before transaction"))
    pr()
    before_hashes = set()
    average_costs = {}
    for account in accounts:
        balance = balance_before[account]

        pc_balances = balance.split()
        for currency, pc_balance in pc_balances.items():
            if len(pc_balance) &gt; 1:
                average_costs[account] = pc_balance.average()

        positions = balance.get_positions()
        for position in positions:
            before_hashes.add((account, hash(position)))
            pr(position_line.format('', account, str(position)))
        if not positions:
            pr(position_line.format('', account, ''))
        pr()
    pr()

    # Print average cost per account, if relevant.
    if average_costs:
        pr(header.format("Average Costs"))
        pr()
        for account, average_cost in sorted(average_costs.items()):
            for position in average_cost:
                pr(position_line.format('', account, str(position)))
        pr()
        pr()

    # Print the entry itself.
    dcontext = options_map['dcontext']
    pr(header.format("Unbooked Transaction"))
    pr()
    if parsed_entry:
        printer.print_entry(parsed_entry, dcontext, render_weights=True, file=oss)
    pr()

    pr(header.format("Transaction"))
    pr()
    printer.print_entry(entry, dcontext, render_weights=True, file=oss)
    pr()

    if isinstance(entry, data.Transaction):
        pr(header.format("Residual and Tolerances"))
        pr()

        # Print residuals.
        residual = interpolate.compute_residual(entry.postings)
        if not residual.is_empty():
            # Note: We render the residual at maximum precision, for debugging.
            pr('Residual: {}'.format(residual))

        # Dump the tolerances used.
        tolerances = interpolate.infer_tolerances(entry.postings, options_map)
        if tolerances:
            pr('Tolerances: {}'.format(
                ', '.join('{}={}'.format(key, value)
                          for key, value in sorted(tolerances.items()))))

        # Compute the total cost basis.
        cost_basis = inventory.Inventory(
            pos for pos in entry.postings if pos.cost is not None
        ).reduce(convert.get_cost)
        if not cost_basis.is_empty():
            pr('Basis: {}'.format(cost_basis))
        pr()
        pr()

    # Print the context after.
    pr(header.format("Balances after transaction"))
    pr()
    for account in accounts:
        positions = balance_after[account].get_positions()
        for position in positions:
            changed = (account, hash(position)) not in before_hashes
            print(position_line.format('*' if changed else '', account, str(position)),
                  file=oss)
        if not positions:
            pr(position_line.format('', account, ''))
        pr()

    return oss.getvalue()
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.context.render_file_context" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.context.render_file_context(entries, options_map, filename, lineno)</code>


<a href="#beancount.parser.context.render_file_context" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Render the context before and after a particular transaction is applied.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> – A list of directives.</p></li>
            <li><p><strong>options_map</strong> – A dict of options, as produced by the parser.</p></li>
            <li><p><strong>filename</strong> – A string, the name of the file from which the transaction was parsed.</p></li>
            <li><p><strong>lineno</strong> – An integer, the line number in the file the transaction was parsed from.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A multiline string of text, which consists of the context before the
transaction is applied, the transaction itself, and the context after it
is applied. You can just print that, it is in form that is intended to be
consumed by the user.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/context.py</code></summary>
          <pre class="highlight"><code class="language-python">def render_file_context(entries, options_map, filename, lineno):
    """Render the context before and after a particular transaction is applied.

    Args:
      entries: A list of directives.
      options_map: A dict of options, as produced by the parser.
      filename: A string, the name of the file from which the transaction was parsed.
      lineno: An integer, the line number in the file the transaction was parsed from.
    Returns:
      A multiline string of text, which consists of the context before the
      transaction is applied, the transaction itself, and the context after it
      is applied. You can just print that, it is in form that is intended to be
      consumed by the user.
    """
    # Find the closest entry.
    closest_entry = data.find_closest(entries, filename, lineno)
    if closest_entry is None:
        raise SystemExit("No entry could be found before {}:{}".format(filename, lineno))

    # Run just the parser stage (no booking nor interpolation, which would
    # remove the postings) on the input file to produced the corresponding
    # unbooked transaction, so that we can get the list of accounts.
    if path.exists(filename):
        parsed_entries, _, __= parser.parse_file(filename)

        # Note: We cannot bisect as we cannot rely on sorting behavior from the parser.
        lineno = closest_entry.meta['lineno']
        closest_parsed_entries = [parsed_entry
                                  for parsed_entry in parsed_entries
                                  if parsed_entry.meta['lineno'] == lineno]
        if len(closest_parsed_entries) != 1:
            # This is an internal error, this should never occur.
            raise RuntimeError(
                "Parsed entry corresponding to real entry not found in original filename.")
        closest_parsed_entry = next(iter(closest_parsed_entries))
    else:
        closest_parsed_entry = None

    return render_entry_context(entries, options_map, closest_entry, closest_parsed_entry)
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="beancount.parser.grammar" class="doc doc-heading">
        <code>beancount.parser.grammar</code>



<a href="#beancount.parser.grammar" class="headerlink" title="Permanent link"></a></h2>

    <div class="doc doc-contents ">

      <p>Builder for Beancount grammar.</p>



  <div class="doc doc-children">










  <div class="doc doc-object doc-class">



<h3 id="beancount.parser.grammar.Builder" class="doc doc-heading">
        <code>
beancount.parser.grammar.Builder            (<a title="beancount.parser.lexer.LexBuilder" href="#beancount.parser.lexer.LexBuilder">LexBuilder</a>)
        </code>



<a href="#beancount.parser.grammar.Builder" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>A builder used by the lexer and grammar parser as callbacks to create
the data objects corresponding to rules parsed from the input file.</p>




  <div class="doc doc-children">










  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.account" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.account(self, filename, lineno, account)</code>


<a href="#beancount.parser.grammar.Builder.account" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Check account name validity.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>account</strong> – a str, the account name.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A string, the account name.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def account(self, filename, lineno, account):
    """Check account name validity.

    Args:
      account: a str, the account name.
    Returns:
      A string, the account name.
    """
    if not self.account_regexp.match(account):
        meta = new_metadata(filename, lineno)
        self.errors.append(
            ParserError(meta, "Invalid account name: {}".format(account), None))
    # Intern account names. This should reduces memory usage a
    # fair bit because these strings are repeated liberally.
    return self.accounts.setdefault(account, account)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.amount" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.amount(self, filename, lineno, number, currency)</code>


<a href="#beancount.parser.grammar.Builder.amount" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Process an amount grammar rule.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>number</strong> – a Decimal instance, the number of the amount.</p></li>
            <li><p><strong>currency</strong> – a currency object (a str, really, see CURRENCY above)</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>An instance of Amount.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def amount(self, filename, lineno, number, currency):
    """Process an amount grammar rule.

    Args:
      number: a Decimal instance, the number of the amount.
      currency: a currency object (a str, really, see CURRENCY above)
    Returns:
      An instance of Amount.
    """
    # Update the mapping that stores the parsed precisions.
    # Note: This is relatively slow, adds about 70ms because of number.as_tuple().
    self._dcupdate(number, currency)
    return Amount(number, currency)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.balance" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.balance(self, filename, lineno, date, account, amount, tolerance, kvlist)</code>


<a href="#beancount.parser.grammar.Builder.balance" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Process an assertion directive.</p>
<p>We produce no errors here by default. We replace the failing ones in the
routine that does the verification later one, that these have succeeded
or failed.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>filename</strong> – The current filename.</p></li>
            <li><p><strong>lineno</strong> – The current line number.</p></li>
            <li><p><strong>date</strong> – A datetime object.</p></li>
            <li><p><strong>account</strong> – A string, the account to balance.</p></li>
            <li><p><strong>amount</strong> – The expected amount, to be checked.</p></li>
            <li><p><strong>tolerance</strong> – The tolerance number.</p></li>
            <li><p><strong>kvlist</strong> – a list of KeyValue instances.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A new Balance object.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def balance(self, filename, lineno, date, account, amount, tolerance, kvlist):
    """Process an assertion directive.

    We produce no errors here by default. We replace the failing ones in the
    routine that does the verification later one, that these have succeeded
    or failed.

    Args:
      filename: The current filename.
      lineno: The current line number.
      date: A datetime object.
      account: A string, the account to balance.
      amount: The expected amount, to be checked.
      tolerance: The tolerance number.
      kvlist: a list of KeyValue instances.
    Returns:
      A new Balance object.
    """
    diff_amount = None
    meta = new_metadata(filename, lineno, kvlist)
    return Balance(meta, date, account, amount, tolerance, diff_amount)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.build_grammar_error" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.build_grammar_error(self, filename, lineno, exc_value, exc_type=None, exc_traceback=None)</code>


<a href="#beancount.parser.grammar.Builder.build_grammar_error" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Build a grammar error and appends it to the list of pending errors.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>filename</strong> – The current filename</p></li>
            <li><p><strong>lineno</strong> – The current line number</p></li>
            <li><p><strong>excvalue</strong> – The exception value, or a str, the message of the error.</p></li>
            <li><p><strong>exc_type</strong> – An exception type, if an exception occurred.</p></li>
            <li><p><strong>exc_traceback</strong> – A traceback object.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def build_grammar_error(self, filename, lineno, exc_value,
                        exc_type=None, exc_traceback=None):
    """Build a grammar error and appends it to the list of pending errors.

    Args:
      filename: The current filename
      lineno: The current line number
      excvalue: The exception value, or a str, the message of the error.
      exc_type: An exception type, if an exception occurred.
      exc_traceback: A traceback object.
    """
    if exc_type is not None:
        assert not isinstance(exc_value, str)
        strings = traceback.format_exception_only(exc_type, exc_value)
        tblist = traceback.extract_tb(exc_traceback)
        filename, lineno, _, __ = tblist[0]
        message = '{} ({}:{})'.format(strings[0], filename, lineno)
    else:
        message = str(exc_value)
    meta = new_metadata(filename, lineno)
    self.errors.append(
        ParserSyntaxError(meta, message, None))
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.close" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.close(self, filename, lineno, date, account, kvlist)</code>


<a href="#beancount.parser.grammar.Builder.close" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Process a close directive.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>filename</strong> – The current filename.</p></li>
            <li><p><strong>lineno</strong> – The current line number.</p></li>
            <li><p><strong>date</strong> – A datetime object.</p></li>
            <li><p><strong>account</strong> – A string, the name of the account.</p></li>
            <li><p><strong>kvlist</strong> – a list of KeyValue instances.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A new Close object.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def close(self, filename, lineno, date, account, kvlist):
    """Process a close directive.

    Args:
      filename: The current filename.
      lineno: The current line number.
      date: A datetime object.
      account: A string, the name of the account.
      kvlist: a list of KeyValue instances.
    Returns:
      A new Close object.
    """
    meta = new_metadata(filename, lineno, kvlist)
    return Close(meta, date, account)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.commodity" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.commodity(self, filename, lineno, date, currency, kvlist)</code>


<a href="#beancount.parser.grammar.Builder.commodity" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Process a close directive.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>filename</strong> – The current filename.</p></li>
            <li><p><strong>lineno</strong> – The current line number.</p></li>
            <li><p><strong>date</strong> – A datetime object.</p></li>
            <li><p><strong>currency</strong> – A string, the commodity being declared.</p></li>
            <li><p><strong>kvlist</strong> – a list of KeyValue instances.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A new Close object.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def commodity(self, filename, lineno, date, currency, kvlist):
    """Process a close directive.

    Args:
      filename: The current filename.
      lineno: The current line number.
      date: A datetime object.
      currency: A string, the commodity being declared.
      kvlist: a list of KeyValue instances.
    Returns:
      A new Close object.
    """
    meta = new_metadata(filename, lineno, kvlist)
    return Commodity(meta, date, currency)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.compound_amount" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.compound_amount(self, filename, lineno, number_per, number_total, currency)</code>


<a href="#beancount.parser.grammar.Builder.compound_amount" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Process an amount grammar rule.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>number_per</strong> – a Decimal instance, the number of the cost per share.</p></li>
            <li><p><strong>number_total</strong> – a Decimal instance, the number of the cost over all shares.</p></li>
            <li><p><strong>currency</strong> – a currency object (a str, really, see CURRENCY above)</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A triple of (Decimal, Decimal, currency string) to be processed further when
creating the final per-unit cost number.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def compound_amount(self, filename, lineno, number_per, number_total, currency):
    """Process an amount grammar rule.

    Args:
      number_per: a Decimal instance, the number of the cost per share.
      number_total: a Decimal instance, the number of the cost over all shares.
      currency: a currency object (a str, really, see CURRENCY above)
    Returns:
      A triple of (Decimal, Decimal, currency string) to be processed further when
      creating the final per-unit cost number.
    """
    # Update the mapping that stores the parsed precisions.
    # Note: This is relatively slow, adds about 70ms because of number.as_tuple().
    self._dcupdate(number_per, currency)
    self._dcupdate(number_total, currency)

    # Note that we are not able to reduce the value to a number per-share
    # here because we only get the number of units in the full lot spec.
    return CompoundAmount(number_per, number_total, currency)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.cost_merge" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.cost_merge(self, filename, lineno, _)</code>


<a href="#beancount.parser.grammar.Builder.cost_merge" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Create a 'merge cost' token.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def cost_merge(self, filename, lineno, _):
    """Create a 'merge cost' token."""
    return MERGE_COST
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.cost_spec" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.cost_spec(self, filename, lineno, cost_comp_list, is_total)</code>


<a href="#beancount.parser.grammar.Builder.cost_spec" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Process a cost_spec grammar rule.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>cost_comp_list</strong> – A list of CompoundAmount, a datetime.date, or
label ID strings.</p></li>
            <li><p><strong>is_total</strong> – Assume only the total cost is specified; reject the &lt;number&gt; # &lt;number&gt;
  syntax, that is, no compound amounts may be specified. This is used to support
  the {{...}} syntax.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A cost-info tuple of CompoundAmount, lot date and label string. Any of these
may be set to a sentinel indicating "unset".</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def cost_spec(self, filename, lineno, cost_comp_list, is_total):
    """Process a cost_spec grammar rule.

    Args:
      cost_comp_list: A list of CompoundAmount, a datetime.date, or
        label ID strings.
      is_total: Assume only the total cost is specified; reject the &lt;number&gt; # &lt;number&gt;
          syntax, that is, no compound amounts may be specified. This is used to support
          the {{...}} syntax.
    Returns:
      A cost-info tuple of CompoundAmount, lot date and label string. Any of these
      may be set to a sentinel indicating "unset".
    """
    if not cost_comp_list:
        return CostSpec(MISSING, None, MISSING, None, None, False)
    assert isinstance(cost_comp_list, list), (
        "Internal error in parser: {}".format(cost_comp_list))

    compound_cost = None
    date_ = None
    label = None
    merge = None
    for comp in cost_comp_list:
        if isinstance(comp, CompoundAmount):
            if compound_cost is None:
                compound_cost = comp
            else:
                self.errors.append(
                    ParserError(new_metadata(filename, lineno),
                                "Duplicate cost: '{}'.".format(comp), None))

        elif isinstance(comp, date):
            if date_ is None:
                date_ = comp
            else:
                self.errors.append(
                    ParserError(new_metadata(filename, lineno),
                                "Duplicate date: '{}'.".format(comp), None))

        elif comp is MERGE_COST:
            if merge is None:
                merge = True
                self.errors.append(
                    ParserError(new_metadata(filename, lineno),
                                "Cost merging is not supported yet", None))
            else:
                self.errors.append(
                    ParserError(new_metadata(filename, lineno),
                                "Duplicate merge-cost spec", None))

        else:
            assert isinstance(comp, str), (
                "Currency component is not string: '{}'".format(comp))
            if label is None:
                label = comp
            else:
                self.errors.append(
                    ParserError(new_metadata(filename, lineno),
                                "Duplicate label: '{}'.".format(comp), None))

    # If there was a cost_comp_list, thus a "{...}" cost basis spec, you must
    # indicate that by creating a CompoundAmount(), always.

    if compound_cost is None:
        number_per, number_total, currency = MISSING, None, MISSING
    else:
        number_per, number_total, currency = compound_cost
        if is_total:
            if number_total is not None:
                self.errors.append(
                    ParserError(
                        new_metadata(filename, lineno),
                        ("Per-unit cost may not be specified using total cost "
                         "syntax: '{}'; ignoring per-unit cost").format(compound_cost),
                        None))
                # Ignore per-unit number.
                number_per = ZERO
            else:
                # There's a single number specified; interpret it as a total cost.
                number_total = number_per
                number_per = ZERO

    if merge is None:
        merge = False

    return CostSpec(number_per, number_total, currency, date_, label, merge)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.custom" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.custom(self, filename, lineno, date, dir_type, custom_values, kvlist)</code>


<a href="#beancount.parser.grammar.Builder.custom" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Process a custom directive.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>filename</strong> – the current filename.</p></li>
            <li><p><strong>lineno</strong> – the current line number.</p></li>
            <li><p><strong>date</strong> – a datetime object.</p></li>
            <li><p><strong>dir_type</strong> – A string, a type for the custom directive being parsed.</p></li>
            <li><p><strong>custom_values</strong> – A list of the various tokens seen on the same line.</p></li>
            <li><p><strong>kvlist</strong> – a list of KeyValue instances.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A new Custom object.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def custom(self, filename, lineno, date, dir_type, custom_values, kvlist):
    """Process a custom directive.

    Args:
      filename: the current filename.
      lineno: the current line number.
      date: a datetime object.
      dir_type: A string, a type for the custom directive being parsed.
      custom_values: A list of the various tokens seen on the same line.
      kvlist: a list of KeyValue instances.
    Returns:
      A new Custom object.
    """
    meta = new_metadata(filename, lineno, kvlist)
    return Custom(meta, date, dir_type, custom_values)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.custom_value" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.custom_value(self, filename, lineno, value, dtype=None)</code>


<a href="#beancount.parser.grammar.Builder.custom_value" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Create a custom value object, along with its type.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>value</strong> – One of the accepted custom values.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A pair of (value, dtype) where 'dtype' is the datatype is that of the
value.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def custom_value(self, filename, lineno, value, dtype=None):
    """Create a custom value object, along with its type.

    Args:
      value: One of the accepted custom values.
    Returns:
      A pair of (value, dtype) where 'dtype' is the datatype is that of the
      value.
    """
    if dtype is None:
        dtype = type(value)
    return ValueType(value, dtype)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.document" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.document(self, filename, lineno, date, account, document_filename, tags_links, kvlist)</code>


<a href="#beancount.parser.grammar.Builder.document" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Process a document directive.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>filename</strong> – the current filename.</p></li>
            <li><p><strong>lineno</strong> – the current line number.</p></li>
            <li><p><strong>date</strong> – a datetime object.</p></li>
            <li><p><strong>account</strong> – an Account instance.</p></li>
            <li><p><strong>document_filename</strong> – a str, the name of the document file.</p></li>
            <li><p><strong>tags_links</strong> – The current TagsLinks accumulator.</p></li>
            <li><p><strong>kvlist</strong> – a list of KeyValue instances.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A new Document object.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def document(self, filename, lineno, date, account, document_filename, tags_links,
             kvlist):
    """Process a document directive.

    Args:
      filename: the current filename.
      lineno: the current line number.
      date: a datetime object.
      account: an Account instance.
      document_filename: a str, the name of the document file.
      tags_links: The current TagsLinks accumulator.
      kvlist: a list of KeyValue instances.
    Returns:
      A new Document object.
    """
    meta = new_metadata(filename, lineno, kvlist)
    if not path.isabs(document_filename):
        document_filename = path.abspath(path.join(path.dirname(filename),
                                                   document_filename))
    tags, links = self._finalize_tags_links(tags_links.tags, tags_links.links)
    return Document(meta, date, account, document_filename, tags, links)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.event" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.event(self, filename, lineno, date, event_type, description, kvlist)</code>


<a href="#beancount.parser.grammar.Builder.event" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Process an event directive.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>filename</strong> – the current filename.</p></li>
            <li><p><strong>lineno</strong> – the current line number.</p></li>
            <li><p><strong>date</strong> – a datetime object.</p></li>
            <li><p><strong>event_type</strong> – a str, the name of the event type.</p></li>
            <li><p><strong>description</strong> – a str, the event value, the contents.</p></li>
            <li><p><strong>kvlist</strong> – a list of KeyValue instances.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A new Event object.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def event(self, filename, lineno, date, event_type, description, kvlist):
    """Process an event directive.

    Args:
      filename: the current filename.
      lineno: the current line number.
      date: a datetime object.
      event_type: a str, the name of the event type.
      description: a str, the event value, the contents.
      kvlist: a list of KeyValue instances.
    Returns:
      A new Event object.
    """
    meta = new_metadata(filename, lineno, kvlist)
    return Event(meta, date, event_type, description)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.finalize" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.finalize(self)</code>


<a href="#beancount.parser.grammar.Builder.finalize" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Finalize the parser, check for final errors and return the triple.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p><code>A triple of
  entries</code> – A list of parsed directives, which may need completion.
  errors: A list of errors, hopefully empty.
  options_map: A dict of options.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def finalize(self):
    """Finalize the parser, check for final errors and return the triple.

    Returns:
      A triple of
        entries: A list of parsed directives, which may need completion.
        errors: A list of errors, hopefully empty.
        options_map: A dict of options.
    """
    # If the user left some tags unbalanced, issue an error.
    for tag in self.tags:
        meta = new_metadata(self.options['filename'], 0)
        self.errors.append(
            ParserError(meta, "Unbalanced pushed tag: '{}'".format(tag), None))

    # If the user left some metadata unpopped, issue an error.
    for key, value_list in self.meta.items():
        meta = new_metadata(self.options['filename'], 0)
        self.errors.append(
            ParserError(meta, (
                "Unbalanced metadata key '{}'; leftover metadata '{}'").format(
                    key, ', '.join(value_list)), None))

    # Weave the commas option in the DisplayContext itself, so it propagates
    # everywhere it is used automatically.
    self.dcontext.set_commas(self.options['render_commas'])

    return (self.get_entries(), self.errors, self.get_options())
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.get_entries" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.get_entries(self)</code>


<a href="#beancount.parser.grammar.Builder.get_entries" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return the accumulated entries.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A list of sorted directives.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def get_entries(self):
    """Return the accumulated entries.

    Returns:
      A list of sorted directives.
    """
    return sorted(self.entries, key=data.entry_sortkey)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.get_long_string_maxlines" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.get_long_string_maxlines(self)</code>


<a href="#beancount.parser.grammar.Builder.get_long_string_maxlines" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>See base class.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def get_long_string_maxlines(self):
    """See base class."""
    return self.options['long_string_maxlines']
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.get_options" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.get_options(self)</code>


<a href="#beancount.parser.grammar.Builder.get_options" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return the final options map.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A dict of option names to options.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def get_options(self):
    """Return the final options map.

    Returns:
      A dict of option names to options.
    """
    # Build and store the inferred DisplayContext instance.
    self.options['dcontext'] = self.dcontext

    return self.options
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.handle_list" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.handle_list(self, filename, lineno, object_list, new_object)</code>


<a href="#beancount.parser.grammar.Builder.handle_list" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Handle a recursive list grammar rule, generically.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>object_list</strong> – the current list of objects.</p></li>
            <li><p><strong>new_object</strong> – the new object to be added.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>The new, updated list of objects.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def handle_list(self, filename, lineno, object_list, new_object):
    """Handle a recursive list grammar rule, generically.

    Args:
      object_list: the current list of objects.
      new_object: the new object to be added.
    Returns:
      The new, updated list of objects.
    """
    if object_list is None:
        object_list = []
    if new_object is not None:
        object_list.append(new_object)
    return object_list
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.include" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.include(self, filename, lineno, include_filename)</code>


<a href="#beancount.parser.grammar.Builder.include" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Process an include directive.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>filename</strong> – current filename.</p></li>
            <li><p><strong>lineno</strong> – current line number.</p></li>
            <li><p><strong>include_name</strong> – A string, the name of the file to include.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def include(self, filename, lineno, include_filename):
    """Process an include directive.

    Args:
      filename: current filename.
      lineno: current line number.
      include_name: A string, the name of the file to include.
    """
    self.options['include'].append(include_filename)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.key_value" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.key_value(self, filename, lineno, key, value)</code>


<a href="#beancount.parser.grammar.Builder.key_value" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Process a document directive.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>filename</strong> – The current filename.</p></li>
            <li><p><strong>lineno</strong> – The current line number.</p></li>
            <li><p><strong>date</strong> – A datetime object.</p></li>
            <li><p><strong>account</strong> – A string, the account the document relates to.</p></li>
            <li><p><strong>document_filename</strong> – A str, the name of the document file.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A new KeyValue object.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def key_value(self, filename, lineno, key, value):
    """Process a document directive.

    Args:
      filename: The current filename.
      lineno: The current line number.
      date: A datetime object.
      account: A string, the account the document relates to.
      document_filename: A str, the name of the document file.
    Returns:
      A new KeyValue object.
    """
    return KeyValue(key, value)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.note" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.note(self, filename, lineno, date, account, comment, tags_links, kvlist)</code>


<a href="#beancount.parser.grammar.Builder.note" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Process a note directive.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>filename</strong> – The current filename.</p></li>
            <li><p><strong>lineno</strong> – The current line number.</p></li>
            <li><p><strong>date</strong> – A datetime object.</p></li>
            <li><p><strong>account</strong> – A string, the account to attach the note to.</p></li>
            <li><p><strong>comment</strong> – A str, the note's comments contents.</p></li>
            <li><p><strong>kvlist</strong> – a list of KeyValue instances.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A new Note object.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def note(self, filename, lineno, date, account, comment, tags_links, kvlist):
    """Process a note directive.

    Args:
      filename: The current filename.
      lineno: The current line number.
      date: A datetime object.
      account: A string, the account to attach the note to.
      comment: A str, the note's comments contents.
      kvlist: a list of KeyValue instances.
    Returns:
      A new Note object.
    """
    meta = new_metadata(filename, lineno, kvlist)
    tags, links = self._finalize_tags_links(tags_links.tags, tags_links.links)
    return Note(meta, date, account, comment, tags, links)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.open" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.open(self, filename, lineno, date, account, currencies, booking_str, kvlist)</code>


<a href="#beancount.parser.grammar.Builder.open" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Process an open directive.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>filename</strong> – The current filename.</p></li>
            <li><p><strong>lineno</strong> – The current line number.</p></li>
            <li><p><strong>date</strong> – A datetime object.</p></li>
            <li><p><strong>account</strong> – A string, the name of the account.</p></li>
            <li><p><strong>currencies</strong> – A list of constraint currencies.</p></li>
            <li><p><strong>booking_str</strong> – A string, the booking method, or None if none was specified.</p></li>
            <li><p><strong>kvlist</strong> – a list of KeyValue instances.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A new Open object.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def open(self, filename, lineno, date, account, currencies, booking_str, kvlist):
    """Process an open directive.

    Args:
      filename: The current filename.
      lineno: The current line number.
      date: A datetime object.
      account: A string, the name of the account.
      currencies: A list of constraint currencies.
      booking_str: A string, the booking method, or None if none was specified.
      kvlist: a list of KeyValue instances.
    Returns:
      A new Open object.
    """
    meta = new_metadata(filename, lineno, kvlist)
    error = False
    if booking_str:
        try:
            # Note: Somehow the 'in' membership operator is not defined on Enum.
            booking = Booking[booking_str]
        except KeyError:
            # If the per-account method is invalid, set it to the global
            # default method and continue.
            booking = self.options['booking_method']
            error = True
    else:
        booking = None

    entry = Open(meta, date, account, currencies, booking)
    if error:
        self.errors.append(ParserError(meta,
                                       "Invalid booking method: {}".format(booking_str),
                                       entry))
    return entry
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.option" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.option(self, filename, lineno, key, value)</code>


<a href="#beancount.parser.grammar.Builder.option" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Process an option directive.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>filename</strong> – current filename.</p></li>
            <li><p><strong>lineno</strong> – current line number.</p></li>
            <li><p><strong>key</strong> – option's key (str)</p></li>
            <li><p><strong>value</strong> – option's value</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def option(self, filename, lineno, key, value):
    """Process an option directive.

    Args:
      filename: current filename.
      lineno: current line number.
      key: option's key (str)
      value: option's value
    """
    if key not in self.options:
        meta = new_metadata(filename, lineno)
        self.errors.append(
            ParserError(meta, "Invalid option: '{}'".format(key), None))

    elif key in options.READ_ONLY_OPTIONS:
        meta = new_metadata(filename, lineno)
        self.errors.append(
            ParserError(meta, "Option '{}' may not be set".format(key), None))

    else:
        option_descriptor = options.OPTIONS[key]

        # Issue a warning if the option is deprecated.
        if option_descriptor.deprecated:
            assert isinstance(option_descriptor.deprecated, str), "Internal error."
            meta = new_metadata(filename, lineno)
            self.errors.append(
                DeprecatedError(meta, option_descriptor.deprecated, None))

        # Rename the option if it has an alias.
        if option_descriptor.alias:
            key = option_descriptor.alias
            option_descriptor = options.OPTIONS[key]

        # Convert the value, if necessary.
        if option_descriptor.converter:
            try:
                value = option_descriptor.converter(value)
            except ValueError as exc:
                meta = new_metadata(filename, lineno)
                self.errors.append(
                    ParserError(meta,
                                "Error for option '{}': {}".format(key, exc),
                                None))
                return

        option = self.options[key]
        if isinstance(option, list):
            # Append to a list of values.
            option.append(value)

        elif isinstance(option, dict):
            # Set to a dict of values.
            if not (isinstance(value, tuple) and len(value) == 2):
                self.errors.append(
                    ParserError(
                        meta, "Error for option '{}': {}".format(key, value), None))
                return
            dict_key, dict_value = value
            option[dict_key] = dict_value

        elif isinstance(option, bool):
            # Convert to a boolean.
            if not isinstance(value, bool):
                value = (value.lower() in {'true', 'on'}) or (value == '1')
            self.options[key] = value

        else:
            # Set the value.
            self.options[key] = value

        # Refresh the list of valid account regexps as we go along.
        if key.startswith('name_'):
            # Update the set of valid account types.
            self.account_regexp = valid_account_regexp(self.options)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.pad" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.pad(self, filename, lineno, date, account, source_account, kvlist)</code>


<a href="#beancount.parser.grammar.Builder.pad" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Process a pad directive.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>filename</strong> – The current filename.</p></li>
            <li><p><strong>lineno</strong> – The current line number.</p></li>
            <li><p><strong>date</strong> – A datetime object.</p></li>
            <li><p><strong>account</strong> – A string, the account to be padded.</p></li>
            <li><p><strong>source_account</strong> – A string, the account to pad from.</p></li>
            <li><p><strong>kvlist</strong> – a list of KeyValue instances.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A new Pad object.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def pad(self, filename, lineno, date, account, source_account, kvlist):
    """Process a pad directive.

    Args:
      filename: The current filename.
      lineno: The current line number.
      date: A datetime object.
      account: A string, the account to be padded.
      source_account: A string, the account to pad from.
      kvlist: a list of KeyValue instances.
    Returns:
      A new Pad object.
    """
    meta = new_metadata(filename, lineno, kvlist)
    return Pad(meta, date, account, source_account)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.pipe_deprecated_error" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.pipe_deprecated_error(self, filename, lineno)</code>


<a href="#beancount.parser.grammar.Builder.pipe_deprecated_error" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Issue a 'Pipe deprecated' error.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>filename</strong> – The current filename</p></li>
            <li><p><strong>lineno</strong> – The current line number</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def pipe_deprecated_error(self, filename, lineno):
    """Issue a 'Pipe deprecated' error.

    Args:
      filename: The current filename
      lineno: The current line number
    """
    if self.options['allow_pipe_separator']:
        return
    meta = new_metadata(filename, lineno)
    self.errors.append(
        ParserSyntaxError(meta, "Pipe symbol is deprecated.", None))
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.plugin" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.plugin(self, filename, lineno, plugin_name, plugin_config)</code>


<a href="#beancount.parser.grammar.Builder.plugin" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Process a plugin directive.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>filename</strong> – current filename.</p></li>
            <li><p><strong>lineno</strong> – current line number.</p></li>
            <li><p><strong>plugin_name</strong> – A string, the name of the plugin module to import.</p></li>
            <li><p><strong>plugin_config</strong> – A string or None, an optional configuration string to
pass in to the plugin module.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def plugin(self, filename, lineno, plugin_name, plugin_config):
    """Process a plugin directive.

    Args:
      filename: current filename.
      lineno: current line number.
      plugin_name: A string, the name of the plugin module to import.
      plugin_config: A string or None, an optional configuration string to
        pass in to the plugin module.
    """
    self.options['plugin'].append((plugin_name, plugin_config))
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.popmeta" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.popmeta(self, filename, lineno, key)</code>


<a href="#beancount.parser.grammar.Builder.popmeta" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Removed a key off the current set of stacks.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>key</strong> – A string, a key to be removed from the meta dict.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def popmeta(self, filename, lineno, key):
    """Removed a key off the current set of stacks.

    Args:
      key: A string, a key to be removed from the meta dict.
    """
    try:
        if key not in self.meta:
            raise IndexError
        value_list = self.meta[key]
        value_list.pop(-1)
        if not value_list:
            self.meta.pop(key)
    except IndexError:
        meta = new_metadata(filename, lineno)
        self.errors.append(
            ParserError(meta,
                        "Attempting to pop absent metadata key: '{}'".format(key),
                        None))
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.poptag" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.poptag(self, filename, lineno, tag)</code>


<a href="#beancount.parser.grammar.Builder.poptag" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Pop a tag off the current set of stacks.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>tag</strong> – A string, a tag to be removed from the current set of tags.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def poptag(self, filename, lineno, tag):
    """Pop a tag off the current set of stacks.

    Args:
      tag: A string, a tag to be removed from the current set of tags.
    """
    try:
        self.tags.remove(tag)
    except ValueError:
        meta = new_metadata(filename, lineno)
        self.errors.append(
            ParserError(meta, "Attempting to pop absent tag: '{}'".format(tag), None))
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.posting" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.posting(self, filename, lineno, account, units, cost, price, istotal, flag)</code>


<a href="#beancount.parser.grammar.Builder.posting" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Process a posting grammar rule.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>filename</strong> – the current filename.</p></li>
            <li><p><strong>lineno</strong> – the current line number.</p></li>
            <li><p><strong>account</strong> – A string, the account of the posting.</p></li>
            <li><p><strong>units</strong> – An instance of Amount for the units.</p></li>
            <li><p><strong>cost</strong> – An instance of CostSpec for the cost.</p></li>
            <li><p><strong>price</strong> – Either None, or an instance of Amount that is the cost of the position.</p></li>
            <li><p><strong>istotal</strong> – A bool, True if the price is for the total amount being parsed, or
       False if the price is for each lot of the position.</p></li>
            <li><p><strong>flag</strong> – A string, one-character, the flag associated with this posting.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A new Posting object, with no parent entry.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def posting(self, filename, lineno, account, units, cost, price, istotal, flag):
    """Process a posting grammar rule.

    Args:
      filename: the current filename.
      lineno: the current line number.
      account: A string, the account of the posting.
      units: An instance of Amount for the units.
      cost: An instance of CostSpec for the cost.
      price: Either None, or an instance of Amount that is the cost of the position.
      istotal: A bool, True if the price is for the total amount being parsed, or
               False if the price is for each lot of the position.
      flag: A string, one-character, the flag associated with this posting.
    Returns:
      A new Posting object, with no parent entry.
    """
    meta = new_metadata(filename, lineno)

    # Prices may not be negative.
    if price and isinstance(price.number, Decimal) and price.number &lt; ZERO:
        self.errors.append(
            ParserError(meta, (
                "Negative prices are not allowed: {} "
                "(see http://furius.ca/beancount/doc/bug-negative-prices "
                "for workaround)"
            ).format(price), None))
        # Fix it and continue.
        price = Amount(abs(price.number), price.currency)

    # If the price is specified for the entire amount, compute the effective
    # price here and forget about that detail of the input syntax.
    if istotal:
        if units.number is MISSING:
            # Note: we could potentially do a better job and attempt to fix
            # this up after interpolation, but this syntax is pretty rare
            # anyway.
            self.errors.append(ParserError(
                meta, ("Total price on a posting without units: {}.").format(price),
                None))
            price = None
        else:
            price_number = price.number
            if price_number is not MISSING:
                price_number = (ZERO
                                if units.number == ZERO
                                else price_number/abs(units.number))
                price = Amount(price_number, price.currency)

    # Note: Allow zero prices because we need them for round-trips for
    # conversion entries.
    #
    # if price is not None and price.number == ZERO:
    #     self.errors.append(
    #         ParserError(meta, "Price is zero: {}".format(price), None))

    # If both cost and price are specified, the currencies must match, or
    # that is an error.
    if (cost is not None and
        price is not None and
        isinstance(cost.currency, str) and
        isinstance(price.currency, str) and
        cost.currency != price.currency):
        self.errors.append(
            ParserError(meta,
                        "Cost and price currencies must match: {} != {}".format(
                            cost.currency, price.currency), None))

    return Posting(account, units, cost, price, chr(flag) if flag else None, meta)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.price" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.price(self, filename, lineno, date, currency, amount, kvlist)</code>


<a href="#beancount.parser.grammar.Builder.price" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Process a price directive.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>filename</strong> – the current filename.</p></li>
            <li><p><strong>lineno</strong> – the current line number.</p></li>
            <li><p><strong>date</strong> – a datetime object.</p></li>
            <li><p><strong>currency</strong> – the currency to be priced.</p></li>
            <li><p><strong>amount</strong> – an instance of Amount, that is the price of the currency.</p></li>
            <li><p><strong>kvlist</strong> – a list of KeyValue instances.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A new Price object.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def price(self, filename, lineno, date, currency, amount, kvlist):
    """Process a price directive.

    Args:
      filename: the current filename.
      lineno: the current line number.
      date: a datetime object.
      currency: the currency to be priced.
      amount: an instance of Amount, that is the price of the currency.
      kvlist: a list of KeyValue instances.
    Returns:
      A new Price object.
    """
    meta = new_metadata(filename, lineno, kvlist)
    return Price(meta, date, currency, amount)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.pushmeta" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.pushmeta(self, filename, lineno, key_value)</code>


<a href="#beancount.parser.grammar.Builder.pushmeta" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Set a metadata field on the current key-value pairs to be added to transactions.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>key_value</strong> – A KeyValue instance, to be added to the dict of metadata.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def pushmeta(self, filename, lineno, key_value):
    """Set a metadata field on the current key-value pairs to be added to transactions.

    Args:
      key_value: A KeyValue instance, to be added to the dict of metadata.
    """
    key, value = key_value
    self.meta[key].append(value)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.pushtag" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.pushtag(self, filename, lineno, tag)</code>


<a href="#beancount.parser.grammar.Builder.pushtag" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Push a tag on the current set of tags.</p>
<p>Note that this does not need to be stack ordered.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>tag</strong> – A string, a tag to be added.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def pushtag(self, filename, lineno, tag):
    """Push a tag on the current set of tags.

    Note that this does not need to be stack ordered.

    Args:
      tag: A string, a tag to be added.
    """
    self.tags.append(tag)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.query" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.query(self, filename, lineno, date, query_name, query_string, kvlist)</code>


<a href="#beancount.parser.grammar.Builder.query" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Process a document directive.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>filename</strong> – the current filename.</p></li>
            <li><p><strong>lineno</strong> – the current line number.</p></li>
            <li><p><strong>date</strong> – a datetime object.</p></li>
            <li><p><strong>query_name</strong> – a str, the name of the query.</p></li>
            <li><p><strong>query_string</strong> – a str, the SQL query itself.</p></li>
            <li><p><strong>kvlist</strong> – a list of KeyValue instances.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A new Query object.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def query(self, filename, lineno, date, query_name, query_string, kvlist):
    """Process a document directive.

    Args:
      filename: the current filename.
      lineno: the current line number.
      date: a datetime object.
      query_name: a str, the name of the query.
      query_string: a str, the SQL query itself.
      kvlist: a list of KeyValue instances.
    Returns:
      A new Query object.
    """
    meta = new_metadata(filename, lineno, kvlist)
    return Query(meta, date, query_name, query_string)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.store_result" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.store_result(self, filename, lineno, entries)</code>


<a href="#beancount.parser.grammar.Builder.store_result" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Start rule stores the final result here.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> – A list of entries to store.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def store_result(self, filename, lineno, entries):
    """Start rule stores the final result here.

    Args:
      entries: A list of entries to store.
    """
    if entries:
        self.entries = entries
    # Also record the name of the processed file.
    self.options['filename'] = filename
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.tag_link_LINK" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.tag_link_LINK(self, filename, lineno, tags_links, link)</code>


<a href="#beancount.parser.grammar.Builder.tag_link_LINK" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Add a link to the TagsLinks accumulator.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>tags_links</strong> – The current TagsLinks accumulator.</p></li>
            <li><p><strong>link</strong> – A string, the new link to insert.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>An updated TagsLinks instance.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def tag_link_LINK(self, filename, lineno, tags_links, link):
    """Add a link to the TagsLinks accumulator.

    Args:
      tags_links: The current TagsLinks accumulator.
      link: A string, the new link to insert.
    Returns:
      An updated TagsLinks instance.
    """
    tags_links.links.add(link)
    return tags_links
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.tag_link_TAG" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.tag_link_TAG(self, filename, lineno, tags_links, tag)</code>


<a href="#beancount.parser.grammar.Builder.tag_link_TAG" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Add a tag to the TagsLinks accumulator.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>tags_links</strong> – The current TagsLinks accumulator.</p></li>
            <li><p><strong>tag</strong> – A string, the new tag to insert.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>An updated TagsLinks instance.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def tag_link_TAG(self, filename, lineno, tags_links, tag):
    """Add a tag to the TagsLinks accumulator.

    Args:
      tags_links: The current TagsLinks accumulator.
      tag: A string, the new tag to insert.
    Returns:
      An updated TagsLinks instance.
    """
    tags_links.tags.add(tag)
    return tags_links
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.tag_link_new" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.tag_link_new(self, filename, lineno)</code>


<a href="#beancount.parser.grammar.Builder.tag_link_new" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Create a new TagsLinks instance.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>An instance of TagsLinks, initialized with expected attributes.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def tag_link_new(self, filename, lineno):
    """Create a new TagsLinks instance.

    Returns:
      An instance of TagsLinks, initialized with expected attributes.
    """
    return TagsLinks(set(), set())
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.Builder.transaction" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.Builder.transaction(self, filename, lineno, date, flag, txn_strings, tags_links, posting_or_kv_list)</code>


<a href="#beancount.parser.grammar.Builder.transaction" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Process a transaction directive.</p>
<p>All the postings of the transaction are available at this point, and so the
the transaction is balanced here, incomplete postings are completed with the
appropriate position, and errors are being accumulated on the builder to be
reported later on.</p>
<p>This is the main routine that takes up most of the parsing time; be very
careful with modifications here, they have an impact on performance.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>filename</strong> – the current filename.</p></li>
            <li><p><strong>lineno</strong> – the current line number.</p></li>
            <li><p><strong>date</strong> – a datetime object.</p></li>
            <li><p><strong>flag</strong> – a str, one-character, the flag associated with this transaction.</p></li>
            <li><p><strong>txn_strings</strong> – A list of strings, possibly empty, possibly longer.</p></li>
            <li><p><strong>tags_links</strong> – A TagsLinks namedtuple of tags, and/or links.</p></li>
            <li><p><strong>posting_or_kv_list</strong> – a list of Posting or KeyValue instances, to be inserted in
this transaction, or None, if no postings have been declared.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A new Transaction object.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def transaction(self, filename, lineno, date, flag, txn_strings, tags_links,
                posting_or_kv_list):
    """Process a transaction directive.

    All the postings of the transaction are available at this point, and so the
    the transaction is balanced here, incomplete postings are completed with the
    appropriate position, and errors are being accumulated on the builder to be
    reported later on.

    This is the main routine that takes up most of the parsing time; be very
    careful with modifications here, they have an impact on performance.

    Args:
      filename: the current filename.
      lineno: the current line number.
      date: a datetime object.
      flag: a str, one-character, the flag associated with this transaction.
      txn_strings: A list of strings, possibly empty, possibly longer.
      tags_links: A TagsLinks namedtuple of tags, and/or links.
      posting_or_kv_list: a list of Posting or KeyValue instances, to be inserted in
        this transaction, or None, if no postings have been declared.
    Returns:
      A new Transaction object.
    """
    meta = new_metadata(filename, lineno)

    # Separate postings and key-values.
    explicit_meta = {}
    postings = []
    tags, links = tags_links.tags, tags_links.links
    if posting_or_kv_list:
        last_posting = None
        for posting_or_kv in posting_or_kv_list:
            if isinstance(posting_or_kv, Posting):
                postings.append(posting_or_kv)
                last_posting = posting_or_kv
            elif isinstance(posting_or_kv, TagsLinks):
                if postings:
                    self.errors.append(ParserError(
                        meta,
                        "Tags or links not allowed after first " +
                        "Posting: {}".format(posting_or_kv), None))
                else:
                    tags.update(posting_or_kv.tags)
                    links.update(posting_or_kv.links)
            else:
                if last_posting is None:
                    value = explicit_meta.setdefault(posting_or_kv.key,
                                                     posting_or_kv.value)
                    if value is not posting_or_kv.value:
                        self.errors.append(ParserError(
                            meta, "Duplicate metadata field on entry: {}".format(
                                posting_or_kv), None))
                else:
                    if last_posting.meta is None:
                        last_posting = last_posting._replace(meta={})
                        postings.pop(-1)
                        postings.append(last_posting)

                    value = last_posting.meta.setdefault(posting_or_kv.key,
                                                         posting_or_kv.value)
                    if value is not posting_or_kv.value:
                        self.errors.append(ParserError(
                            meta, "Duplicate posting metadata field: {}".format(
                                posting_or_kv), None))

    # Freeze the tags &amp; links or set to default empty values.
    tags, links = self._finalize_tags_links(tags, links)

    # Initialize the metadata fields from the set of active values.
    if self.meta:
        for key, value_list in self.meta.items():
            meta[key] = value_list[-1]

    # Add on explicitly defined values.
    if explicit_meta:
        meta.update(explicit_meta)

    # Unpack the transaction fields.
    payee_narration = self._unpack_txn_strings(txn_strings, meta)
    if payee_narration is None:
        return None
    payee, narration = payee_narration

    # We now allow a single posting when its balance is zero, so we
    # commented out the check below. If a transaction has a single posting
    # with a non-zero balance, it'll get caught below in the booking code.
    #
    # # Detect when a transaction does not have at least two legs.
    # if postings is None or len(postings) &lt; 2:
    #     self.errors.append(
    #         ParserError(meta,
    #                     "Transaction with only one posting: {}".format(postings),
    #                     None))
    #     return None

    # If there are no postings, make sure we insert a list object.
    if postings is None:
        postings = []

    # Create the transaction.
    return Transaction(meta, date, chr(flag),
                       payee, narration, tags, links, postings)
</code></pre>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h3 id="beancount.parser.grammar.CompoundAmount" class="doc doc-heading">
        <code>
beancount.parser.grammar.CompoundAmount            (<span title="tuple">tuple</span>)
        </code>



<a href="#beancount.parser.grammar.CompoundAmount" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>CompoundAmount(number_per, number_total, currency)</p>




  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.CompoundAmount.__getnewargs__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.CompoundAmount.__getnewargs__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.grammar.CompoundAmount.__getnewargs__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return self as a plain tuple.  Used by copy and pickle.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.CompoundAmount.__new__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.CompoundAmount.__new__(_cls, number_per, number_total, currency)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
      <small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
  </span>

<a href="#beancount.parser.grammar.CompoundAmount.__new__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Create new instance of CompoundAmount(number_per, number_total, currency)</p>

    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.CompoundAmount.__replace__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.CompoundAmount.__replace__(/, self, **kwds)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.grammar.CompoundAmount.__replace__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a new CompoundAmount object replacing specified fields with new values</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def _replace(self, /, **kwds):
    result = self._make(_map(kwds.pop, field_names, self))
    if kwds:
        raise TypeError(f'Got unexpected field names: {list(kwds)!r}')
    return result
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.CompoundAmount.__repr__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.CompoundAmount.__repr__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.grammar.CompoundAmount.__repr__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a nicely formatted representation string</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h3 id="beancount.parser.grammar.DeprecatedError" class="doc doc-heading">
        <code>
beancount.parser.grammar.DeprecatedError            (<span title="tuple">tuple</span>)
        </code>



<a href="#beancount.parser.grammar.DeprecatedError" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>DeprecatedError(source, message, entry)</p>




  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.DeprecatedError.__getnewargs__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.DeprecatedError.__getnewargs__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.grammar.DeprecatedError.__getnewargs__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return self as a plain tuple.  Used by copy and pickle.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.DeprecatedError.__new__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.DeprecatedError.__new__(_cls, source, message, entry)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
      <small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
  </span>

<a href="#beancount.parser.grammar.DeprecatedError.__new__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Create new instance of DeprecatedError(source, message, entry)</p>

    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.DeprecatedError.__replace__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.DeprecatedError.__replace__(/, self, **kwds)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.grammar.DeprecatedError.__replace__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a new DeprecatedError object replacing specified fields with new values</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def _replace(self, /, **kwds):
    result = self._make(_map(kwds.pop, field_names, self))
    if kwds:
        raise TypeError(f'Got unexpected field names: {list(kwds)!r}')
    return result
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.DeprecatedError.__repr__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.DeprecatedError.__repr__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.grammar.DeprecatedError.__repr__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a nicely formatted representation string</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h3 id="beancount.parser.grammar.KeyValue" class="doc doc-heading">
        <code>
beancount.parser.grammar.KeyValue            (<span title="tuple">tuple</span>)
        </code>



<a href="#beancount.parser.grammar.KeyValue" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>KeyValue(key, value)</p>




  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.KeyValue.__getnewargs__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.KeyValue.__getnewargs__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.grammar.KeyValue.__getnewargs__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return self as a plain tuple.  Used by copy and pickle.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.KeyValue.__new__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.KeyValue.__new__(_cls, key, value)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
      <small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
  </span>

<a href="#beancount.parser.grammar.KeyValue.__new__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Create new instance of KeyValue(key, value)</p>

    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.KeyValue.__replace__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.KeyValue.__replace__(/, self, **kwds)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.grammar.KeyValue.__replace__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a new KeyValue object replacing specified fields with new values</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def _replace(self, /, **kwds):
    result = self._make(_map(kwds.pop, field_names, self))
    if kwds:
        raise TypeError(f'Got unexpected field names: {list(kwds)!r}')
    return result
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.KeyValue.__repr__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.KeyValue.__repr__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.grammar.KeyValue.__repr__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a nicely formatted representation string</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h3 id="beancount.parser.grammar.ParserError" class="doc doc-heading">
        <code>
beancount.parser.grammar.ParserError            (<span title="tuple">tuple</span>)
        </code>



<a href="#beancount.parser.grammar.ParserError" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>ParserError(source, message, entry)</p>




  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.ParserError.__getnewargs__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.ParserError.__getnewargs__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.grammar.ParserError.__getnewargs__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return self as a plain tuple.  Used by copy and pickle.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.ParserError.__new__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.ParserError.__new__(_cls, source, message, entry)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
      <small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
  </span>

<a href="#beancount.parser.grammar.ParserError.__new__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Create new instance of ParserError(source, message, entry)</p>

    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.ParserError.__replace__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.ParserError.__replace__(/, self, **kwds)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.grammar.ParserError.__replace__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a new ParserError object replacing specified fields with new values</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def _replace(self, /, **kwds):
    result = self._make(_map(kwds.pop, field_names, self))
    if kwds:
        raise TypeError(f'Got unexpected field names: {list(kwds)!r}')
    return result
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.ParserError.__repr__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.ParserError.__repr__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.grammar.ParserError.__repr__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a nicely formatted representation string</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h3 id="beancount.parser.grammar.ParserSyntaxError" class="doc doc-heading">
        <code>
beancount.parser.grammar.ParserSyntaxError            (<span title="tuple">tuple</span>)
        </code>



<a href="#beancount.parser.grammar.ParserSyntaxError" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>ParserSyntaxError(source, message, entry)</p>




  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.ParserSyntaxError.__getnewargs__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.ParserSyntaxError.__getnewargs__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.grammar.ParserSyntaxError.__getnewargs__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return self as a plain tuple.  Used by copy and pickle.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.ParserSyntaxError.__new__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.ParserSyntaxError.__new__(_cls, source, message, entry)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
      <small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
  </span>

<a href="#beancount.parser.grammar.ParserSyntaxError.__new__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Create new instance of ParserSyntaxError(source, message, entry)</p>

    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.ParserSyntaxError.__replace__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.ParserSyntaxError.__replace__(/, self, **kwds)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.grammar.ParserSyntaxError.__replace__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a new ParserSyntaxError object replacing specified fields with new values</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def _replace(self, /, **kwds):
    result = self._make(_map(kwds.pop, field_names, self))
    if kwds:
        raise TypeError(f'Got unexpected field names: {list(kwds)!r}')
    return result
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.ParserSyntaxError.__repr__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.ParserSyntaxError.__repr__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.grammar.ParserSyntaxError.__repr__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a nicely formatted representation string</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h3 id="beancount.parser.grammar.TagsLinks" class="doc doc-heading">
        <code>
beancount.parser.grammar.TagsLinks            (<span title="tuple">tuple</span>)
        </code>



<a href="#beancount.parser.grammar.TagsLinks" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>TagsLinks(tags, links)</p>




  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.TagsLinks.__getnewargs__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.TagsLinks.__getnewargs__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.grammar.TagsLinks.__getnewargs__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return self as a plain tuple.  Used by copy and pickle.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.TagsLinks.__new__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.TagsLinks.__new__(_cls, tags, links)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
      <small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
  </span>

<a href="#beancount.parser.grammar.TagsLinks.__new__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Create new instance of TagsLinks(tags, links)</p>

    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.TagsLinks.__replace__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.TagsLinks.__replace__(/, self, **kwds)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.grammar.TagsLinks.__replace__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a new TagsLinks object replacing specified fields with new values</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def _replace(self, /, **kwds):
    result = self._make(_map(kwds.pop, field_names, self))
    if kwds:
        raise TypeError(f'Got unexpected field names: {list(kwds)!r}')
    return result
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.TagsLinks.__repr__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.TagsLinks.__repr__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.grammar.TagsLinks.__repr__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a nicely formatted representation string</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h3 id="beancount.parser.grammar.ValueType" class="doc doc-heading">
        <code>
beancount.parser.grammar.ValueType            (<span title="tuple">tuple</span>)
        </code>



<a href="#beancount.parser.grammar.ValueType" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>ValueType(value, dtype)</p>




  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.ValueType.__getnewargs__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.ValueType.__getnewargs__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.grammar.ValueType.__getnewargs__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return self as a plain tuple.  Used by copy and pickle.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.ValueType.__new__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.ValueType.__new__(_cls, value, dtype)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
      <small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
  </span>

<a href="#beancount.parser.grammar.ValueType.__new__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Create new instance of ValueType(value, dtype)</p>

    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.ValueType.__replace__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.ValueType.__replace__(/, self, **kwds)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.grammar.ValueType.__replace__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a new ValueType object replacing specified fields with new values</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def _replace(self, /, **kwds):
    result = self._make(_map(kwds.pop, field_names, self))
    if kwds:
        raise TypeError(f'Got unexpected field names: {list(kwds)!r}')
    return result
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.grammar.ValueType.__repr__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.ValueType.__repr__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.grammar.ValueType.__repr__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a nicely formatted representation string</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>




  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.grammar.valid_account_regexp" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.grammar.valid_account_regexp(options)</code>


<a href="#beancount.parser.grammar.valid_account_regexp" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Build a regexp to validate account names from the options.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>options</strong> – A dict of options, as per beancount.parser.options.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A string, a regular expression that will match all account names.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/grammar.py</code></summary>
          <pre class="highlight"><code class="language-python">def valid_account_regexp(options):
    """Build a regexp to validate account names from the options.

    Args:
      options: A dict of options, as per beancount.parser.options.
    Returns:
      A string, a regular expression that will match all account names.
    """
    names = map(options.__getitem__, ('name_assets',
                                      'name_liabilities',
                                      'name_equity',
                                      'name_income',
                                      'name_expenses'))

    # Replace the first term of the account regular expression with the specific
    # names allowed under the options configuration. This code is kept in sync
    # with {5672c7270e1e}.
    return regex.compile("(?:{})(?:{}{})+".format('|'.join(names),
                                                  account.sep,
                                                  account.ACC_COMP_NAME_RE))
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="beancount.parser.hashsrc" class="doc doc-heading">
        <code>beancount.parser.hashsrc</code>



<a href="#beancount.parser.hashsrc" class="headerlink" title="Permanent link"></a></h2>

    <div class="doc doc-contents ">

      <p>Compute a hash of the source files in order to warn when the source goes out of date.</p>



  <div class="doc doc-children">











  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.hashsrc.check_parser_source_files" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.hashsrc.check_parser_source_files(parser_module)</code>


<a href="#beancount.parser.hashsrc.check_parser_source_files" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Check the extension module's source hash and issue a warning if the
current source differs from that of the module.</p>
<p>If the source files aren't located in the Python source directory, ignore
the warning, we're probably running this from an installed based, in which
case we don't need to check anything (this check is useful only for people
running directly from source).</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/hashsrc.py</code></summary>
          <pre class="highlight"><code class="language-python">def check_parser_source_files(parser_module: types.ModuleType):
    """Check the extension module's source hash and issue a warning if the
    current source differs from that of the module.

    If the source files aren't located in the Python source directory, ignore
    the warning, we're probably running this from an installed based, in which
    case we don't need to check anything (this check is useful only for people
    running directly from source).
    """
    parser_source_hash = hash_parser_source_files()
    if parser_source_hash is None:
        return
    if parser_module.SOURCE_HASH and parser_module.SOURCE_HASH != parser_source_hash:
        warnings.warn(
            ("The Beancount parser C extension module is out-of-date ('{}' != '{}'). "
             "You need to rebuild.").format(parser_module.SOURCE_HASH, parser_source_hash))
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.hashsrc.gen_include" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.hashsrc.gen_include()</code>


<a href="#beancount.parser.hashsrc.gen_include" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Generate an include file for the parser source hash.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/hashsrc.py</code></summary>
          <pre class="highlight"><code class="language-python">def gen_include():
    """Generate an include file for the parser source hash."""
    return textwrap.dedent("""\
      #ifndef __BEANCOUNT_PARSER_PARSE_SOURCE_HASH_H__
      #define __BEANCOUNT_PARSER_PARSE_SOURCE_HASH_H__

      #define PARSER_SOURCE_HASH {source_hash}

      #endif // __BEANCOUNT_PARSER_PARSE_SOURCE_HASH_H__
    """.format(source_hash=hash_parser_source_files()))
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.hashsrc.hash_parser_source_files" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.hashsrc.hash_parser_source_files()</code>


<a href="#beancount.parser.hashsrc.hash_parser_source_files" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Compute a unique hash of the parser's Python code in order to bake that into
the extension module. This is used at load-time to verify that the extension
module and the corresponding Python codes match each other. If not, it
issues a warning that you should rebuild your extension module.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A string, the hexadecimal unique hash of relevant source code that should
trigger a recompilation.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/hashsrc.py</code></summary>
          <pre class="highlight"><code class="language-python">def hash_parser_source_files():
    """Compute a unique hash of the parser's Python code in order to bake that into
    the extension module. This is used at load-time to verify that the extension
    module and the corresponding Python codes match each other. If not, it
    issues a warning that you should rebuild your extension module.

    Returns:
      A string, the hexadecimal unique hash of relevant source code that should
      trigger a recompilation.
    """
    md5 = hashlib.md5()
    for filename in PARSER_SOURCE_FILES:
        fullname = path.join(path.dirname(__file__), filename)
        if not path.exists(fullname):
            return None
        with open(fullname, 'rb') as file:
            md5.update(file.read())
    # Note: Prepend a character in front of the hash because under Windows MSDEV
    # removes escapes, and if the hash starts with a number it fails to
    # recognize this is a string. A small compromise for portability.
    return md5.hexdigest()
</code></pre>
        </details>
    </div>

  </div>







  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="beancount.parser.lexer" class="doc doc-heading">
        <code>beancount.parser.lexer</code>



<a href="#beancount.parser.lexer" class="headerlink" title="Permanent link"></a></h2>

    <div class="doc doc-contents ">

      <p>Beancount syntax lexer.</p>



  <div class="doc doc-children">









  <div class="doc doc-object doc-class">



<h3 id="beancount.parser.lexer.LexBuilder" class="doc doc-heading">
        <code>
beancount.parser.lexer.LexBuilder        </code>



<a href="#beancount.parser.lexer.LexBuilder" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>A builder used only for building lexer objects.</p>




  <div class="doc doc-children">










  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.lexer.LexBuilder.build_lexer_error" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.lexer.LexBuilder.build_lexer_error(self, filename, lineno, message)</code>


<a href="#beancount.parser.lexer.LexBuilder.build_lexer_error" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Build a lexer error and appends it to the list of pending errors.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>message</strong> – The message of the error.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/lexer.py</code></summary>
          <pre class="highlight"><code class="language-python">def build_lexer_error(self, filename, lineno, message): # {0e31aeca3363}
    """Build a lexer error and appends it to the list of pending errors.

    Args:
      message: The message of the error.
    """
    self.errors.append(
        LexerError(new_metadata(filename, lineno), str(message), None))
</code></pre>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h3 id="beancount.parser.lexer.LexerError" class="doc doc-heading">
        <code>
beancount.parser.lexer.LexerError            (<span title="tuple">tuple</span>)
        </code>



<a href="#beancount.parser.lexer.LexerError" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>LexerError(source, message, entry)</p>




  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.lexer.LexerError.__getnewargs__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.lexer.LexerError.__getnewargs__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.lexer.LexerError.__getnewargs__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return self as a plain tuple.  Used by copy and pickle.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/lexer.py</code></summary>
          <pre class="highlight"><code class="language-python">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.lexer.LexerError.__new__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.lexer.LexerError.__new__(_cls, source, message, entry)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
      <small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
  </span>

<a href="#beancount.parser.lexer.LexerError.__new__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Create new instance of LexerError(source, message, entry)</p>

    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.lexer.LexerError.__replace__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.lexer.LexerError.__replace__(/, self, **kwds)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.lexer.LexerError.__replace__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a new LexerError object replacing specified fields with new values</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/lexer.py</code></summary>
          <pre class="highlight"><code class="language-python">def _replace(self, /, **kwds):
    result = self._make(_map(kwds.pop, field_names, self))
    if kwds:
        raise TypeError(f'Got unexpected field names: {list(kwds)!r}')
    return result
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.lexer.LexerError.__repr__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.lexer.LexerError.__repr__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.lexer.LexerError.__repr__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a nicely formatted representation string</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/lexer.py</code></summary>
          <pre class="highlight"><code class="language-python">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>




  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.lexer.lex_iter" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.lexer.lex_iter(file, builder=None)</code>


<a href="#beancount.parser.lexer.lex_iter" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>An iterator that yields all the tokens in the given file.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>file</strong> – A string, the filename to run the lexer on, or a file object.</p></li>
            <li><p><strong>builder</strong> – A builder of your choice. If not specified, a LexBuilder is
used and discarded (along with its errors).</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>      <p>Yields:
  All the tokens in the input file as <code>(token, lineno, text,
  value)</code> tuples where <code>token</code> is a string representing the
  token kind, <code>lineno</code> is the line number in the input file
  where the token was matched, <code>mathed</code> is a bytes object
  containing the exact text matched, and <code>value</code> is the semantic
  value of the token or None.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/lexer.py</code></summary>
          <pre class="highlight"><code class="language-python">def lex_iter(file, builder=None):
    """An iterator that yields all the tokens in the given file.

    Args:
      file: A string, the filename to run the lexer on, or a file object.
      builder: A builder of your choice. If not specified, a LexBuilder is
        used and discarded (along with its errors).
    Yields:
      All the tokens in the input file as ``(token, lineno, text,
      value)`` tuples where ``token`` is a string representing the
      token kind, ``lineno`` is the line number in the input file
      where the token was matched, ``mathed`` is a bytes object
      containing the exact text matched, and ``value`` is the semantic
      value of the token or None.
    """
    with contextlib.ExitStack() as ctx:
        # It would be more appropriate here to check for io.RawIOBase but
        # that does not work for io.BytesIO despite it implementing the
        # readinto() method.
        if not isinstance(file, io.IOBase):
            file = ctx.enter_context(open(file, 'rb'))
        if builder is None:
            builder = LexBuilder()
        parser = _parser.Parser(builder)
        yield from parser.lex(file)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.lexer.lex_iter_string" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.lexer.lex_iter_string(string, builder=None, **kwargs)</code>


<a href="#beancount.parser.lexer.lex_iter_string" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>An iterator that yields all the tokens in the given string.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>string</strong> – a str or bytes, the contents of the ledger to be parsed.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>An iterator, see <code>lex_iter()</code> for details.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/lexer.py</code></summary>
          <pre class="highlight"><code class="language-python">def lex_iter_string(string, builder=None, **kwargs):
    """An iterator that yields all the tokens in the given string.

    Args:
      string: a str or bytes, the contents of the ledger to be parsed.
    Returns:
      An iterator, see ``lex_iter()`` for details.
    """
    if not isinstance(string, bytes):
        string = string.encode('utf8')
    file = io.BytesIO(string)
    yield from lex_iter(file, builder=builder, **kwargs)
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="beancount.parser.options" class="doc doc-heading">
        <code>beancount.parser.options</code>



<a href="#beancount.parser.options" class="headerlink" title="Permanent link"></a></h2>

    <div class="doc doc-contents ">

      <p>Declaration of options and their default values.</p>



  <div class="doc doc-children">
















  <div class="doc doc-object doc-class">



<h3 id="beancount.parser.options.OptDesc" class="doc doc-heading">
        <code>
beancount.parser.options.OptDesc            (<span title="tuple">tuple</span>)
        </code>



<a href="#beancount.parser.options.OptDesc" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>OptDesc(name, default_value, example_value, converter, deprecated, alias)</p>




  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.options.OptDesc.__getnewargs__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.options.OptDesc.__getnewargs__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.options.OptDesc.__getnewargs__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return self as a plain tuple.  Used by copy and pickle.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/options.py</code></summary>
          <pre class="highlight"><code class="language-python">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.options.OptDesc.__new__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.options.OptDesc.__new__(_cls, name, default_value, example_value, converter, deprecated, alias)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
      <small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
  </span>

<a href="#beancount.parser.options.OptDesc.__new__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Create new instance of OptDesc(name, default_value, example_value, converter, deprecated, alias)</p>

    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.options.OptDesc.__replace__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.options.OptDesc.__replace__(/, self, **kwds)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.options.OptDesc.__replace__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a new OptDesc object replacing specified fields with new values</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/options.py</code></summary>
          <pre class="highlight"><code class="language-python">def _replace(self, /, **kwds):
    result = self._make(_map(kwds.pop, field_names, self))
    if kwds:
        raise TypeError(f'Got unexpected field names: {list(kwds)!r}')
    return result
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.options.OptDesc.__repr__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.options.OptDesc.__repr__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.options.OptDesc.__repr__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a nicely formatted representation string</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/options.py</code></summary>
          <pre class="highlight"><code class="language-python">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h3 id="beancount.parser.options.OptGroup" class="doc doc-heading">
        <code>
beancount.parser.options.OptGroup            (<span title="tuple">tuple</span>)
        </code>



<a href="#beancount.parser.options.OptGroup" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>OptGroup(description, options)</p>




  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.options.OptGroup.__getnewargs__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.options.OptGroup.__getnewargs__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.options.OptGroup.__getnewargs__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return self as a plain tuple.  Used by copy and pickle.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/options.py</code></summary>
          <pre class="highlight"><code class="language-python">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.options.OptGroup.__new__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.options.OptGroup.__new__(_cls, description, options)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
      <small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
  </span>

<a href="#beancount.parser.options.OptGroup.__new__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Create new instance of OptGroup(description, options)</p>

    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.options.OptGroup.__replace__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.options.OptGroup.__replace__(/, self, **kwds)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.options.OptGroup.__replace__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a new OptGroup object replacing specified fields with new values</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/options.py</code></summary>
          <pre class="highlight"><code class="language-python">def _replace(self, /, **kwds):
    result = self._make(_map(kwds.pop, field_names, self))
    if kwds:
        raise TypeError(f'Got unexpected field names: {list(kwds)!r}')
    return result
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.options.OptGroup.__repr__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.options.OptGroup.__repr__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.options.OptGroup.__repr__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a nicely formatted representation string</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/options.py</code></summary>
          <pre class="highlight"><code class="language-python">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>




  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.options.Opt" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.options.Opt(name, default_value, example_value=&lt;object object at 0x781d1c7909d0&gt;, converter=None, deprecated=False, alias=None)</code>


<a href="#beancount.parser.options.Opt" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Alternative constructor for OptDesc, with default values.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>name</strong> – See OptDesc.</p></li>
            <li><p><strong>default_value</strong> – See OptDesc.</p></li>
            <li><p><strong>example_value</strong> – See OptDesc.</p></li>
            <li><p><strong>converter</strong> – See OptDesc.</p></li>
            <li><p><strong>deprecated</strong> – See OptDesc.</p></li>
            <li><p><strong>alias</strong> – See OptDesc.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>An instance of OptDesc.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/options.py</code></summary>
          <pre class="highlight"><code class="language-python">def Opt(name, default_value,
        example_value=UNSET,
        converter=None,
        deprecated=False,
        alias=None):
    """Alternative constructor for OptDesc, with default values.

    Args:
      name: See OptDesc.
      default_value: See OptDesc.
      example_value: See OptDesc.
      converter: See OptDesc.
      deprecated: See OptDesc.
      alias: See OptDesc.
    Returns:
      An instance of OptDesc.
    """
    if example_value is UNSET:
        example_value = default_value
    return OptDesc(name, default_value, example_value, converter, deprecated, alias)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.options.get_account_types" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.options.get_account_types(options)</code>


<a href="#beancount.parser.options.get_account_types" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Extract the account type names from the parser's options.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>options</strong> – a dict of ledger options.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>An instance of AccountTypes, that contains all the prefixes.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/options.py</code></summary>
          <pre class="highlight"><code class="language-python">def get_account_types(options):
    """Extract the account type names from the parser's options.

    Args:
      options: a dict of ledger options.
    Returns:
      An instance of AccountTypes, that contains all the prefixes.
    """
    return account_types.AccountTypes(
        *[options[key]
          for key in ("name_assets",
                      "name_liabilities",
                      "name_equity",
                      "name_income",
                      "name_expenses")])
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.options.get_current_accounts" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.options.get_current_accounts(options)</code>


<a href="#beancount.parser.options.get_current_accounts" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Return account names for the current earnings and conversion accounts.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>options</strong> – a dict of ledger options.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A tuple of 2 account objects, one for booking current earnings, and one
for current conversions.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/options.py</code></summary>
          <pre class="highlight"><code class="language-python">def get_current_accounts(options):
    """Return account names for the current earnings and conversion accounts.

    Args:
      options: a dict of ledger options.
    Returns:
      A tuple of 2 account objects, one for booking current earnings, and one
      for current conversions.
    """
    equity = options['name_equity']
    account_current_earnings = account.join(equity,
                                            options['account_current_earnings'])
    account_current_conversions = account.join(equity,
                                               options['account_current_conversions'])
    return (account_current_earnings,
            account_current_conversions)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.options.get_previous_accounts" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.options.get_previous_accounts(options)</code>


<a href="#beancount.parser.options.get_previous_accounts" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Return account names for the previous earnings, balances and conversion accounts.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>options</strong> – a dict of ledger options.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A tuple of 3 account objects, for booking previous earnings,
previous balances, and previous conversions.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/options.py</code></summary>
          <pre class="highlight"><code class="language-python">def get_previous_accounts(options):
    """Return account names for the previous earnings, balances and conversion accounts.

    Args:
      options: a dict of ledger options.
    Returns:
      A tuple of 3 account objects, for booking previous earnings,
      previous balances, and previous conversions.
    """
    equity = options['name_equity']
    account_previous_earnings = account.join(equity,
                                             options['account_previous_earnings'])
    account_previous_balances = account.join(equity,
                                             options['account_previous_balances'])
    account_previous_conversions = account.join(equity,
                                                options['account_previous_conversions'])
    return (account_previous_earnings,
            account_previous_balances,
            account_previous_conversions)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.options.get_unrealized_account" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.options.get_unrealized_account(options)</code>


<a href="#beancount.parser.options.get_unrealized_account" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Return the full account name for the unrealized account.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>options</strong> – a dict of ledger options.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A tuple of 2 account objects, one for booking current earnings, and one
for current conversions.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/options.py</code></summary>
          <pre class="highlight"><code class="language-python">def get_unrealized_account(options):
    """Return the full account name for the unrealized account.

    Args:
      options: a dict of ledger options.
    Returns:
      A tuple of 2 account objects, one for booking current earnings, and one
      for current conversions.
    """
    income = options['name_income']
    return  account.join(income, options['account_unrealized_gains'])
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.options.list_options" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.options.list_options()</code>


<a href="#beancount.parser.options.list_options" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Produce a formatted text of the available options and their description.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A string, formatted nicely to be printed in 80 columns.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/options.py</code></summary>
          <pre class="highlight"><code class="language-python">def list_options():
    """Produce a formatted text of the available options and their description.

    Returns:
      A string, formatted nicely to be printed in 80 columns.
    """
    oss = io.StringIO()
    for group in PUBLIC_OPTION_GROUPS:
        for desc in group.options:
            oss.write('option "{}" "{}"\n'.format(desc.name, desc.example_value))
            if desc.deprecated:
                oss.write(textwrap.fill(
                    "THIS OPTION IS DEPRECATED: {}".format(desc.deprecated),
                    initial_indent="  ",
                    subsequent_indent="  "))
                oss.write('\n\n')
        description = ' '.join(line.strip()
                               for line in group.description.strip().splitlines())
        oss.write(textwrap.fill(description,
                                initial_indent='  ',
                                subsequent_indent='  '))
        oss.write('\n')

        if isinstance(desc.default_value, (list, dict, set)):
            oss.write('\n')
            oss.write('  (This option may be supplied multiple times.)\n')

        oss.write('\n\n')

    return oss.getvalue()
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.options.options_validate_booking_method" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.options.options_validate_booking_method(value)</code>


<a href="#beancount.parser.options.options_validate_booking_method" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Validate a booking method name.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>value</strong> – A string, the value provided as option.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>The new value, converted, if the conversion is successful.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Exceptions:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><code>ValueError</code> – If the value is invalid.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/options.py</code></summary>
          <pre class="highlight"><code class="language-python">def options_validate_booking_method(value):
    """Validate a booking method name.

    Args:
      value: A string, the value provided as option.
    Returns:
      The new value, converted, if the conversion is successful.
    Raises:
      ValueError: If the value is invalid.
    """
    try:
        return data.Booking[value]
    except KeyError as exc:
        raise ValueError(str(exc)) from exc
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.options.options_validate_boolean" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.options.options_validate_boolean(value)</code>


<a href="#beancount.parser.options.options_validate_boolean" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Validate a boolean option.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>value</strong> – A string, the value provided as option.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>The new value, converted, if the conversion is successful.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Exceptions:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><code>ValueError</code> – If the value is invalid.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/options.py</code></summary>
          <pre class="highlight"><code class="language-python">def options_validate_boolean(value):
    """Validate a boolean option.

    Args:
      value: A string, the value provided as option.
    Returns:
      The new value, converted, if the conversion is successful.
    Raises:
      ValueError: If the value is invalid.
    """
    return value.lower() in ('1', 'true', 'yes')
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.options.options_validate_plugin" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.options.options_validate_plugin(value)</code>


<a href="#beancount.parser.options.options_validate_plugin" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Validate the plugin option.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>value</strong> – A string, the value provided as option.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>The new value, converted, if the conversion is successful.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Exceptions:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><code>ValueError</code> – If the value is invalid.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/options.py</code></summary>
          <pre class="highlight"><code class="language-python">def options_validate_plugin(value):
    """Validate the plugin option.

    Args:
      value: A string, the value provided as option.
    Returns:
      The new value, converted, if the conversion is successful.
    Raises:
      ValueError: If the value is invalid.
    """
    # Process the 'plugin' option specially: accept an optional
    # argument from it. NOTE: We will eventually phase this out and
    # replace it by a dedicated 'plugin' directive.
    match = re.match('(.*):(.*)', value)
    if match:
        plugin_name, plugin_config = match.groups()
    else:
        plugin_name, plugin_config = value, None
    return (plugin_name, plugin_config)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.options.options_validate_processing_mode" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.options.options_validate_processing_mode(value)</code>


<a href="#beancount.parser.options.options_validate_processing_mode" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Validate the options processing mode.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>value</strong> – A string, the value provided as option.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>The new value, converted, if the conversion is successful.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Exceptions:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><code>ValueError</code> – If the value is invalid.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/options.py</code></summary>
          <pre class="highlight"><code class="language-python">def options_validate_processing_mode(value):
    """Validate the options processing mode.

    Args:
      value: A string, the value provided as option.
    Returns:
      The new value, converted, if the conversion is successful.
    Raises:
      ValueError: If the value is invalid.
    """
    if value not in ('raw', 'default'):
        raise ValueError("Invalid value '{}'".format(value))
    return value
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.options.options_validate_tolerance" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.options.options_validate_tolerance(value)</code>


<a href="#beancount.parser.options.options_validate_tolerance" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Validate the tolerance option.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>value</strong> – A string, the value provided as option.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>The new value, converted, if the conversion is successful.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Exceptions:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><code>ValueError</code> – If the value is invalid.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/options.py</code></summary>
          <pre class="highlight"><code class="language-python">def options_validate_tolerance(value):
    """Validate the tolerance option.

    Args:
      value: A string, the value provided as option.
    Returns:
      The new value, converted, if the conversion is successful.
    Raises:
      ValueError: If the value is invalid.
    """
    return D(value)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.options.options_validate_tolerance_map" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.options.options_validate_tolerance_map(value)</code>


<a href="#beancount.parser.options.options_validate_tolerance_map" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Validate an option with a map of currency/tolerance pairs in a string.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>value</strong> – A string, the value provided as option.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>The new value, converted, if the conversion is successful.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Exceptions:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><code>ValueError</code> – If the value is invalid.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/options.py</code></summary>
          <pre class="highlight"><code class="language-python">def options_validate_tolerance_map(value):
    """Validate an option with a map of currency/tolerance pairs in a string.

    Args:
      value: A string, the value provided as option.
    Returns:
      The new value, converted, if the conversion is successful.
    Raises:
      ValueError: If the value is invalid.
    """
    # Process the setting of a key-value, whereby the value is a Decimal
    # representation.
    match = re.match('(.*):(.*)', value)
    if not match:
        raise ValueError("Invalid value '{}'".format(value))
    currency, tolerance_str = match.groups()
    return (currency, D(tolerance_str))
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="beancount.parser.parser" class="doc doc-heading">
        <code>beancount.parser.parser</code>



<a href="#beancount.parser.parser" class="headerlink" title="Permanent link"></a></h2>

    <div class="doc doc-contents ">

      <p>Beancount syntax parser.</p>
<p>IMPORTANT: The parser (and its grammar builder) produces "incomplete"
Transaction objects. This means that some of the data can be found missing from
the output of the parser and some of the data types vary slightly. Missing
components are replaced not by None, but by a special constant 'NA' which helps
diagnose problems if a user inadvertently attempts to work on an incomplete
posting instead of a complete one. Those incomplete entries are then run through
the "booking" routines which do two things simultaneously:</p>
<ol>
<li>They find matching lots for reducing inventory positions, and</li>
<li>They interpolate missing numbers.</li>
</ol>
<p>In doing so they normalize the entries to "complete" entries by converting a
position/lot's "cost" attribute from a CostSpec to a Cost. A Cost is similar to
an Amount in that it shares "number" and "currency" attributes, but also has a
label and a lot date. A CostSpec is similar to a Cost, but has all optional
data; it consists in a specification for matching against a particular inventory
lot.</p>
<p>Other parts of a posting may also be missing, not just parts of the cost.
Leaving out some parts of the input is used to invoke interpolation, to tell
Beancount to automatically compute the missing numbers (if possible).</p>
<p>Missing components will be set to the special value
"beancount.core.number.MISSING" until inventory booking and number interpolation
has been completed. The "MISSING" value should never appear in completed, loaded
transaction postings.</p>
<p>For instance, all of the units may be missing:</p>
<p>INPUT: Assets:Account
  posting.units = MISSING</p>
<p>Or just the number of the units:</p>
<p>INPUT: Assets:Account                    USD
  posting.units = Amount(MISSING, "USD")</p>
<p>You must always specify the currency.</p>
<p>If a price annotation is simply absent, it appears as None:</p>
<p>INPUT: Assets:Account                 2 MXN
  posting.price = None</p>
<p>However, you may indicate that there is a price but have Beancount compute it
automatically:</p>
<p>INPUT: Assets:Account                 2 MXN @
  posting.price = Amount(MISSING, MISSING)</p>
<p>Indicating the conversion currency is also possible (and recommended):</p>
<p>INPUT: Assets:Account                 2 MXN @ USD
  posting.price = Amount(MISSING, "USD")</p>
<p>If a cost specification is provided, a "cost" attribute it set but it does not
refer to a Cost instance (as in complete entries) but rather to a CostSpec
instance. Some of the fields of a CostSpec may be MISSING if they were not
specified in the input. For example:</p>
<p>INPUT: Assets:Account  1 HOOL {100 # 5 USD}
  posting.cost = CostSpec(Decimal("100"), Decimal("5"), "USD", None, None, False))</p>
<p>Note how we never consider the label of date override to be MISSING; this is
because those inputs are optional: A missing label is simply left unset in the
computed Cost, and a missing date override uses the date of the transaction
that contains the posting.</p>
<p>You can indicate that there is a total number to be filled in like this:</p>
<p>INPUT: Assets:Account  1 HOOL {100 # USD}
  posting.cost = CostSpec(Decimal("100"), MISSING, "USD", None, None, False))</p>
<p>This is in contrast to the total value simple not being used:</p>
<p>INPUT: Assets:Account  1 HOOL {100 USD}
  posting.cost = CostSpec(Decimal("100"), None, "USD", None, None, False))</p>
<p>Both per-unit and total numbers may be omitted as well, in which case, only the
number-per-unit portion of the CostSpec will appear as MISSING:</p>
<p>INPUT: Assets:Account  1 HOOL {USD}
  posting.cost = CostSpec(MISSING, None, "USD", None, None, False))</p>
<p>And furthermore, all the cost basis may be missing:</p>
<p>INPUT: Assets:Account  1 HOOL {}
  posting.cost = CostSpec(MISSING, None, MISSING, None, None, False))</p>
<p>If you ask for the lots to be merged, you get this:</p>
<p>INPUT: Assets:Account  1 HOOL {*}
  posting.cost = CostSpec(MISSING, None, MISSING, None, None, True))</p>
<p>The numbers have to be computed by Beancount, so we output this with MISSING
values.</p>
<p>Of course, you can provide only the non-basis information, like just the date
or label:</p>
<p>INPUT: Assets:Account  1 HOOL {2015-09-21}
  posting.cost = CostSpec(MISSING, None, MISSING, date(2015, 9, 21), None, True)</p>
<p>See the test beancount.parser.grammar_test.TestIncompleteInputs for examples and
corresponding expected values.</p>



  <div class="doc doc-children">










  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.parser.is_entry_incomplete" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.parser.is_entry_incomplete(entry)</code>


<a href="#beancount.parser.parser.is_entry_incomplete" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Detect the presence of elided amounts in Transactions.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> – A directive.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A boolean, true if there are some missing portions of any postings found.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/parser.py</code></summary>
          <pre class="highlight"><code class="language-python">def is_entry_incomplete(entry):
    """Detect the presence of elided amounts in Transactions.

    Args:
      entries: A directive.
    Returns:
      A boolean, true if there are some missing portions of any postings found.
    """
    if isinstance(entry, data.Transaction):
        if any(is_posting_incomplete(posting) for posting in entry.postings):
            return True
    return False
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.parser.is_posting_incomplete" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.parser.is_posting_incomplete(posting)</code>


<a href="#beancount.parser.parser.is_posting_incomplete" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Detect the presence of any elided amounts in a Posting.</p>
<p>If any of the possible amounts are missing, this returns True.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> – A directive.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A boolean, true if there are some missing portions of any postings found.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/parser.py</code></summary>
          <pre class="highlight"><code class="language-python">def is_posting_incomplete(posting):
    """Detect the presence of any elided amounts in a Posting.

    If any of the possible amounts are missing, this returns True.

    Args:
      entries: A directive.
    Returns:
      A boolean, true if there are some missing portions of any postings found.
    """
    units = posting.units
    if (units is MISSING or
        units.number is MISSING or
        units.currency is MISSING):
        return True
    price = posting.price
    if (price is MISSING or
        price is not None and (price.number is MISSING or
                               price.currency is MISSING)):
        return True
    cost = posting.cost
    if cost is not None and (cost.number_per is MISSING or
                             cost.number_total is MISSING or
                             cost.currency is MISSING):
        return True
    return False
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.parser.parse_doc" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.parser.parse_doc(expect_errors=False, allow_incomplete=False)</code>


<a href="#beancount.parser.parser.parse_doc" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Factory of decorators that parse the function's docstring as an argument.</p>
<p>Note that the decorators thus generated only run the parser on the tests,
not the loader, so is no validation, balance checks, nor plugins applied to
the parsed text.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>expect_errors</strong> – A boolean or None, with the following semantics,
True: Expect errors and fail if there are none.
False: Expect no errors and fail if there are some.
None: Do nothing, no check.</p></li>
            <li><p><strong>allow_incomplete</strong> – A boolean, if true, allow incomplete input. Otherwise
barf if the input would require interpolation. The default value is set
not to allow it because we want to minimize the features tests depend on.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A decorator for test functions.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/parser.py</code></summary>
          <pre class="highlight"><code class="language-python">def parse_doc(expect_errors=False, allow_incomplete=False):
    """Factory of decorators that parse the function's docstring as an argument.

    Note that the decorators thus generated only run the parser on the tests,
    not the loader, so is no validation, balance checks, nor plugins applied to
    the parsed text.

    Args:
      expect_errors: A boolean or None, with the following semantics,
        True: Expect errors and fail if there are none.
        False: Expect no errors and fail if there are some.
        None: Do nothing, no check.
      allow_incomplete: A boolean, if true, allow incomplete input. Otherwise
        barf if the input would require interpolation. The default value is set
        not to allow it because we want to minimize the features tests depend on.
    Returns:
      A decorator for test functions.
    """
    def decorator(fun):
        """A decorator that parses the function's docstring as an argument.

        Args:
          fun: the function object to be decorated.
        Returns:
          A decorated test function.
        """
        filename = inspect.getfile(fun)
        lines, lineno = inspect.getsourcelines(fun)

        # Skip over decorator invocation and function definition. This
        # is imperfect as it assumes that each consumes exactly one
        # line, but this is by far the most common case, and this is
        # mainly used in test, thus it is good enough.
        lineno += 2

        @functools.wraps(fun)
        def wrapper(self):
            assert fun.__doc__ is not None, (
                "You need to insert a docstring on {}".format(fun.__name__))
            entries, errors, options_map = parse_string(fun.__doc__,
                                                        report_filename=filename,
                                                        report_firstline=lineno,
                                                        dedent=True)

            if not allow_incomplete and any(is_entry_incomplete(entry)
                                            for entry in entries):
                self.fail("parse_doc() may not use interpolation.")

            if expect_errors is not None:
                if expect_errors is False and errors:
                    oss = io.StringIO()
                    printer.print_errors(errors, file=oss)
                    self.fail("Unexpected errors found:\n{}".format(oss.getvalue()))
                elif expect_errors is True and not errors:
                    self.fail("Expected errors, none found:")

            return fun(self, entries, errors, options_map)

        return wrapper

    return decorator
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.parser.parse_file" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.parser.parse_file(file, report_filename=None, report_firstline=1, encoding=None, debug=False, **kw)</code>


<a href="#beancount.parser.parser.parse_file" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Parse a beancount input file and return Ledger with the list of
transactions and tree of accounts.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>file</strong> – file object or path to the file to be parsed.</p></li>
            <li><p><strong>kw</strong> – a dict of keywords to be applied to the C parser.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A tuple of (
  list of entries parsed in the file,
  list of errors that were encountered during parsing, and
  a dict of the option values that were parsed from the file.)</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/parser.py</code></summary>
          <pre class="highlight"><code class="language-python">def parse_file(file, report_filename=None, report_firstline=1,
               encoding=None, debug=False, **kw):
    """Parse a beancount input file and return Ledger with the list of
    transactions and tree of accounts.

    Args:
      file: file object or path to the file to be parsed.
      kw: a dict of keywords to be applied to the C parser.
    Returns:
      A tuple of (
        list of entries parsed in the file,
        list of errors that were encountered during parsing, and
        a dict of the option values that were parsed from the file.)
    """
    if encoding is not None and codecs.lookup(encoding).name != 'utf-8':
        raise ValueError('Only UTF-8 encoded files are supported.')
    with contextlib.ExitStack() as ctx:
        if file == '-':
            file = sys.stdin.buffer
        # It would be more appropriate here to check for io.RawIOBase but
        # that does not work for io.BytesIO despite it implementing the
        # readinto() method.
        elif not isinstance(file, io.IOBase):
            file = ctx.enter_context(open(file, 'rb'))
        builder = grammar.Builder()
        parser = _parser.Parser(builder, debug=debug)
        parser.parse(file, filename=report_filename, lineno=report_firstline, **kw)
    return builder.finalize()
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.parser.parse_many" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.parser.parse_many(string, level=0)</code>


<a href="#beancount.parser.parser.parse_many" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Parse a string with a snippet of Beancount input and replace vars from caller.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>string</strong> – A string with some Beancount input.</p></li>
            <li><p><strong>level</strong> – The number of extra stacks to ignore.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A list of entries.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Exceptions:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><code>AssertionError</code> – If there are any errors.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/parser.py</code></summary>
          <pre class="highlight"><code class="language-python">def parse_many(string, level=0):
    """Parse a string with a snippet of Beancount input and replace vars from caller.

    Args:
      string: A string with some Beancount input.
      level: The number of extra stacks to ignore.
    Returns:
      A list of entries.
    Raises:
      AssertionError: If there are any errors.
    """
    # Get the locals in the stack for the callers and produce the final text.
    frame = inspect.stack()[level+1]
    varkwds = frame[0].f_locals
    input_string = textwrap.dedent(string.format(**varkwds))

    # Parse entries and check there are no errors.
    entries, errors, __ = parse_string(input_string)
    assert not errors

    return entries
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.parser.parse_one" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.parser.parse_one(string)</code>


<a href="#beancount.parser.parser.parse_one" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Parse a string with single Beancount directive and replace vars from caller.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>string</strong> – A string with some Beancount input.</p></li>
            <li><p><strong>level</strong> – The number of extra stacks to ignore.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A list of entries.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Exceptions:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><code>AssertionError</code> – If there are any errors.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/parser.py</code></summary>
          <pre class="highlight"><code class="language-python">def parse_one(string):
    """Parse a string with single Beancount directive and replace vars from caller.

    Args:
      string: A string with some Beancount input.
      level: The number of extra stacks to ignore.
    Returns:
      A list of entries.
    Raises:
      AssertionError: If there are any errors.
    """
    entries = parse_many(string, level=1)
    assert len(entries) == 1
    return entries[0]
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.parser.parse_string" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.parser.parse_string(string, report_filename=None, dedent=False, **kw)</code>


<a href="#beancount.parser.parser.parse_string" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Parse a beancount input file and return Ledger with the list of
transactions and tree of accounts.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>string</strong> – A string, the contents to be parsed instead of a file's.</p></li>
            <li><p><strong>report_filename</strong> – A string, the source filename from which this string
has been extracted, if any. This is stored in the metadata of the
parsed entries.</p></li>
            <li><p><strong>dedent</strong> – Whether to run textwrap.dedent() on the string before parsing.</p></li>
            <li><p><strong>**kw</strong> – See parse.c.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>Same as the output of parse_file().</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/parser.py</code></summary>
          <pre class="highlight"><code class="language-python">def parse_string(string, report_filename=None, dedent=False, **kw):
    """Parse a beancount input file and return Ledger with the list of
    transactions and tree of accounts.

    Args:
      string: A string, the contents to be parsed instead of a file's.
      report_filename: A string, the source filename from which this string
        has been extracted, if any. This is stored in the metadata of the
        parsed entries.
      dedent: Whether to run textwrap.dedent() on the string before parsing.
      **kw: See parse.c.
    Return:
      Same as the output of parse_file().
    """
    if dedent:
        string = textwrap.dedent(string)
    if isinstance(string, str):
        string = string.encode('utf8')
    if report_filename is None:
        report_filename = '&lt;string&gt;'
    file = io.BytesIO(string)
    return parse_file(file, report_filename=report_filename, **kw)
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="beancount.parser.printer" class="doc doc-heading">
        <code>beancount.parser.printer</code>



<a href="#beancount.parser.printer" class="headerlink" title="Permanent link"></a></h2>

    <div class="doc doc-contents ">

      <p>Conversion from internal data structures to text.</p>



  <div class="doc doc-children">









  <div class="doc doc-object doc-class">



<h3 id="beancount.parser.printer.EntryPrinter" class="doc doc-heading">
        <code>
beancount.parser.printer.EntryPrinter        </code>



<a href="#beancount.parser.printer.EntryPrinter" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>A multi-method interface for printing all directive types.</p>

<p><strong>Attributes:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>dcontext</code></td>
        <td></td>
        <td><p>An instance of DisplayContext with which to render all the numbers.</p></td>
      </tr>
      <tr>
        <td><code>render_weight</code></td>
        <td></td>
        <td><p>A boolean, true if we should render the weight of the postings
as a comment, for debugging.</p></td>
      </tr>
      <tr>
        <td><code>min_width_account</code></td>
        <td></td>
        <td><p>An integer, the minimum width to leave for the account name.</p></td>
      </tr>
      <tr>
        <td><code>prefix</code></td>
        <td></td>
        <td><p>User-specific prefix for custom indentation (for Fava).</p></td>
      </tr>
      <tr>
        <td><code>stringify_invalid_types</code></td>
        <td></td>
        <td><p>If a metadata value is invalid, force a conversion to
string for printout.</p></td>
      </tr>
  </tbody>
</table>



  <div class="doc doc-children">























  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.printer.EntryPrinter.__call__" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.printer.EntryPrinter.__call__(self, obj)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.parser.printer.EntryPrinter.__call__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Render a directive.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>obj</strong> – The directive to be rendered.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A string, the rendered directive.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/printer.py</code></summary>
          <pre class="highlight"><code class="language-python">def __call__(self, obj):
    """Render a directive.

    Args:
      obj: The directive to be rendered.
    Returns:
      A string, the rendered directive.
    """
    oss = io.StringIO()

    # We write optional entry source for every entry type, hence writing it here
    self.write_entry_source(obj.meta, oss, prefix="")

    method = getattr(self, obj.__class__.__name__)
    method(obj, oss)
    return oss.getvalue()
</code></pre>
        </details>
    </div>

  </div>




  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.printer.EntryPrinter.render_posting_strings" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.printer.EntryPrinter.render_posting_strings(self, posting)</code>


<a href="#beancount.parser.printer.EntryPrinter.render_posting_strings" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>This renders the three components of a posting: the account and its optional
posting flag, the position, and finally, the weight of the position. The
purpose is to align these in the caller.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>posting</strong> – An instance of Posting, the posting to render.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p><code>A tuple of
  flag_account</code> – A string, the account name including the flag.
  position_str: A string, the rendered position string.
  weight_str: A string, the rendered weight of the posting.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/printer.py</code></summary>
          <pre class="highlight"><code class="language-python">def render_posting_strings(self, posting):
    """This renders the three components of a posting: the account and its optional
    posting flag, the position, and finally, the weight of the position. The
    purpose is to align these in the caller.

    Args:
      posting: An instance of Posting, the posting to render.
    Returns:
      A tuple of
        flag_account: A string, the account name including the flag.
        position_str: A string, the rendered position string.
        weight_str: A string, the rendered weight of the posting.
    """
    # Render a string of the flag and the account.
    flag = '{} '.format(render_flag(posting.flag)) if posting.flag else ''
    flag_account = flag + posting.account

    # Render a string with the amount and cost and optional price, if
    # present. Also render a string with the weight.
    weight_str = ''
    if isinstance(posting.units, amount.Amount):
        position_str = position.to_string(posting, self.dformat)
        # Note: we render weights at maximum precision, for debugging.
        if posting.cost is None or (isinstance(posting.cost, position.Cost) and
                                    isinstance(posting.cost.number, Decimal)):
            weight_str = str(convert.get_weight(posting))
    else:
        position_str = ''

    if posting.price is not None:
        position_str += ' @ {}'.format(posting.price.to_string(self.dformat_max))

    return flag_account, position_str, weight_str
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.printer.EntryPrinter.write_entry_source" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.printer.EntryPrinter.write_entry_source(self, meta, oss, prefix=None)</code>


<a href="#beancount.parser.printer.EntryPrinter.write_entry_source" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Write source file and line number in a format interpretable as a message
location for Emacs, VSCode or other editors. As this is for
"debugging" purposes, this information will be commented out by a
semicolon.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>meta</strong> – A dict that contains the metadata for this directive.</p></li>
            <li><p><strong>oss</strong> – A file object to write to.</p></li>
            <li><p><strong>prefix</strong> – User-specific prefix for custom indentation</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/printer.py</code></summary>
          <pre class="highlight"><code class="language-python">def write_entry_source(self, meta, oss, prefix=None):
    """Write source file and line number in a format interpretable as a message
    location for Emacs, VSCode or other editors. As this is for
    "debugging" purposes, this information will be commented out by a
    semicolon.

    Args:
      meta: A dict that contains the metadata for this directive.
      oss: A file object to write to.
      prefix: User-specific prefix for custom indentation
    """
    if not self.write_source:
        return

    if prefix is None:
        prefix = self.prefix

    oss.write('{}; source: {}\n'.format(prefix, render_source(meta)))
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.parser.printer.EntryPrinter.write_metadata" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.printer.EntryPrinter.write_metadata(self, meta, oss, prefix=None)</code>


<a href="#beancount.parser.printer.EntryPrinter.write_metadata" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Write metadata to the file object, excluding filename and line number.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>meta</strong> – A dict that contains the metadata for this directive.</p></li>
            <li><p><strong>oss</strong> – A file object to write to.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/printer.py</code></summary>
          <pre class="highlight"><code class="language-python">def write_metadata(self, meta, oss, prefix=None):
    """Write metadata to the file object, excluding filename and line number.

    Args:
      meta: A dict that contains the metadata for this directive.
      oss: A file object to write to.
    """
    if meta is None:
        return
    if prefix is None:
        prefix = self.prefix

    # Note: meta.items() is assumed stable from 3.7 onwards; we're not sorting
    # on purpose in order to keep the original insertion order in print.
    for key, value in meta.items():
        if key not in self.META_IGNORE and not key.startswith('__'):
            value_str = None
            if isinstance(value, str):
                value_str = '"{}"'.format(misc_utils.escape_string(value))
            elif isinstance(value, (Decimal, datetime.date, amount.Amount, enum.Enum)):
                value_str = str(value)
            elif isinstance(value, bool):
                value_str = 'TRUE' if value else 'FALSE'
            elif isinstance(value, (dict, inventory.Inventory)):
                pass # Ignore dicts, don't print them out.
            elif value is None:
                value_str = ''  # Render null metadata as empty, on purpose.
            else:
                if self.stringify_invalid_types:
                    # This is only intended to be used during development,
                    # when debugging for custom values of data types
                    # attached directly and not coming from the parser.
                    value_str = str(value)
                else:
                    raise ValueError("Unexpected value: '{!r}'".format(value))
            if value_str is not None:
                oss.write("{}{}: {}\n".format(prefix, key, value_str))
</code></pre>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>




  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.printer.align_position_strings" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.printer.align_position_strings(strings)</code>


<a href="#beancount.parser.printer.align_position_strings" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>A helper used to align rendered amounts positions to their first currency
character (an uppercase letter). This class accepts a list of rendered
positions and calculates the necessary width to render them stacked in a
column so that the first currency word aligns. It does not go beyond that
(further currencies, e.g. for the price or cost, are not aligned).</p>
<p>This is perhaps best explained with an example. The following positions will
be aligned around the column marked with '^':</p>
<pre><code>      45 HOOL {504.30 USD}
       4 HOOL {504.30 USD, 2014-11-11}
    9.95 USD
</code></pre>
<p>-22473.32 CAD @ 1.10 USD
             ^</p>
<p>Strings without a currency character will be rendered flush left.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>strings</strong> – A list of rendered position or amount strings.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A pair of a list of aligned strings and the width of the aligned strings.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/printer.py</code></summary>
          <pre class="highlight"><code class="language-python">def align_position_strings(strings):
    """A helper used to align rendered amounts positions to their first currency
    character (an uppercase letter). This class accepts a list of rendered
    positions and calculates the necessary width to render them stacked in a
    column so that the first currency word aligns. It does not go beyond that
    (further currencies, e.g. for the price or cost, are not aligned).

    This is perhaps best explained with an example. The following positions will
    be aligned around the column marked with '^':

              45 HOOL {504.30 USD}
               4 HOOL {504.30 USD, 2014-11-11}
            9.95 USD
       -22473.32 CAD @ 1.10 USD
                 ^

    Strings without a currency character will be rendered flush left.

    Args:
      strings: A list of rendered position or amount strings.
    Returns:
      A pair of a list of aligned strings and the width of the aligned strings.
    """
    # Maximum length before the alignment character.
    max_before = 0
    # Maximum length after the alignment character.
    max_after = 0
    # Maximum length of unknown strings.
    max_unknown = 0

    string_items = []
    search = re.compile('[A-Z]').search
    for string in strings:
        match = search(string)
        if match:
            index = match.start()
            if index != 0:
                max_before = max(index, max_before)
                max_after = max(len(string) - index, max_after)
                string_items.append((index, string))
                continue
        # else
        max_unknown = max(len(string), max_unknown)
        string_items.append((None, string))

    # Compute formatting string.
    max_total = max(max_before + max_after, max_unknown)
    max_after_prime = max_total - max_before
    fmt = "{{:&gt;{0}}}{{:{1}}}".format(max_before, max_after_prime).format
    fmt_unknown = "{{:&lt;{0}}}".format(max_total).format

    # Align the strings and return them.
    # pylint: disable=format-string-without-interpolation
    aligned_strings = []
    for index, string in string_items:
        # pylint: disable=format-string-without-interpolation
        if index is not None:
            string = fmt(string[:index], string[index:])
        else:
            string = fmt_unknown(string)
        aligned_strings.append(string)

    return aligned_strings, max_total
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.printer.format_entry" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.printer.format_entry(entry, dcontext=None, render_weights=False, prefix=None, write_source=False)</code>


<a href="#beancount.parser.printer.format_entry" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Format an entry into a string in the same input syntax the parser accepts.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entry</strong> – An entry instance.</p></li>
            <li><p><strong>dcontext</strong> – An instance of DisplayContext used to format the numbers.</p></li>
            <li><p><strong>render_weights</strong> – A boolean, true to render the weights for debugging.</p></li>
            <li><p><strong>write_source</strong> – If true a source file and line number will be written for
each entry in a format interpretable as a message location for Emacs,
VSCode or other editors. As this is for
"debugging" purposes, this information will be commented out by a
semicolon.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A string, the formatted entry.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/printer.py</code></summary>
          <pre class="highlight"><code class="language-python">def format_entry(entry, dcontext=None, render_weights=False, prefix=None,
                 write_source=False):
    """Format an entry into a string in the same input syntax the parser accepts.

    Args:
      entry: An entry instance.
      dcontext: An instance of DisplayContext used to format the numbers.
      render_weights: A boolean, true to render the weights for debugging.
      write_source: If true a source file and line number will be written for
        each entry in a format interpretable as a message location for Emacs,
        VSCode or other editors. As this is for
        "debugging" purposes, this information will be commented out by a
        semicolon.
    Returns:
      A string, the formatted entry.
    """
    return EntryPrinter(dcontext, render_weights, prefix=prefix,
                        write_source=write_source)(entry)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.printer.format_error" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.printer.format_error(error)</code>


<a href="#beancount.parser.printer.format_error" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Given an error objects, return a formatted string for it.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>error</strong> – a namedtuple objects representing an error. It has to have an
'entry' attribute that may be either a single directive object or a
list of directive objects.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A string, the errors rendered.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/printer.py</code></summary>
          <pre class="highlight"><code class="language-python">def format_error(error):
    """Given an error objects, return a formatted string for it.

    Args:
      error: a namedtuple objects representing an error. It has to have an
        'entry' attribute that may be either a single directive object or a
        list of directive objects.
    Returns:
      A string, the errors rendered.
    """
    oss = io.StringIO()
    oss.write('{} {}\n'.format(render_source(error.source), error.message))
    if error.entry is not None:
        entries = error.entry if isinstance(error.entry, list) else [error.entry]
        error_string = '\n'.join(format_entry(entry) for entry in entries)
        oss.write('\n')
        oss.write(textwrap.indent(error_string, '   '))
        oss.write('\n')
    return oss.getvalue()
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.printer.print_entries" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.printer.print_entries(entries, dcontext=None, render_weights=False, file=None, prefix=None, write_source=False)</code>


<a href="#beancount.parser.printer.print_entries" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>A convenience function that prints a list of entries to a file.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> – A list of directives.</p></li>
            <li><p><strong>dcontext</strong> – An instance of DisplayContext used to format the numbers.</p></li>
            <li><p><strong>render_weights</strong> – A boolean, true to render the weights for debugging.</p></li>
            <li><p><strong>file</strong> – An optional file object to write the entries to.</p></li>
            <li><p><strong>prefix</strong> – User-specific prefix for custom indentation (for Fava).</p></li>
            <li><p><strong>write_source</strong> – If true a source file and line number will be written for
each entry in a format interpretable as a message location for Emacs,
VSCode or other editors. This is usefull for "debugging" peurposes,
especially in a multi-file setup</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/printer.py</code></summary>
          <pre class="highlight"><code class="language-python">def print_entries(entries, dcontext=None, render_weights=False, file=None, prefix=None,
                  write_source=False):
    """A convenience function that prints a list of entries to a file.

    Args:
      entries: A list of directives.
      dcontext: An instance of DisplayContext used to format the numbers.
      render_weights: A boolean, true to render the weights for debugging.
      file: An optional file object to write the entries to.
      prefix: User-specific prefix for custom indentation (for Fava).
      write_source: If true a source file and line number will be written for
        each entry in a format interpretable as a message location for Emacs,
        VSCode or other editors. This is usefull for "debugging" peurposes,
        especially in a multi-file setup
    """
    assert isinstance(entries, list), "Entries is not a list: {}".format(entries)
    output = file or (codecs.getwriter("utf-8")(sys.stdout.buffer)
                      if hasattr(sys.stdout, 'buffer') else
                      sys.stdout)

    if prefix:
        output.write(prefix)
    previous_type = type(entries[0]) if entries else None
    eprinter = EntryPrinter(dcontext, render_weights, write_source=write_source)
    for entry in entries:
        # Insert a newline between transactions and between blocks of directives
        # of the same type.
        entry_type = type(entry)
        if (entry_type in (data.Transaction, data.Commodity) or
            entry_type is not previous_type or write_source):
            output.write('\n')
            previous_type = entry_type

        string = eprinter(entry)
        output.write(string)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.printer.print_entry" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.printer.print_entry(entry, dcontext=None, render_weights=False, file=None, write_source=False)</code>


<a href="#beancount.parser.printer.print_entry" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>A convenience function that prints a single entry to a file.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entry</strong> – A directive entry.</p></li>
            <li><p><strong>dcontext</strong> – An instance of DisplayContext used to format the numbers.</p></li>
            <li><p><strong>render_weights</strong> – A boolean, true to render the weights for debugging.</p></li>
            <li><p><strong>file</strong> – An optional file object to write the entries to.</p></li>
            <li><p><strong>write_source</strong> – If true a source file and line number will be written for
each entry in a format interpretable as a message location for Emacs,
VSCode or other editors. This is usefull for "debugging" purposes,
especially in a multi-file setup</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/printer.py</code></summary>
          <pre class="highlight"><code class="language-python">def print_entry(entry, dcontext=None, render_weights=False, file=None,
                write_source=False):
    """A convenience function that prints a single entry to a file.

    Args:
      entry: A directive entry.
      dcontext: An instance of DisplayContext used to format the numbers.
      render_weights: A boolean, true to render the weights for debugging.
      file: An optional file object to write the entries to.
      write_source: If true a source file and line number will be written for
        each entry in a format interpretable as a message location for Emacs,
        VSCode or other editors. This is usefull for "debugging" purposes,
        especially in a multi-file setup
    """
    # TODO(blais): DO remove this now, it's a huge annoyance not to be able to
    # print in-between other statements.
    output = file or (codecs.getwriter("utf-8")(sys.stdout.buffer)
                      if hasattr(sys.stdout, 'buffer') else
                      sys.stdout)
    output.write(format_entry(entry, dcontext, render_weights,
                              write_source=write_source))
    output.write('\n')
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.printer.print_error" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.printer.print_error(error, file=None)</code>


<a href="#beancount.parser.printer.print_error" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>A convenience function that prints a single error to a file.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>error</strong> – An error object.</p></li>
            <li><p><strong>file</strong> – An optional file object to write the errors to.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/printer.py</code></summary>
          <pre class="highlight"><code class="language-python">def print_error(error, file=None):
    """A convenience function that prints a single error to a file.

    Args:
      error: An error object.
      file: An optional file object to write the errors to.
    """
    output = file or sys.stdout
    output.write(format_error(error))
    output.write('\n')
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.printer.print_errors" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.printer.print_errors(errors, file=None, prefix=None)</code>


<a href="#beancount.parser.printer.print_errors" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>A convenience function that prints a list of errors to a file.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>errors</strong> – A list of errors.</p></li>
            <li><p><strong>file</strong> – An optional file object to write the errors to.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/printer.py</code></summary>
          <pre class="highlight"><code class="language-python">def print_errors(errors, file=None, prefix=None):
    """A convenience function that prints a list of errors to a file.

    Args:
      errors: A list of errors.
      file: An optional file object to write the errors to.
    """
    output = file or sys.stdout
    if prefix:
        output.write(prefix)
    for error in errors:
        output.write(format_error(error))
        output.write('\n')
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.printer.render_flag" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.printer.render_flag(inflag)</code>


<a href="#beancount.parser.printer.render_flag" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Render a flag, which can be None, a symbol of a character to a string.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/parser/printer.py</code></summary>
          <pre class="highlight"><code class="language-python">def render_flag(inflag: Optional[str]) -&gt; str:
    """Render a flag, which can be None, a symbol of a character to a string."""
    if not inflag:
        return ''
    return inflag
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.printer.render_source" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.printer.render_source(meta)</code>


<a href="#beancount.parser.printer.render_source" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Render the source for errors in a way that it will be both detected by
Emacs and align and rendered nicely.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>meta</strong> – A dict with the metadata.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A string, rendered to be interpretable as a message location for Emacs or
other editors.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/printer.py</code></summary>
          <pre class="highlight"><code class="language-python">def render_source(meta):
    """Render the source for errors in a way that it will be both detected by
    Emacs and align and rendered nicely.

    Args:
      meta: A dict with the metadata.
    Returns:
      A string, rendered to be interpretable as a message location for Emacs or
      other editors.
    """
    return '{}:{:8}'.format(meta['filename'], '{}:'.format(meta['lineno']))
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="beancount.parser.version" class="doc doc-heading">
        <code>beancount.parser.version</code>



<a href="#beancount.parser.version" class="headerlink" title="Permanent link"></a></h2>

    <div class="doc doc-contents ">

      <p>Implement common options across all programs.</p>



  <div class="doc doc-children">











  <div class="doc doc-object doc-function">



<h3 id="beancount.parser.version.compute_version_string" class="doc doc-heading">
<code class="highlight language-python">beancount.parser.version.compute_version_string(version, changeset, timestamp)</code>


<a href="#beancount.parser.version.compute_version_string" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Compute a version string from the changeset and timestamp baked in the parser.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>version</strong> – A string, the version number.</p></li>
            <li><p><strong>changeset</strong> – A string, a version control string identifying the commit of the version.</p></li>
            <li><p><strong>timestamp</strong> – An integer, the UNIX epoch timestamp of the changeset.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A human-readable string for the version.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/parser/version.py</code></summary>
          <pre class="highlight"><code class="language-python">def compute_version_string(version, changeset, timestamp):
    """Compute a version string from the changeset and timestamp baked in the parser.

    Args:
      version: A string, the version number.
      changeset: A string, a version control string identifying the commit of the version.
      timestamp: An integer, the UNIX epoch timestamp of the changeset.
    Returns:
      A human-readable string for the version.
    """
    # Shorten changeset.
    if changeset:
        if re.match('hg:', changeset):
            changeset = changeset[:15]
        elif re.match('git:', changeset):
            changeset = changeset[:12]

    # Convert timestamp to a date.
    date = None
    if timestamp &gt; 0:
        date = datetime.datetime.fromtimestamp(timestamp, datetime.UTC).date()

    version = 'Beancount {}'.format(version)
    if changeset or date:
        version = '{} ({})'.format(
            version, '; '.join(map(str, filter(None, [changeset, date]))))

    return version
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>




  </div>

    </div>

  </div>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="beancount.plugins.html" class="btn btn-neutral float-right" title="beancount.plugins">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="beancount.ops.html" class="btn btn-neutral" title="beancount.ops"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="beancount.ops.html" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="beancount.plugins.html" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
