<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="canonical" href="https://beancount.github.io/docs/api_reference/beancount.ops.html">
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>beancount.ops - Beancount Documentation</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link href="../assets/_mkdocstrings.css" rel="stylesheet" />
  <link href="../css/custom.css" rel="stylesheet" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "beancount.ops";
    var mkdocs_page_input_path = "api_reference/beancount.ops.md";
    var mkdocs_page_url = "/docs/api_reference/beancount.ops.html";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="../index.html" class="icon icon-home"> Beancount Documentation</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../index.html">Index</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Outline</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="#">Documentation for Users</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../command_line_accounting_in_context.html">Command Line Accounting in Context</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../the_double_entry_counting_method.html">The Double Entry Counting Method</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../installing_beancount.html">Installing Beancount</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../running_beancount_and_generating_reports.html">Running Beancount and Generating Reports</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../getting_started_with_beancount.html">Getting Started with Beancount</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../beancount_language_syntax.html">Beancount Language Syntax</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../beancount_options_reference.html">Beancount Options Reference</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../precision_tolerances.html">Precision Tolerances</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../beancount_query_language.html">Beancount Query Language</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../beancount_cheat_sheet.html">Beancount Cheat Sheet</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../how_inventories_work.html">How Inventories Work</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../exporting_your_portfolio.html">Exporting Your Portfolio</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../tutorial_example.html">Tutorial & Example</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../beancount_history_and_credits.html">Beancount History and Credits</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../a_comparison_of_beancount_and_ledger_hledger.html">A Comparison of Beancount and Ledger Hledger</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../fetching_prices_in_beancount.html">Fetching Prices in Beancount</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../importing_external_data.html">Importing External Data</a>
                </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="#">Cookbooks & Examples</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../command_line_accounting_cookbook.html">Command Line Accounting Cookbook</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../trading_with_beancount.html">Trading with Beancount</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../stock_vesting_in_beancount.html">Stock Vesting in Beancount</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../sharing_expenses_with_beancount.html">Sharing Expenses with Beancount</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../how_we_share_expenses.html">How We Share Expenses</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../health_care_expenses.html">Health Care Expenses</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../calculating_portolio_returns.html">Calculating Portfolio Returns</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../tracking_medical_claims.html">Tracking Out-of-Network Medical Claims in Beancount</a>
                </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="#">Documentation for Developers</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../beancount_scripting_plugins.html">Beancount Scripting Plugins</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../beancount_design_doc.html">Beancount Design Doc</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../ledgerhub_design_doc.html">Ledgerhub Design Doc</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../external_contributions.html">External Contributions</a>
                </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="#">Enhancement Proposals & Discussions</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../a_proposal_for_an_improvement_on_inventory_booking.html">A Proposal for an Improvement on Inventory Booking</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../settlement_dates_in_beancount.html">Settlement Dates in Beancount</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../balance_assertions_in_beancount.html">Balance Assertions in Beancount</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../fund_accounting_with_beancount.html">Fund Accounting with Beancount</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../rounding_precision_in_beancount.html">Rounding Precision in Beancount</a>
                </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="#">Beancount 3</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../beancount_v3.html">Goals & Design</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../installing_beancount_v3.html">Installing Beancount</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../beancount_v3_dependencies.html">Dependencies</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../beangulp.html">Beangulp</a>
                </li>
    </ul>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">API reference</span></p>
                <ul class="current">
                    <li class="toctree-l1"><a class="reference internal" href="index.html">beancount</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="beancount.core.html">beancount.core</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="beancount.loader.html">beancount.loader</a>
                    </li>
                    <li class="toctree-l1 current"><a class="reference internal current" href="beancount.ops.html">beancount.ops</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#beancount.ops">beancount.ops</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#beancount.ops.balance">balance</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.balance.check">check()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.balance.get_balance_tolerance">get_balance_tolerance()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#beancount.ops.basicops">basicops</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.basicops.filter_link">filter_link()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.basicops.filter_tag">filter_tag()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.basicops.get_common_accounts">get_common_accounts()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.basicops.group_entries_by_link">group_entries_by_link()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#beancount.ops.compress">compress</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.compress.compress">compress()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.compress.merge">merge()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#beancount.ops.documents">documents</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.documents.DocumentError">DocumentError</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.ops.documents.DocumentError.__getnewargs__">__getnewargs__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.ops.documents.DocumentError.__new__">__new__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.ops.documents.DocumentError.__repr__">__repr__()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.documents.find_documents">find_documents()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.documents.process_documents">process_documents()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.documents.verify_document_files_exist">verify_document_files_exist()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#beancount.ops.find_prices">find_prices</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.find_prices.find_balance_currencies">find_balance_currencies()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.find_prices.find_currencies_at_cost">find_currencies_at_cost()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.find_prices.find_currencies_converted">find_currencies_converted()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.find_prices.find_currencies_priced">find_currencies_priced()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#beancount.ops.lifetimes">lifetimes</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.lifetimes.compress_intervals_days">compress_intervals_days()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.lifetimes.compress_lifetimes_days">compress_lifetimes_days()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.lifetimes.get_commodity_lifetimes">get_commodity_lifetimes()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.lifetimes.required_daily_prices">required_daily_prices()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.lifetimes.required_weekly_prices">required_weekly_prices()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.lifetimes.trim_intervals">trim_intervals()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#beancount.ops.pad">pad</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.pad.PadError">PadError</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.ops.pad.PadError.__getnewargs__">__getnewargs__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.ops.pad.PadError.__new__">__new__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.ops.pad.PadError.__repr__">__repr__()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.pad.pad">pad()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#beancount.ops.summarize">summarize</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.summarize.balance_by_account">balance_by_account()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.summarize.cap">cap()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.summarize.cap_opt">cap_opt()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.summarize.clamp">clamp()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.summarize.clamp_opt">clamp_opt()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.summarize.clear">clear()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.summarize.clear_opt">clear_opt()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.summarize.close">close()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.summarize.close_opt">close_opt()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.summarize.conversions">conversions()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.summarize.create_entries_from_balances">create_entries_from_balances()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.summarize.get_open_entries">get_open_entries()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.summarize.open">open()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.summarize.open_opt">open_opt()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.summarize.summarize">summarize()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.summarize.transfer_balances">transfer_balances()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.summarize.truncate">truncate()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#beancount.ops.validation">validation</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.validation.ValidationError">ValidationError</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.ops.validation.ValidationError.__getnewargs__">__getnewargs__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.ops.validation.ValidationError.__new__">__new__()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#beancount.ops.validation.ValidationError.__repr__">__repr__()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.validation.validate">validate()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.validation.validate_active_accounts">validate_active_accounts()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.validation.validate_check_transaction_balances">validate_check_transaction_balances()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.validation.validate_currency_constraints">validate_currency_constraints()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.validation.validate_data_types">validate_data_types()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.validation.validate_documents_paths">validate_documents_paths()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.validation.validate_duplicate_balances">validate_duplicate_balances()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.validation.validate_duplicate_commodities">validate_duplicate_commodities()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#beancount.ops.validation.validate_open_close">validate_open_close()</a>
    </li>
        </ul>
    </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="beancount.parser.html">beancount.parser</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="beancount.plugins.html">beancount.plugins</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="beancount.scripts.html">beancount.scripts</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="beancount.tools.html">beancount.tools</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="beancount.utils.html">beancount.utils</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">Beancount Documentation</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
    
      
        
          <li>API reference &raquo;</li>
        
      
    
    <li>beancount.ops</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>

          <div role="main">
            <div class="section">
              
                <h1 id="beancountops">beancount.ops<a class="headerlink" href="#beancountops" title="Permanent link"></a></h1>


  <div class="doc doc-object doc-module">

<a id="beancount.ops"></a>
    <div class="doc doc-contents first">

      <p>Operations on the entries defined in the core modules.</p>
<p>This package contains various functions which operate on lists of entries.</p>



  <div class="doc doc-children">












  <div class="doc doc-object doc-module">



<h2 id="beancount.ops.balance" class="doc doc-heading">
        <code>beancount.ops.balance</code>



<a href="#beancount.ops.balance" class="headerlink" title="Permanent link"></a></h2>

    <div class="doc doc-contents ">

      <p>Automatic padding of gaps between entries.</p>



  <div class="doc doc-children">











  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.balance.check" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.balance.check(entries, options_map)</code>


<a href="#beancount.ops.balance.check" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Process the balance assertion directives.</p>
<p>For each Balance directive, check that their expected balance corresponds to
the actual balance computed at that time and replace failing ones by new
ones with a flag that indicates failure.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> – A list of directives.</p></li>
            <li><p><strong>options_map</strong> – A dict of options, parsed from the input file.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A pair of a list of directives and a list of balance check errors.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/balance.py</code></summary>
          <pre class="highlight"><code class="language-python">def check(entries, options_map):
    """Process the balance assertion directives.

    For each Balance directive, check that their expected balance corresponds to
    the actual balance computed at that time and replace failing ones by new
    ones with a flag that indicates failure.

    Args:
      entries: A list of directives.
      options_map: A dict of options, parsed from the input file.
    Returns:
      A pair of a list of directives and a list of balance check errors.
    """
    new_entries = []
    check_errors = []

    # This is similar to realization, but performed in a different order, and
    # where we only accumulate inventories for accounts that have balance
    # assertions in them (this saves on time). Here we process the entries one
    # by one along with the balance checks. We use a temporary realization in
    # order to hold the incremental tree of balances, so that we can easily get
    # the amounts of an account's subaccounts for making checks on parent
    # accounts.
    real_root = realization.RealAccount("")

    # Figure out the set of accounts for which we need to compute a running
    # inventory balance.
    asserted_accounts = {entry.account for entry in entries if isinstance(entry, Balance)}

    # Add all children accounts of an asserted account to be calculated as well,
    # and pre-create these accounts, and only those (we're just being tight to
    # make sure).
    asserted_match_list = [
        account.parent_matcher(account_) for account_ in asserted_accounts
    ]
    for account_ in getters.get_accounts(entries):
        if account_ in asserted_accounts or any(
            match(account_) for match in asserted_match_list
        ):
            realization.get_or_create(real_root, account_)

    # Get the Open directives for each account.
    open_close_map = getters.get_account_open_close(entries)

    for entry in entries:
        if isinstance(entry, Transaction):
            # For each of the postings' accounts, update the balance inventory.
            for posting in entry.postings:
                real_account = realization.get(real_root, posting.account)

                # The account will have been created only if we're meant to track it.
                if real_account is not None:
                    # Note: Always allow negative lots for the purpose of balancing.
                    # This error should show up somewhere else than here.
                    real_account.balance.add_position(posting)

        elif isinstance(entry, Balance):
            # Check that the currency of the balance check is one of the allowed
            # currencies for that account.
            expected_amount = entry.amount
            open = None
            try:
                open, _ = open_close_map[entry.account]
            except KeyError:
                check_errors.append(
                    BalanceError(
                        entry.meta,
                        "Invalid reference to unknown account '{}'".format(entry.account),
                        entry,
                    )
                )

            if (
                expected_amount is not None
                and open
                and open.currencies
                and expected_amount.currency not in open.currencies
            ):
                check_errors.append(
                    BalanceError(
                        entry.meta,
                        "Invalid currency '{}' for Balance directive: ".format(
                            expected_amount.currency
                        ),
                        entry,
                    )
                )

            # Sum up the current balances for this account and its
            # sub-accounts. We want to support checks for parent accounts
            # for the total sum of their subaccounts.
            #
            # FIXME: Improve the performance further by computing the balance
            # for the desired currency only. This won't allow us to cache in
            # this way but may be faster, if we're not asserting all the
            # currencies. Furthermore, we could probably avoid recomputing the
            # balance if a subtree of positions hasn't been invalidated by a new
            # position added to the realization. Do this.
            real_account = realization.get(real_root, entry.account)
            assert real_account is not None, "Missing {}".format(entry.account)
            subtree_balance = realization.compute_balance(real_account, leaf_only=False)

            # Get only the amount in the desired currency.
            balance_amount = subtree_balance.get_currency_units(expected_amount.currency)

            # Check if the amount is within bounds of the expected amount.
            diff_amount = amount.sub(balance_amount, expected_amount)

            # Use the specified tolerance or automatically infer it.
            tolerance = get_balance_tolerance(entry, options_map)

            if abs(diff_amount.number) &gt; tolerance:
                check_errors.append(
                    BalanceError(
                        entry.meta,
                        (
                            "Balance failed for '{}': expected {} != accumulated {} ({} {})"
                        ).format(
                            entry.account,
                            expected_amount,
                            balance_amount,
                            abs(diff_amount.number),
                            ("too much" if diff_amount.number &gt; 0 else "too little"),
                        ),
                        entry,
                    )
                )

                # Substitute the entry by a failing entry, with the diff_amount
                # field set on it. I'm not entirely sure that this is the best
                # of ideas, maybe leaving the original check intact and insert a
                # new error entry might be more functional or easier to
                # understand.
                entry = entry._replace(meta=entry.meta.copy(), diff_amount=diff_amount)

        new_entries.append(entry)

    return new_entries, check_errors
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.balance.get_balance_tolerance" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.balance.get_balance_tolerance(balance_entry, options_map)</code>


<a href="#beancount.ops.balance.get_balance_tolerance" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Get the tolerance amount for a single entry.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>balance_entry</strong> – An instance of data.Balance</p></li>
            <li><p><strong>options_map</strong> – An options dict, as per the parser.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A Decimal, the amount of tolerance implied by the directive.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/balance.py</code></summary>
          <pre class="highlight"><code class="language-python">def get_balance_tolerance(balance_entry, options_map):
    """Get the tolerance amount for a single entry.

    Args:
      balance_entry: An instance of data.Balance
      options_map: An options dict, as per the parser.
    Returns:
      A Decimal, the amount of tolerance implied by the directive.
    """
    if balance_entry.tolerance is not None:
        # Use the balance-specific tolerance override if it is provided.
        tolerance = balance_entry.tolerance

    else:
        expo = balance_entry.amount.number.as_tuple().exponent
        if expo &lt; 0:
            # Be generous and always allow twice the multiplier on Balance and
            # Pad because the user creates these and the rounding of those
            # balances may often be further off than those used within a single
            # transaction.
            tolerance = options_map["tolerance_multiplier"] * 2
            tolerance = ONE.scaleb(expo) * tolerance
        else:
            tolerance = ZERO

    return tolerance
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="beancount.ops.basicops" class="doc doc-heading">
        <code>beancount.ops.basicops</code>



<a href="#beancount.ops.basicops" class="headerlink" title="Permanent link"></a></h2>

    <div class="doc doc-contents ">

      <p>Basic filtering and aggregation operations on lists of entries.</p>
<p>This module contains some common basic operations on entries that are complex
enough not to belong in core/data.py.</p>



  <div class="doc doc-children">










  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.basicops.filter_link" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.basicops.filter_link(link, entries)</code>


<a href="#beancount.ops.basicops.filter_link" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Yield all the entries which have the given link.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>link</strong> – A string, the link we are interested in.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>      <p>Yields:
  Every entry in 'entries' that links to 'link.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/ops/basicops.py</code></summary>
          <pre class="highlight"><code class="language-python">def filter_link(link, entries):
    """Yield all the entries which have the given link.

    Args:
      link: A string, the link we are interested in.
    Yields:
      Every entry in 'entries' that links to 'link.
    """
    for entry in entries:
        if isinstance(entry, data.Transaction) and entry.links and link in entry.links:
            yield entry
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.basicops.filter_tag" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.basicops.filter_tag(tag, entries)</code>


<a href="#beancount.ops.basicops.filter_tag" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Yield all the entries which have the given tag.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>tag</strong> – A string, the tag we are interested in.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>      <p>Yields:
  Every entry in 'entries' that tags to 'tag.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/ops/basicops.py</code></summary>
          <pre class="highlight"><code class="language-python">def filter_tag(tag, entries):
    """Yield all the entries which have the given tag.

    Args:
      tag: A string, the tag we are interested in.
    Yields:
      Every entry in 'entries' that tags to 'tag.
    """
    for entry in entries:
        if isinstance(entry, data.Transaction) and entry.tags and tag in entry.tags:
            yield entry
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.basicops.get_common_accounts" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.basicops.get_common_accounts(entries)</code>


<a href="#beancount.ops.basicops.get_common_accounts" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Compute the intersection of the accounts on the given entries.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> – A list of Transaction entries to process.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A set of strings, the names of the common accounts from these
entries.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/basicops.py</code></summary>
          <pre class="highlight"><code class="language-python">def get_common_accounts(entries):
    """Compute the intersection of the accounts on the given entries.

    Args:
      entries: A list of Transaction entries to process.
    Returns:
      A set of strings, the names of the common accounts from these
      entries.
    """
    assert all(isinstance(entry, data.Transaction) for entry in entries)

    # If there is a single entry, the common accounts to it is all its accounts.
    # Note that this also works with no entries (yields an empty set).
    if len(entries) &lt; 2:
        if entries:
            intersection = {posting.account for posting in entries[0].postings}
        else:
            intersection = set()
    else:
        entries_iter = iter(entries)
        intersection = set(posting.account for posting in next(entries_iter).postings)
        for entry in entries_iter:
            accounts = set(posting.account for posting in entry.postings)
            intersection &amp;= accounts
            if not intersection:
                break
    return intersection
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.basicops.group_entries_by_link" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.basicops.group_entries_by_link(entries)</code>


<a href="#beancount.ops.basicops.group_entries_by_link" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Group the list of entries by link.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> – A list of directives/transactions to process.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A dict of link-name to list of entries.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/basicops.py</code></summary>
          <pre class="highlight"><code class="language-python">def group_entries_by_link(entries):
    """Group the list of entries by link.

    Args:
      entries: A list of directives/transactions to process.
    Returns:
      A dict of link-name to list of entries.
    """
    link_groups = defaultdict(list)
    for entry in entries:
        if not (isinstance(entry, data.Transaction) and entry.links):
            continue
        for link in entry.links:
            link_groups[link].append(entry)
    return link_groups
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="beancount.ops.compress" class="doc doc-heading">
        <code>beancount.ops.compress</code>



<a href="#beancount.ops.compress" class="headerlink" title="Permanent link"></a></h2>

    <div class="doc doc-contents ">

      <p>Compress multiple entries into a single one.</p>
<p>This can be used during import to compress the effective output, for accounts
with a large number of similar entries. For example, I had a trading account
which would pay out interest every single day. I have no desire to import the
full detail of these daily interests, and compressing these interest-only
entries to monthly ones made sense. This is the code that was used to carry this
out.</p>



  <div class="doc doc-children">










  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.compress.compress" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.compress.compress(entries, predicate)</code>


<a href="#beancount.ops.compress.compress" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Compress multiple transactions into single transactions.</p>
<p>Replace consecutive sequences of Transaction entries that fulfill the given
predicate by a single entry at the date of the last matching entry.
'predicate' is the function that determines if an entry should be
compressed.</p>
<p>This can be used to simply a list of transactions that are similar and occur
frequently. As an example, in a retail FOREX trading account, differential
interest of very small amounts is paid every day; it is not relevant to look
at the full detail of this interest unless there are other transactions. You
can use this to compress it into single entries between other types of
transactions.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> – A list of directives.</p></li>
            <li><p><strong>predicate</strong> – A callable which accepts an entry and return true if the entry
  is intended to be compressed.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A list of directives, with compressible transactions replaced by a summary
equivalent.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/compress.py</code></summary>
          <pre class="highlight"><code class="language-python">def compress(entries, predicate):
    """Compress multiple transactions into single transactions.

    Replace consecutive sequences of Transaction entries that fulfill the given
    predicate by a single entry at the date of the last matching entry.
    'predicate' is the function that determines if an entry should be
    compressed.

    This can be used to simply a list of transactions that are similar and occur
    frequently. As an example, in a retail FOREX trading account, differential
    interest of very small amounts is paid every day; it is not relevant to look
    at the full detail of this interest unless there are other transactions. You
    can use this to compress it into single entries between other types of
    transactions.

    Args:
      entries: A list of directives.
      predicate: A callable which accepts an entry and return true if the entry
          is intended to be compressed.
    Returns:
      A list of directives, with compressible transactions replaced by a summary
      equivalent.
    """
    new_entries = []
    pending = []
    for entry in entries:
        if isinstance(entry, data.Transaction) and predicate(entry):
            # Save for compressing later.
            pending.append(entry)
        else:
            # Compress and output all the pending entries.
            if pending:
                new_entries.append(merge(pending, pending[-1]))
                pending.clear()

            # Output the differing entry.
            new_entries.append(entry)

    if pending:
        new_entries.append(merge(pending, pending[-1]))

    return new_entries
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.compress.merge" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.compress.merge(entries, prototype_txn)</code>


<a href="#beancount.ops.compress.merge" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Merge the postings of a list of Transactions into a single one.</p>
<p>Merge postings the given entries into a single entry with the Transaction
attributes of the prototype. Return the new entry. The combined list of
postings are merged if everything about the postings is the same except the
number.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> – A list of directives.</p></li>
            <li><p><strong>prototype_txn</strong> – A Transaction which is used to create the compressed
  Transaction instance. Its list of postings is ignored.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A new Transaction instance which contains all the postings from the input
entries merged together.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/compress.py</code></summary>
          <pre class="highlight"><code class="language-python">def merge(entries, prototype_txn):
    """Merge the postings of a list of Transactions into a single one.

    Merge postings the given entries into a single entry with the Transaction
    attributes of the prototype. Return the new entry. The combined list of
    postings are merged if everything about the postings is the same except the
    number.

    Args:
      entries: A list of directives.
      prototype_txn: A Transaction which is used to create the compressed
          Transaction instance. Its list of postings is ignored.
    Returns:
      A new Transaction instance which contains all the postings from the input
      entries merged together.

    """
    # Aggregate the postings together. This is a mapping of numberless postings
    # to their number of units.
    postings_map = collections.defaultdict(Decimal)
    for entry in data.filter_txns(entries):
        for posting in entry.postings:
            # We strip the number off the posting to act as an aggregation key.
            key = data.Posting(
                posting.account,
                Amount(None, posting.units.currency),
                posting.cost,
                posting.price,
                posting.flag,
                None,
            )
            postings_map[key] += posting.units.number

    # Create a new transaction with the aggregated postings.
    new_entry = data.Transaction(
        prototype_txn.meta,
        prototype_txn.date,
        prototype_txn.flag,
        prototype_txn.payee,
        prototype_txn.narration,
        data.EMPTY_SET,
        data.EMPTY_SET,
        [],
    )

    # Sort for at least some stability of output.
    sorted_items = sorted(
        postings_map.items(),
        key=lambda item: (item[0].account, item[0].units.currency, item[1]),
    )

    # Issue the merged postings.
    for posting, number in sorted_items:
        units = Amount(number, posting.units.currency)
        new_entry.postings.append(
            data.Posting(
                posting.account,
                units,
                posting.cost,
                posting.price,
                posting.flag,
                posting.meta,
            )
        )

    return new_entry
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="beancount.ops.documents" class="doc doc-heading">
        <code>beancount.ops.documents</code>



<a href="#beancount.ops.documents" class="headerlink" title="Permanent link"></a></h2>

    <div class="doc doc-contents ">

      <p>Everything that relates to creating the Document directives.</p>



  <div class="doc doc-children">










  <div class="doc doc-object doc-class">



<h3 id="beancount.ops.documents.DocumentError" class="doc doc-heading">
        <code>
beancount.ops.documents.DocumentError            (<span title="tuple">tuple</span>)
        </code>



<a href="#beancount.ops.documents.DocumentError" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Error encountered during document processing.</p>

<p><strong>Attributes:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>source</code></td>
        <td><code>dict[str, Any]</code></td>
        <td><p>Source metadata for the error</p></td>
      </tr>
      <tr>
        <td><code>message</code></td>
        <td><code>str</code></td>
        <td><p>Error message string</p></td>
      </tr>
      <tr>
        <td><code>entry</code></td>
        <td><code>beancount.core.data.Document | None</code></td>
        <td><p>The related entry that caused the error</p></td>
      </tr>
  </tbody>
</table>



  <div class="doc doc-children">












  <div class="doc doc-object doc-method">



<h4 id="beancount.ops.documents.DocumentError.__getnewargs__" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.documents.DocumentError.__getnewargs__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.ops.documents.DocumentError.__getnewargs__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return self as a plain tuple.  Used by copy and pickle.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/ops/documents.py</code></summary>
          <pre class="highlight"><code class="language-python">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.ops.documents.DocumentError.__new__" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.documents.DocumentError.__new__(_cls, source, message, entry)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
      <small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
  </span>

<a href="#beancount.ops.documents.DocumentError.__new__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Create new instance of DocumentError(source, message, entry)</p>

    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.ops.documents.DocumentError.__repr__" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.documents.DocumentError.__repr__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.ops.documents.DocumentError.__repr__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a nicely formatted representation string</p>

        <details class="quote">
          <summary>Source code in <code>beancount/ops/documents.py</code></summary>
          <pre class="highlight"><code class="language-python">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>




  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.documents.find_documents" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.documents.find_documents(directory, input_filename, accounts_only=None, strict=False)</code>


<a href="#beancount.ops.documents.find_documents" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Find dated document files under the given directory.</p>
<p>If a restricting set of accounts is provided in 'accounts_only', only return
entries that correspond to one of the given accounts.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>directory</strong> – A string, the name of the root of the directory hierarchy to be searched.</p></li>
            <li><p><strong>input_filename</strong> – The name of the file to be used for the Document directives. This is
also used to resolve relative directory names.</p></li>
            <li><p><strong>accounts_only</strong> – A set of valid accounts strings to search for.</p></li>
            <li><p><strong>strict</strong> – A boolean, set to true if you want to generate errors on documents
found in accounts not provided in accounts_only. This is only meaningful
if accounts_only is specified.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A list of new Document objects that were created from the files found, and a list
of new errors generated.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/documents.py</code></summary>
          <pre class="highlight"><code class="language-python">def find_documents(directory, input_filename, accounts_only=None, strict=False):
    """Find dated document files under the given directory.

    If a restricting set of accounts is provided in 'accounts_only', only return
    entries that correspond to one of the given accounts.

    Args:
      directory: A string, the name of the root of the directory hierarchy to be searched.
      input_filename: The name of the file to be used for the Document directives. This is
        also used to resolve relative directory names.
      accounts_only: A set of valid accounts strings to search for.
      strict: A boolean, set to true if you want to generate errors on documents
        found in accounts not provided in accounts_only. This is only meaningful
        if accounts_only is specified.
    Returns:
      A list of new Document objects that were created from the files found, and a list
      of new errors generated.

    """
    errors = []

    # Compute the documents directory name relative to the beancount input
    # file itself.
    if not path.isabs(directory):
        input_directory = path.dirname(input_filename)
        directory = path.abspath(path.normpath(path.join(input_directory, directory)))

    # If the directory does not exist, just generate an error and return.
    if not path.exists(directory):
        meta = data.new_metadata(input_filename, 0)
        error = DocumentError(
            meta, "Document root '{}' does not exist".format(directory), None
        )
        return ([], [error])

    # Walk the hierarchy of files.
    entries = []
    for root, account_name, dirs, files in account.walk(directory):
        # Look for files that have a dated filename.
        for filename in files:
            match = re.match(r"(\d\d\d\d)-(\d\d)-(\d\d).(.*)", filename)
            if not match:
                continue

            # If a restricting set of accounts was specified, skip document
            # directives found in accounts with no corresponding account name.
            if accounts_only is not None and account_name not in accounts_only:
                if strict:
                    if any(account_name.startswith(account) for account in accounts_only):
                        errors.append(
                            DocumentError(
                                data.new_metadata(input_filename, 0),
                                "Document '{}' found in child account {}".format(
                                    filename, account_name
                                ),
                                None,
                            )
                        )
                    elif any(account.startswith(account_name) for account in accounts_only):
                        errors.append(
                            DocumentError(
                                data.new_metadata(input_filename, 0),
                                "Document '{}' found in parent account {}".format(
                                    filename, account_name
                                ),
                                None,
                            )
                        )
                continue

            # Create a new directive.
            meta = data.new_metadata(input_filename, 0)
            try:
                date = datetime.date(*map(int, match.group(1, 2, 3)))
            except ValueError as exc:
                errors.append(
                    DocumentError(
                        data.new_metadata(input_filename, 0),
                        "Invalid date on document file '{}': {}".format(filename, exc),
                        None,
                    )
                )
            else:
                entry = data.Document(
                    meta,
                    date,
                    account_name,
                    path.join(root, filename),
                    data.EMPTY_SET,
                    data.EMPTY_SET,
                )
                entries.append(entry)

    return (entries, errors)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.documents.process_documents" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.documents.process_documents(entries, options_map)</code>


<a href="#beancount.ops.documents.process_documents" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Check files for document directives and create documents directives automatically.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> – A list of all directives parsed from the file.</p></li>
            <li><p><strong>options_map</strong> – An options dict, as is output by the parser.
We're using its 'filename' option to figure out relative path to
search for documents.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A pair of list of all entries (including new ones), and errors
generated during the process of creating document directives.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/documents.py</code></summary>
          <pre class="highlight"><code class="language-python">def process_documents(entries, options_map):
    """Check files for document directives and create documents directives automatically.

    Args:
      entries: A list of all directives parsed from the file.
      options_map: An options dict, as is output by the parser.
        We're using its 'filename' option to figure out relative path to
        search for documents.
    Returns:
      A pair of list of all entries (including new ones), and errors
      generated during the process of creating document directives.
    """
    filename = options_map["filename"]

    # Detect filenames that should convert into entries.
    autodoc_entries = []
    autodoc_errors = []
    document_dirs = options_map["documents"]
    if document_dirs:
        # Restrict to the list of valid accounts only.
        accounts = getters.get_accounts(entries)

        # Accumulate all the entries.
        for directory in map(path.normpath, document_dirs):
            new_entries, new_errors = find_documents(directory, filename, accounts)
            autodoc_entries.extend(new_entries)
            autodoc_errors.extend(new_errors)

    # Merge the two lists of entries and errors. Keep the entries sorted.
    entries.extend(autodoc_entries)
    entries.sort(key=data.entry_sortkey)

    return (entries, autodoc_errors)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.documents.verify_document_files_exist" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.documents.verify_document_files_exist(entries, unused_options_map)</code>


<a href="#beancount.ops.documents.verify_document_files_exist" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Verify that the document entries point to existing files.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> – a list of directives whose documents need to be validated.</p></li>
            <li><p><strong>unused_options_map</strong> – A parser options dict. We're not using it.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>The same list of entries, and a list of new errors, if any were encountered.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/documents.py</code></summary>
          <pre class="highlight"><code class="language-python">def verify_document_files_exist(entries, unused_options_map):
    """Verify that the document entries point to existing files.

    Args:
      entries: a list of directives whose documents need to be validated.
      unused_options_map: A parser options dict. We're not using it.
    Returns:
      The same list of entries, and a list of new errors, if any were encountered.
    """
    errors = []
    for entry in entries:
        if not isinstance(entry, data.Document):
            continue
        if not path.exists(entry.filename):
            errors.append(
                DocumentError(
                    entry.meta, 'File does not exist: "{}"'.format(entry.filename), entry
                )
            )
    return entries, errors
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="beancount.ops.find_prices" class="doc doc-heading">
        <code>beancount.ops.find_prices</code>



<a href="#beancount.ops.find_prices" class="headerlink" title="Permanent link"></a></h2>

    <div class="doc doc-contents ">

      <p>A library of codes create price fetching jobs from strings and files.</p>



  <div class="doc doc-children">










  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.find_prices.find_balance_currencies" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.find_prices.find_balance_currencies(entries, date=None)</code>


<a href="#beancount.ops.find_prices.find_balance_currencies" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Return currencies relevant for the given date.</p>
<p>This computes the account balances as of the date, and returns the union of:
a) The currencies held at cost, and
b) Currency pairs from previous conversions, but only for currencies with
   non-zero balances.</p>
<p>This is intended to produce the list of currencies whose prices are relevant
at a particular date, based on previous history.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> – A list of directives.</p></li>
            <li><p><strong>date</strong> – A datetime.date instance.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A set of (base, quote) currencies.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/find_prices.py</code></summary>
          <pre class="highlight"><code class="language-python">def find_balance_currencies(entries, date=None):
    """Return currencies relevant for the given date.

    This computes the account balances as of the date, and returns the union of:
    a) The currencies held at cost, and
    b) Currency pairs from previous conversions, but only for currencies with
       non-zero balances.

    This is intended to produce the list of currencies whose prices are relevant
    at a particular date, based on previous history.

    Args:
      entries: A list of directives.
      date: A datetime.date instance.
    Returns:
      A set of (base, quote) currencies.
    """
    # Compute the balances.
    currencies = set()
    currencies_on_books = set()
    balances, _ = summarize.balance_by_account(entries, date)
    for _, balance in balances.items():
        for pos in balance:
            if pos.cost is not None:
                # Add currencies held at cost.
                currencies.add((pos.units.currency, pos.cost.currency))
            else:
                # Add regular currencies.
                currencies_on_books.add(pos.units.currency)

    # Create currency pairs from the currencies which are on account balances.
    # In order to figure out the quote currencies, we use the list of price
    # conversions until this date.
    converted = find_currencies_converted(entries, date) | find_currencies_priced(
        entries, date
    )
    for cbase in currencies_on_books:
        for base_quote in converted:
            base, quote = base_quote
            if base == cbase:
                currencies.add(base_quote)

    return currencies
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.find_prices.find_currencies_at_cost" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.find_prices.find_currencies_at_cost(entries, date=None)</code>


<a href="#beancount.ops.find_prices.find_currencies_at_cost" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Return all currencies that were held at cost at some point.</p>
<p>This returns all of them, even if not on the books at a particular point in
time. This code does not look at account balances.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> – A list of directives.</p></li>
            <li><p><strong>date</strong> – A datetime.date instance.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A list of (base, quote) currencies.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/find_prices.py</code></summary>
          <pre class="highlight"><code class="language-python">def find_currencies_at_cost(entries, date=None):
    """Return all currencies that were held at cost at some point.

    This returns all of them, even if not on the books at a particular point in
    time. This code does not look at account balances.

    Args:
      entries: A list of directives.
      date: A datetime.date instance.
    Returns:
      A list of (base, quote) currencies.
    """
    currencies = set()
    for entry in entries:
        if not isinstance(entry, data.Transaction):
            continue
        if date and entry.date &gt;= date:
            break
        for posting in entry.postings:
            if posting.cost is not None and posting.cost.number is not None:
                currencies.add((posting.units.currency, posting.cost.currency))
    return currencies
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.find_prices.find_currencies_converted" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.find_prices.find_currencies_converted(entries, date=None)</code>


<a href="#beancount.ops.find_prices.find_currencies_converted" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Return currencies from price conversions.</p>
<p>This function looks at all price conversions that occurred until some date
and produces a list of them. Note: This does not include Price directives,
only postings with price conversions.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> – A list of directives.</p></li>
            <li><p><strong>date</strong> – A datetime.date instance.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A list of (base, quote) currencies.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/find_prices.py</code></summary>
          <pre class="highlight"><code class="language-python">def find_currencies_converted(entries, date=None):
    """Return currencies from price conversions.

    This function looks at all price conversions that occurred until some date
    and produces a list of them. Note: This does not include Price directives,
    only postings with price conversions.

    Args:
      entries: A list of directives.
      date: A datetime.date instance.
    Returns:
      A list of (base, quote) currencies.
    """
    currencies = set()
    for entry in entries:
        if not isinstance(entry, data.Transaction):
            continue
        if date and entry.date &gt;= date:
            break
        for posting in entry.postings:
            price = posting.price
            if posting.cost is not None or price is None:
                continue
            currencies.add((posting.units.currency, price.currency))
    return currencies
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.find_prices.find_currencies_priced" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.find_prices.find_currencies_priced(entries, date=None)</code>


<a href="#beancount.ops.find_prices.find_currencies_priced" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Return currencies seen in Price directives.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> – A list of directives.</p></li>
            <li><p><strong>date</strong> – A datetime.date instance.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A list of (base, quote) currencies.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/find_prices.py</code></summary>
          <pre class="highlight"><code class="language-python">def find_currencies_priced(entries, date=None):
    """Return currencies seen in Price directives.

    Args:
      entries: A list of directives.
      date: A datetime.date instance.
    Returns:
      A list of (base, quote) currencies.
    """
    currencies = set()
    for entry in entries:
        if not isinstance(entry, data.Price):
            continue
        if date and entry.date &gt;= date:
            break
        currencies.add((entry.currency, entry.amount.currency))
    return currencies
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="beancount.ops.lifetimes" class="doc doc-heading">
        <code>beancount.ops.lifetimes</code>



<a href="#beancount.ops.lifetimes" class="headerlink" title="Permanent link"></a></h2>

    <div class="doc doc-contents ">

      <p>Given a Beancount ledger, compute time intervals where we hold each commodity.</p>
<p>This script computes, for each commodity, which time intervals it is required at.
This can then be used to identify a list of dates at which we need to fetch prices
in order to properly fill the price database.</p>



  <div class="doc doc-children">












  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.lifetimes.compress_intervals_days" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.lifetimes.compress_intervals_days(intervals, num_days)</code>


<a href="#beancount.ops.lifetimes.compress_intervals_days" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Compress a list of date pairs to ignore short stretches of unused days.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>intervals</strong> – A list of pairs of datetime.date instances.</p></li>
            <li><p><strong>num_days</strong> – An integer, the number of unused days to require for intervals
to be distinct, to allow a gap.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A new dict of lifetimes map where some intervals may have been joined.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/lifetimes.py</code></summary>
          <pre class="highlight"><code class="language-python">def compress_intervals_days(intervals, num_days):
    """Compress a list of date pairs to ignore short stretches of unused days.

    Args:
      intervals: A list of pairs of datetime.date instances.
      num_days: An integer, the number of unused days to require for intervals
        to be distinct, to allow a gap.
    Returns:
      A new dict of lifetimes map where some intervals may have been joined.
    """
    ignore_interval = datetime.timedelta(days=num_days)
    new_intervals = []
    iter_intervals = iter(intervals)
    last_begin, last_end = next(iter_intervals)
    for date_begin, date_end in iter_intervals:
        if date_begin - last_end &lt; ignore_interval:
            # Compress.
            last_end = date_end
            continue
        new_intervals.append((last_begin, last_end))
        last_begin, last_end = date_begin, date_end
    new_intervals.append((last_begin, last_end))
    return new_intervals
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.lifetimes.compress_lifetimes_days" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.lifetimes.compress_lifetimes_days(lifetimes_map, num_days)</code>


<a href="#beancount.ops.lifetimes.compress_lifetimes_days" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Compress a lifetimes map to ignore short stretches of unused days.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>lifetimes_map</strong> – A dict of currency intervals as returned by get_commodity_lifetimes.</p></li>
            <li><p><strong>num_days</strong> – An integer, the number of unused days to ignore.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A new dict of lifetimes map where some intervals may have been joined.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/lifetimes.py</code></summary>
          <pre class="highlight"><code class="language-python">def compress_lifetimes_days(lifetimes_map, num_days):
    """Compress a lifetimes map to ignore short stretches of unused days.

    Args:
      lifetimes_map: A dict of currency intervals as returned by get_commodity_lifetimes.
      num_days: An integer, the number of unused days to ignore.
    Returns:
      A new dict of lifetimes map where some intervals may have been joined.
    """
    return {
        currency_pair: compress_intervals_days(intervals, num_days)
        for currency_pair, intervals in lifetimes_map.items()
    }
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.lifetimes.get_commodity_lifetimes" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.lifetimes.get_commodity_lifetimes(entries)</code>


<a href="#beancount.ops.lifetimes.get_commodity_lifetimes" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Given a list of directives, figure out the life of each commodity.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> – A list of directives.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A dict of (currency, cost-currency) commodity strings to lists of (start,
end) datetime.date pairs. The dates are inclusive of the day the commodity
was seen; the end/last dates are one day <em>after</em> the last date seen.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/lifetimes.py</code></summary>
          <pre class="highlight"><code class="language-python">def get_commodity_lifetimes(entries):
    """Given a list of directives, figure out the life of each commodity.

    Args:
      entries: A list of directives.
    Returns:
      A dict of (currency, cost-currency) commodity strings to lists of (start,
      end) datetime.date pairs. The dates are inclusive of the day the commodity
      was seen; the end/last dates are one day _after_ the last date seen.
    """
    lifetimes = collections.defaultdict(list)

    # The current set of active commodities.
    commodities = set()

    # The current balances across all accounts.
    balances = collections.defaultdict(inventory.Inventory)

    for entry in entries:
        # Process only transaction entries.
        if not isinstance(entry, data.Transaction):
            continue

        # Update the balance of affected accounts and check locally whether that
        # triggered a change in the set of commodities.
        commodities_changed = False
        for posting in entry.postings:
            balance = balances[posting.account]
            commodities_before = balance.currency_pairs()
            balance.add_position(posting)
            commodities_after = balance.currency_pairs()
            if commodities_after != commodities_before:
                commodities_changed = True

        # If there was a change in one of the affected account's list of
        # commodities, recompute the total set globally. This should not
        # occur very frequently.
        if commodities_changed:
            new_commodities = set(
                itertools.chain(*(inv.currency_pairs() for inv in balances.values()))
            )
            if new_commodities != commodities:
                # The new global set of commodities has changed; update our
                # the dictionary of intervals.
                for currency in new_commodities - commodities:
                    lifetimes[currency].append((entry.date, None))

                for currency in commodities - new_commodities:
                    lifetime = lifetimes[currency]
                    begin_date, end_date = lifetime.pop(-1)
                    assert end_date is None
                    lifetime.append((begin_date, entry.date + ONEDAY))

                # Update our current set.
                commodities = new_commodities

    return lifetimes
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.lifetimes.required_daily_prices" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.lifetimes.required_daily_prices(lifetimes_map, date_last, weekdays_only=False)</code>


<a href="#beancount.ops.lifetimes.required_daily_prices" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Enumerate all the commodities and days where the price is required.</p>
<p>Given a map of lifetimes for a set of commodities, enumerate all the days
for each commodity where it is active. This can be used to connect to a
historical price fetcher routine to fill in missing price entries from an
existing ledger.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>lifetimes_map</strong> – A dict of currency to active intervals as returned by
get_commodity_lifetimes().</p></li>
            <li><p><strong>date_last</strong> – A datetime.date instance, the last date which we're interested in.</p></li>
            <li><p><strong>weekdays_only</strong> – Option to limit fetching to weekdays only.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>Tuples of (date, currency, cost-currency).</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/lifetimes.py</code></summary>
          <pre class="highlight"><code class="language-python">def required_daily_prices(lifetimes_map, date_last, weekdays_only=False):
    """Enumerate all the commodities and days where the price is required.

    Given a map of lifetimes for a set of commodities, enumerate all the days
    for each commodity where it is active. This can be used to connect to a
    historical price fetcher routine to fill in missing price entries from an
    existing ledger.

    Args:
      lifetimes_map: A dict of currency to active intervals as returned by
        get_commodity_lifetimes().
      date_last: A datetime.date instance, the last date which we're interested in.
      weekdays_only: Option to limit fetching to weekdays only.
    Returns:
      Tuples of (date, currency, cost-currency).
    """
    results = []
    for currency_pair, intervals in lifetimes_map.items():
        if currency_pair[1] is None:
            continue
        for date_begin, date_end in intervals:
            # Find first Weekday starting on or before minimum date.
            date = date_begin
            if weekdays_only:
                diff_days = 4 - date_begin.weekday()
                if diff_days &lt; 0:
                    date += datetime.timedelta(days=diff_days)

            # Iterate over all weekdays.
            if date_end is None:
                date_end = date_last
            while date &lt; date_end:
                results.append((date, currency_pair[0], currency_pair[1]))
                if weekdays_only and date.weekday() == 4:
                    date += 3 * ONEDAY
                else:
                    date += ONEDAY

    return sorted(results)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.lifetimes.required_weekly_prices" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.lifetimes.required_weekly_prices(lifetimes_map, date_last)</code>


<a href="#beancount.ops.lifetimes.required_weekly_prices" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Enumerate all the commodities and Fridays where the price is required.</p>
<p>Given a map of lifetimes for a set of commodities, enumerate all the Fridays
for each commodity where it is active. This can be used to connect to a
historical price fetcher routine to fill in missing price entries from an
existing ledger.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>lifetimes_map</strong> – A dict of currency to active intervals as returned by
get_commodity_lifetimes().</p></li>
            <li><p><strong>date_last</strong> – A datetime.date instance, the last date which we're interested in.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>Tuples of (date, currency, cost-currency).</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/lifetimes.py</code></summary>
          <pre class="highlight"><code class="language-python">def required_weekly_prices(lifetimes_map, date_last):
    """Enumerate all the commodities and Fridays where the price is required.

    Given a map of lifetimes for a set of commodities, enumerate all the Fridays
    for each commodity where it is active. This can be used to connect to a
    historical price fetcher routine to fill in missing price entries from an
    existing ledger.

    Args:
      lifetimes_map: A dict of currency to active intervals as returned by
        get_commodity_lifetimes().
      date_last: A datetime.date instance, the last date which we're interested in.
    Returns:
      Tuples of (date, currency, cost-currency).
    """
    results = []
    for currency_pair, intervals in lifetimes_map.items():
        if currency_pair[1] is None:
            continue
        for date_begin, date_end in intervals:
            # Find first Friday before the minimum date.
            diff_days = 4 - date_begin.weekday()
            if diff_days &gt;= 1:
                diff_days -= 7
            date = date_begin + datetime.timedelta(days=diff_days)

            # Iterate over all Fridays.
            if date_end is None:
                date_end = date_last
            while date &lt; date_end:
                results.append((date, currency_pair[0], currency_pair[1]))
                date += ONE_WEEK
    return sorted(results)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.lifetimes.trim_intervals" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.lifetimes.trim_intervals(intervals, trim_start=None, trim_end=None)</code>


<a href="#beancount.ops.lifetimes.trim_intervals" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Trim a list of date pairs to be within a start and end date.
Useful in update-style price fetching.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>intervals</strong> – A list of pairs of datetime.date instances</p></li>
            <li><p><strong>trim_start</strong> – An inclusive starting date.</p></li>
            <li><p><strong>trim_end</strong> – An exclusive starting date.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A list of new intervals (pairs of (date, date)).</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/lifetimes.py</code></summary>
          <pre class="highlight"><code class="language-python">def trim_intervals(intervals, trim_start=None, trim_end=None):
    """Trim a list of date pairs to be within a start and end date.
    Useful in update-style price fetching.

    Args:
      intervals: A list of pairs of datetime.date instances
      trim_start: An inclusive starting date.
      trim_end: An exclusive starting date.
    Returns:
      A list of new intervals (pairs of (date, date)).
    """
    new_intervals = []
    iter_intervals = iter(intervals)
    if trim_start is not None and trim_end is not None and trim_end &lt; trim_start:
        raise ValueError("Trim end date is before start date")

    for date_begin, date_end in iter_intervals:
        if trim_start is not None and trim_start &gt; date_begin:
            date_begin = trim_start
        if trim_end is not None:
            if date_end is None or trim_end &lt; date_end:
                date_end = trim_end

        if date_end is None or date_begin &lt;= date_end:
            new_intervals.append((date_begin, date_end))
    return new_intervals
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="beancount.ops.pad" class="doc doc-heading">
        <code>beancount.ops.pad</code>



<a href="#beancount.ops.pad" class="headerlink" title="Permanent link"></a></h2>

    <div class="doc doc-contents ">

      <p>Automatic padding of gaps between entries.</p>



  <div class="doc doc-children">










  <div class="doc doc-object doc-class">



<h3 id="beancount.ops.pad.PadError" class="doc doc-heading">
        <code>
beancount.ops.pad.PadError            (<span title="tuple">tuple</span>)
        </code>



<a href="#beancount.ops.pad.PadError" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Represents an error encountered during padding.</p>




  <div class="doc doc-children">












  <div class="doc doc-object doc-method">



<h4 id="beancount.ops.pad.PadError.__getnewargs__" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.pad.PadError.__getnewargs__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.ops.pad.PadError.__getnewargs__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return self as a plain tuple.  Used by copy and pickle.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/ops/pad.py</code></summary>
          <pre class="highlight"><code class="language-python">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.ops.pad.PadError.__new__" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.pad.PadError.__new__(_cls, source, message, entry)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
      <small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
  </span>

<a href="#beancount.ops.pad.PadError.__new__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Create new instance of PadError(source, message, entry)</p>

    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.ops.pad.PadError.__repr__" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.pad.PadError.__repr__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.ops.pad.PadError.__repr__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a nicely formatted representation string</p>

        <details class="quote">
          <summary>Source code in <code>beancount/ops/pad.py</code></summary>
          <pre class="highlight"><code class="language-python">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>




  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.pad.pad" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.pad.pad(entries, options_map)</code>


<a href="#beancount.ops.pad.pad" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Insert transaction entries for to fulfill a subsequent balance check.</p>
<p>Synthesize and insert Transaction entries right after Pad entries in order
to fulfill checks in the padded accounts. Returns a new list of entries.
Note that this doesn't pad across parent-child relationships, it is a very
simple kind of pad. (I have found this to be sufficient in practice, and
simpler to implement and understand.)</p>
<p>Furthermore, this pads for a single currency only, that is, balance checks
are specified only for one currency at a time, and pads will only be
inserted for those currencies.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> – A list of directives.</p></li>
            <li><p><strong>options_map</strong> – A parser options dict.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A new list of directives, with Pad entries inserted, and a list of new
errors produced.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/pad.py</code></summary>
          <pre class="highlight"><code class="language-python">def pad(entries, options_map):
    """Insert transaction entries for to fulfill a subsequent balance check.

    Synthesize and insert Transaction entries right after Pad entries in order
    to fulfill checks in the padded accounts. Returns a new list of entries.
    Note that this doesn't pad across parent-child relationships, it is a very
    simple kind of pad. (I have found this to be sufficient in practice, and
    simpler to implement and understand.)

    Furthermore, this pads for a single currency only, that is, balance checks
    are specified only for one currency at a time, and pads will only be
    inserted for those currencies.

    Args:
      entries: A list of directives.
      options_map: A parser options dict.
    Returns:
      A new list of directives, with Pad entries inserted, and a list of new
      errors produced.
    """
    pad_errors = []

    # Find all the pad entries and group them by account.
    pads = list(misc_utils.filter_type(entries, data.Pad))
    pad_dict = misc_utils.groupby(lambda x: x.account, pads)

    # Partially realize the postings, so we can iterate them by account.
    by_account = realization.postings_by_account(entries)

    # A dict of pad -&gt; list of entries to be inserted.
    new_entries = {id(pad): [] for pad in pads}

    # Process each account that has a padding group.
    for account_, pad_list in sorted(pad_dict.items()):
        # Last encountered / currency active pad entry.
        active_pad = None

        # Gather all the postings for the account and its children.
        postings = []
        is_child = account.parent_matcher(account_)
        for item_account, item_postings in by_account.items():
            if is_child(item_account):
                postings.extend(item_postings)
        postings.sort(key=data.posting_sortkey)

        # A set of currencies already padded so far in this account.
        padded_lots = set()

        pad_balance = inventory.Inventory()
        for entry in postings:
            assert not isinstance(entry, data.Posting)
            if isinstance(entry, data.TxnPosting):
                # This is a transaction; update the running balance for this
                # account.
                pad_balance.add_position(entry.posting)

            elif isinstance(entry, data.Pad):
                if entry.account == account_:
                    # Mark this newly encountered pad as active and allow all lots
                    # to be padded heretofore.
                    active_pad = entry
                    padded_lots = set()

            elif isinstance(entry, data.Balance):
                check_amount = entry.amount

                # Compare the current balance amount to the expected one from
                # the check entry. IMPORTANT: You need to understand that this
                # does not check a single position, but rather checks that the
                # total amount for a particular currency (which itself is
                # distinct from the cost).
                balance_amount = pad_balance.get_currency_units(check_amount.currency)
                diff_amount = amount.sub(balance_amount, check_amount)

                # Use the specified tolerance or automatically infer it.
                tolerance = balance.get_balance_tolerance(entry, options_map)

                if abs(diff_amount.number) &gt; tolerance:
                    # The check fails; we need to pad.

                    # Pad only if pad entry is active and we haven't already
                    # padded that lot since it was last encountered.
                    if active_pad and (check_amount.currency not in padded_lots):
                        # Note: we decide that it's an error to try to pad
                        # positions at cost; we check here that all the existing
                        # positions with that currency have no cost.
                        positions = [
                            pos
                            for pos in pad_balance.get_positions()
                            if pos.units.currency == check_amount.currency
                        ]
                        for position_ in positions:
                            if position_.cost is not None:
                                pad_errors.append(
                                    PadError(
                                        entry.meta,
                                        (
                                            "Attempt to pad an entry with cost for "
                                            "balance: {}".format(pad_balance)
                                        ),
                                        active_pad,
                                    )
                                )

                        # Thus our padding lot is without cost by default.
                        diff_position = position.Position.from_amounts(
                            amount.Amount(
                                check_amount.number - balance_amount.number,
                                check_amount.currency,
                            )
                        )

                        # Synthesize a new transaction entry for the difference.
                        narration = (
                            "(Padding inserted for Balance of {} for difference {})"
                        ).format(check_amount, diff_position)
                        new_entry = data.Transaction(
                            active_pad.meta.copy(),
                            active_pad.date,
                            flags.FLAG_PADDING,
                            None,
                            narration,
                            data.EMPTY_SET,
                            data.EMPTY_SET,
                            [],
                        )

                        new_entry.postings.append(
                            data.Posting(
                                active_pad.account,
                                diff_position.units,
                                diff_position.cost,
                                None,
                                None,
                                entry.meta,
                            )
                        )
                        neg_diff_position = -diff_position
                        new_entry.postings.append(
                            data.Posting(
                                active_pad.source_account,
                                neg_diff_position.units,
                                neg_diff_position.cost,
                                None,
                                None,
                                entry.meta,
                            )
                        )

                        # Save it for later insertion after the active pad.
                        new_entries[id(active_pad)].append(new_entry)

                        # Fixup the running balance.
                        pos, _ = pad_balance.add_position(diff_position)
                        if pos is not None and pos.is_negative_at_cost():
                            raise ValueError(
                                "Position held at cost goes negative: {}".format(pos)
                            )

                # Mark this lot as padded. Further checks should not pad this lot.
                padded_lots.add(check_amount.currency)

    # Insert the newly created entries right after the pad entries that created them.
    padded_entries = []
    for entry in entries:
        padded_entries.append(entry)
        if isinstance(entry, data.Pad):
            entry_list = new_entries[id(entry)]
            if entry_list:
                padded_entries.extend(entry_list)
            else:
                # Generate errors on unused pad entries.
                pad_errors.append(PadError(entry.meta, "Unused Pad entry", entry))

    return padded_entries, pad_errors
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="beancount.ops.summarize" class="doc doc-heading">
        <code>beancount.ops.summarize</code>



<a href="#beancount.ops.summarize" class="headerlink" title="Permanent link"></a></h2>

    <div class="doc doc-contents ">

      <p>Summarization of entries.</p>
<p>This code is used to summarize a sequence of entries (e.g. during a time period)
into a few "opening balance" entries. This is when computing a balance sheet for
a specific time period: we don't want to see the entries from before some period
of time, so we fold them into a single transaction per account that has the sum
total amount of that account.</p>



  <div class="doc doc-children">










  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.summarize.balance_by_account" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.summarize.balance_by_account(entries, date=None, compress_unbooked=False)</code>


<a href="#beancount.ops.summarize.balance_by_account" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Sum up the balance per account for all entries strictly before 'date'.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> (<code>Directives</code>) – A list of directives.</p></li>
            <li><p><strong>date</strong> (<code>datetime.date | None</code>) – An optional datetime.date instance. If provided, stop accumulating
on and after this date. This is useful for summarization before a
specific date.</p></li>
            <li><p><strong>compress_unbooked</strong> (<code>bool</code>) – For accounts that have a booking method of NONE,
compress their positions into a single average position. This can be
used when you export the full list of positions, because those accounts
will have a myriad of small positions from fees at negative cost and
what-not.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p><code>tuple[dict[Account, inventory.Inventory], int]</code> – A pair of a dict of account string to instance Inventory (the balance of
this account before the given date), and the index in the list of entries
where the date was encountered. If all entries are located before the
cutoff date, an index one beyond the last entry is returned.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/summarize.py</code></summary>
          <pre class="highlight"><code class="language-python">def balance_by_account(
    entries: Directives,
    date: datetime.date | None = None,
    compress_unbooked: bool = False,
) -&gt; tuple[dict[Account, inventory.Inventory], int]:
    """Sum up the balance per account for all entries strictly before 'date'.

    Args:
      entries: A list of directives.
      date: An optional datetime.date instance. If provided, stop accumulating
        on and after this date. This is useful for summarization before a
        specific date.
      compress_unbooked: For accounts that have a booking method of NONE,
        compress their positions into a single average position. This can be
        used when you export the full list of positions, because those accounts
        will have a myriad of small positions from fees at negative cost and
        what-not.
    Returns:
      A pair of a dict of account string to instance Inventory (the balance of
      this account before the given date), and the index in the list of entries
      where the date was encountered. If all entries are located before the
      cutoff date, an index one beyond the last entry is returned.

    """
    balances: dict[Account, inventory.Inventory] = collections.defaultdict(
        inventory.Inventory
    )
    for index, entry in enumerate(entries):
        if date and entry.date &gt;= date:
            break

        if isinstance(entry, Transaction):
            for posting in entry.postings:
                account_balance = balances[posting.account]

                # Note: We must allow negative lots at cost, because this may be
                # used to reduce a filtered list of entries which may not
                # include the entries necessary to keep units at cost always
                # above zero. The only summation that is guaranteed to be above
                # zero is if all the entries are being summed together, no
                # entries are filtered, at least for a particular account's
                # postings.
                account_balance.add_position(posting)
    else:
        index = len(entries)

    # If the account has "NONE" booking method, merge all its postings
    # together in order to obtain an accurate cost basis and balance of
    # units.
    #
    # (This is a complex issue.) If you accrued positions without having them
    # booked properly against existing cost bases, you have not properly accounted
    # for the profit/loss to other postings. This means that the resulting
    # profit/loss is merged in the cost basis of the positive and negative
    # postings.
    if compress_unbooked:
        oc_map = getters.get_account_open_close(entries)
        accounts_map = {account: dopen for account, (dopen, _) in oc_map.items()}

        for account, balance in balances.items():
            dopen = accounts_map.get(account, None)
            if dopen is not None and dopen.booking is data.Booking.NONE:
                average_balance = balance.average()
                balances[account] = inventory.Inventory(pos for pos in average_balance)

    return balances, index
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.summarize.cap" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.summarize.cap(entries, account_types, conversion_currency, account_earnings, account_conversions)</code>


<a href="#beancount.ops.summarize.cap" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Transfer net income to equity and insert a final conversion entry.</p>
<p>This is used to move and nullify balances from the income and expense
accounts to an equity account in order to draw up a balance sheet with a
balance of precisely zero.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> (<code>Directives</code>) – A list of directives.</p></li>
            <li><p><strong>account_types</strong> (<code>AccountTypes</code>) – An instance of AccountTypes.</p></li>
            <li><p><strong>conversion_currency</strong> (<code>Currency</code>) – A string, the transfer currency to use for zero prices
on the conversion entry.</p></li>
            <li><p><strong>account_earnings</strong> (<code>Account</code>) – A string, the name of the equity account to transfer
final balances of the income and expense accounts to.</p></li>
            <li><p><strong>account_conversions</strong> (<code>Account</code>) – A string, the name of the equity account to use as
the source for currency conversions.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p><code>Directives</code> – A modified list of entries, with the income and expense accounts
transferred.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/summarize.py</code></summary>
          <pre class="highlight"><code class="language-python">def cap(
    entries: Directives,
    account_types: AccountTypes,
    conversion_currency: Currency,
    account_earnings: Account,
    account_conversions: Account,
) -&gt; Directives:
    """Transfer net income to equity and insert a final conversion entry.

    This is used to move and nullify balances from the income and expense
    accounts to an equity account in order to draw up a balance sheet with a
    balance of precisely zero.

    Args:
      entries: A list of directives.
      account_types: An instance of AccountTypes.
      conversion_currency: A string, the transfer currency to use for zero prices
        on the conversion entry.
      account_earnings: A string, the name of the equity account to transfer
        final balances of the income and expense accounts to.
      account_conversions: A string, the name of the equity account to use as
        the source for currency conversions.
    Returns:
      A modified list of entries, with the income and expense accounts
      transferred.
    """

    # Transfer the balances of income and expense accounts as earnings / net
    # income.
    income_statement_account_pred = lambda account: is_income_statement_account(
        account, account_types
    )
    entries = transfer_balances(
        entries, None, income_statement_account_pred, account_earnings
    )

    # Insert final conversion entries.
    entries = conversions(entries, account_conversions, conversion_currency, None)

    return entries
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.summarize.cap_opt" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.summarize.cap_opt(entries, options_map)</code>


<a href="#beancount.ops.summarize.cap_opt" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Close by getting all the parameters from an options map.</p>
<p>See cap() for details.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> (<code>Directives</code>) – See cap().</p></li>
            <li><p><strong>options_map</strong> (<code>OptionsMap</code>) – A parser's option_map.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p><code>Directives</code> – Same as close().</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/summarize.py</code></summary>
          <pre class="highlight"><code class="language-python">def cap_opt(entries: Directives, options_map: OptionsMap) -&gt; Directives:
    """Close by getting all the parameters from an options map.

    See cap() for details.

    Args:
      entries: See cap().
      options_map: A parser's option_map.
    Returns:
      Same as close().
    """
    account_types = options.get_account_types(options_map)
    current_accounts = options.get_current_accounts(options_map)
    conversion_currency = options_map["conversion_currency"]
    return cap(entries, account_types, conversion_currency, *current_accounts)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.summarize.clamp" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.summarize.clamp(entries, begin_date, end_date, account_types, conversion_currency, account_earnings, account_opening, account_conversions)</code>


<a href="#beancount.ops.summarize.clamp" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Filter entries to include only those during a specified time period.</p>
<p>Firstly, this method will transfer all balances for the income and expense
accounts occurring before the given period begin date to the
'account_earnings' account (earnings before the period, or "retained
earnings") and summarize all of the transactions before that date against
the 'account_opening' account (usually "opening balances"). The resulting
income and expense accounts should have no transactions (since their
balances have been transferred out and summarization of zero balances should
not add any transactions).</p>
<p>Secondly, all the entries after the period end date will be truncated and a
conversion entry will be added for the resulting transactions that reflect
changes occurring between the beginning and end of the exercise period. The
resulting balance of all account should be empty.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> (<code>Directives</code>) – A list of directive tuples.</p></li>
            <li><p><strong>begin_date</strong> (<code>datetime.date</code>) – A datetime.date instance, the beginning of the period.</p></li>
            <li><p><strong>end_date</strong> (<code>datetime.date</code>) – A datetime.date instance, one day beyond the end of the period.</p></li>
            <li><p><strong>account_types</strong> (<code>AccountTypes</code>) – An instance of AccountTypes.</p></li>
            <li><p><strong>conversion_currency</strong> (<code>Currency</code>) – A string, the transfer currency to use for zero prices
on the conversion entry.</p></li>
            <li><p><strong>account_earnings</strong> (<code>Account</code>) – A string, the name of the account to transfer
previous earnings from the income statement accounts to the balance
sheet.</p></li>
            <li><p><strong>account_opening</strong> (<code>Account</code>) – A string, the name of the account in equity
to transfer previous balances from, in order to initialize account
balances at the beginning of the period. This is typically called an
opening balances account.</p></li>
            <li><p><strong>account_conversions</strong> (<code>Account</code>) – A string, the name of the equity account to
book currency conversions against.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A new list of entries is returned, and the index that points to the first
original transaction after the beginning date of the period. This index
can be used to generate the opening balances report, which is a balance
sheet fed with only the summarized entries.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/summarize.py</code></summary>
          <pre class="highlight"><code class="language-python">def clamp(
    entries: Directives,
    begin_date: datetime.date,
    end_date: datetime.date,
    account_types: AccountTypes,
    conversion_currency: Currency,
    account_earnings: Account,
    account_opening: Account,
    account_conversions: Account,
):
    """Filter entries to include only those during a specified time period.

    Firstly, this method will transfer all balances for the income and expense
    accounts occurring before the given period begin date to the
    'account_earnings' account (earnings before the period, or "retained
    earnings") and summarize all of the transactions before that date against
    the 'account_opening' account (usually "opening balances"). The resulting
    income and expense accounts should have no transactions (since their
    balances have been transferred out and summarization of zero balances should
    not add any transactions).

    Secondly, all the entries after the period end date will be truncated and a
    conversion entry will be added for the resulting transactions that reflect
    changes occurring between the beginning and end of the exercise period. The
    resulting balance of all account should be empty.

    Args:
      entries: A list of directive tuples.
      begin_date: A datetime.date instance, the beginning of the period.
      end_date: A datetime.date instance, one day beyond the end of the period.
      account_types: An instance of AccountTypes.
      conversion_currency: A string, the transfer currency to use for zero prices
        on the conversion entry.
      account_earnings: A string, the name of the account to transfer
        previous earnings from the income statement accounts to the balance
        sheet.
      account_opening: A string, the name of the account in equity
        to transfer previous balances from, in order to initialize account
        balances at the beginning of the period. This is typically called an
        opening balances account.
      account_conversions: A string, the name of the equity account to
        book currency conversions against.
    Returns:
      A new list of entries is returned, and the index that points to the first
      original transaction after the beginning date of the period. This index
      can be used to generate the opening balances report, which is a balance
      sheet fed with only the summarized entries.
    """
    # Transfer income and expenses before the period to equity.
    income_statement_account_pred = lambda account: is_income_statement_account(
        account, account_types
    )
    entries = transfer_balances(
        entries, begin_date, income_statement_account_pred, account_earnings
    )

    # Summarize all the previous balances, after transferring the income and
    # expense balances, so all entries for those accounts before the begin date
    # should now disappear.
    entries, index = summarize(entries, begin_date, account_opening)

    # Truncate the entries after this.
    entries = truncate(entries, end_date)

    # Insert conversion entries.
    entries = conversions(entries, account_conversions, conversion_currency, end_date)

    return entries, index
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.summarize.clamp_opt" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.summarize.clamp_opt(entries, begin_date, end_date, options_map)</code>


<a href="#beancount.ops.summarize.clamp_opt" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Clamp by getting all the parameters from an options map.</p>
<p>See clamp() for details.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> (<code>Directives</code>) – See clamp().</p></li>
            <li><p><strong>begin_date</strong> (<code>datetime.date</code>) – See clamp().</p></li>
            <li><p><strong>end_date</strong> (<code>datetime.date</code>) – See clamp().</p></li>
            <li><p><strong>options_map</strong> (<code>OptionsMap</code>) – A parser's option_map.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p><code>tuple[Directives, int]</code> – Same as clamp().</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/summarize.py</code></summary>
          <pre class="highlight"><code class="language-python">def clamp_opt(
    entries: Directives,
    begin_date: datetime.date,
    end_date: datetime.date,
    options_map: OptionsMap,
) -&gt; tuple[Directives, int]:
    """Clamp by getting all the parameters from an options map.

    See clamp() for details.

    Args:
      entries: See clamp().
      begin_date: See clamp().
      end_date: See clamp().
      options_map: A parser's option_map.
    Returns:
      Same as clamp().
    """
    account_types = options.get_account_types(options_map)
    previous_earnings, previous_balances, _ = options.get_previous_accounts(options_map)
    _, current_conversions = options.get_current_accounts(options_map)

    conversion_currency = options_map["conversion_currency"]
    return clamp(
        entries,
        begin_date,
        end_date,
        account_types,
        conversion_currency,
        previous_earnings,
        previous_balances,
        current_conversions,
    )
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.summarize.clear" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.summarize.clear(entries, date, account_types, account_earnings)</code>


<a href="#beancount.ops.summarize.clear" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Transfer income and expenses balances at the given date to the equity accounts.</p>
<p>This method insert entries to zero out balances on income and expenses
accounts by transferring them to an equity account.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> (<code>Directives</code>) – A list of directive tuples.</p></li>
            <li><p><strong>date</strong> (<code>datetime.date</code>) – A datetime.date instance, one day beyond the end of the period. This
date can be optionally left to None in order to close at the end of the
list of entries.</p></li>
            <li><p><strong>account_types</strong> (<code>AccountTypes</code>) – An instance of AccountTypes.</p></li>
            <li><p><strong>account_earnings</strong> (<code>Account</code>) – A string, the name of the account to transfer
previous earnings from the income statement accounts to the balance
sheet.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p><code>tuple[Directives, int]</code> – A new list of entries is returned, and the index that points to one before
the last original transaction before the transfers.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/summarize.py</code></summary>
          <pre class="highlight"><code class="language-python">def clear(
    entries: Directives,
    date: datetime.date,
    account_types: AccountTypes,
    account_earnings: Account,
) -&gt; tuple[Directives, int]:
    """Transfer income and expenses balances at the given date to the equity accounts.

    This method insert entries to zero out balances on income and expenses
    accounts by transferring them to an equity account.

    Args:
      entries: A list of directive tuples.
      date: A datetime.date instance, one day beyond the end of the period. This
        date can be optionally left to None in order to close at the end of the
        list of entries.
      account_types: An instance of AccountTypes.
      account_earnings: A string, the name of the account to transfer
        previous earnings from the income statement accounts to the balance
        sheet.
    Returns:
      A new list of entries is returned, and the index that points to one before
      the last original transaction before the transfers.
    """
    index = len(entries)

    # Transfer income and expenses before the period to equity.
    income_statement_account_pred = lambda account: is_income_statement_account(
        account, account_types
    )
    new_entries = transfer_balances(
        entries, date, income_statement_account_pred, account_earnings
    )

    return new_entries, index
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.summarize.clear_opt" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.summarize.clear_opt(entries, date, options_map)</code>


<a href="#beancount.ops.summarize.clear_opt" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Convenience function to clear() using an options map.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/ops/summarize.py</code></summary>
          <pre class="highlight"><code class="language-python">def clear_opt(
    entries: Directives, date: datetime.date, options_map: OptionsMap
) -&gt; tuple[Directives, int]:
    """Convenience function to clear() using an options map."""
    account_types = options.get_account_types(options_map)
    current_accounts = options.get_current_accounts(options_map)
    return clear(entries, date, account_types, current_accounts[0])
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.summarize.close" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.summarize.close(entries, date, conversion_currency, account_conversions)</code>


<a href="#beancount.ops.summarize.close" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Truncate entries that occur after a particular date and ensure balance.</p>
<p>This method essentially removes entries after a date. It truncates the
future. To do so, it will</p>
<ol>
<li>
<p>Remove all entries which occur after 'date', if given.</p>
</li>
<li>
<p>Insert conversion transactions at the end of the list of entries to
   ensure that the total balance of all postings sums up to empty.</p>
</li>
</ol>
<p>The result is a list of entries with a total balance of zero, with possibly
non-zero balances for the income/expense accounts. To produce a final
balance sheet, use transfer() to move the net income to the equity accounts.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> (<code>Directives</code>) – A list of directive tuples.</p></li>
            <li><p><strong>date</strong> (<code>datetime.date</code>) – A datetime.date instance, one day beyond the end of the period. This
date can be optionally left to None in order to close at the end of the
list of entries.</p></li>
            <li><p><strong>conversion_currency</strong> (<code>Currency</code>) – A string, the transfer currency to use for zero prices
on the conversion entry.</p></li>
            <li><p><strong>account_conversions</strong> (<code>Account</code>) – A string, the name of the equity account to
book currency conversions against.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p><code>tuple[Directives, int]</code> – A new list of entries is returned, and the index that points to one beyond
the last original transaction that was provided. Further entries may have
been inserted to normalize conversions and ensure the total balance sums
to zero.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/summarize.py</code></summary>
          <pre class="highlight"><code class="language-python">def close(
    entries: Directives,
    date: datetime.date,
    conversion_currency: Currency,
    account_conversions: Account,
) -&gt; tuple[Directives, int]:
    """Truncate entries that occur after a particular date and ensure balance.

    This method essentially removes entries after a date. It truncates the
    future. To do so, it will

    1. Remove all entries which occur after 'date', if given.

    2. Insert conversion transactions at the end of the list of entries to
       ensure that the total balance of all postings sums up to empty.

    The result is a list of entries with a total balance of zero, with possibly
    non-zero balances for the income/expense accounts. To produce a final
    balance sheet, use transfer() to move the net income to the equity accounts.

    Args:
      entries: A list of directive tuples.
      date: A datetime.date instance, one day beyond the end of the period. This
        date can be optionally left to None in order to close at the end of the
        list of entries.
      conversion_currency: A string, the transfer currency to use for zero prices
        on the conversion entry.
      account_conversions: A string, the name of the equity account to
        book currency conversions against.
    Returns:
      A new list of entries is returned, and the index that points to one beyond
      the last original transaction that was provided. Further entries may have
      been inserted to normalize conversions and ensure the total balance sums
      to zero.
    """

    # Truncate the entries after the date, if a date has been provided.
    if date is not None:
        entries = truncate(entries, date)

    # Keep an index to the truncated list of entries (before conversions).
    index = len(entries)

    # Insert a conversions entry to ensure the total balance of all accounts is
    # flush zero.
    entries = conversions(entries, account_conversions, conversion_currency, date)

    return entries, index
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.summarize.close_opt" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.summarize.close_opt(entries, date, options_map)</code>


<a href="#beancount.ops.summarize.close_opt" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Convenience function to close() using an options map.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/ops/summarize.py</code></summary>
          <pre class="highlight"><code class="language-python">def close_opt(
    entries: Directives, date: datetime.date, options_map: OptionsMap
) -&gt; tuple[Directives, int]:
    """Convenience function to close() using an options map."""
    conversion_currency = options_map["conversion_currency"]
    current_accounts = options.get_current_accounts(options_map)
    return close(entries, date, conversion_currency, current_accounts[1])
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.summarize.conversions" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.summarize.conversions(entries, conversion_account, conversion_currency, date=None)</code>


<a href="#beancount.ops.summarize.conversions" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Insert a conversion entry at date 'date' at the given account.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> (<code>Directives</code>) – A list of entries.</p></li>
            <li><p><strong>conversion_account</strong> (<code>Account</code>) – A string, the account to book against.</p></li>
            <li><p><strong>conversion_currency</strong> (<code>Currency</code>) – A string, the transfer currency to use for zero prices
on the conversion entry.</p></li>
            <li><p><strong>date</strong> (<code>datetime.date | None</code>) – The date before which to insert the conversion entry. The new
entry will be inserted as the last entry of the date just previous
to this date.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p><code>Directives</code> – A modified list of entries.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/summarize.py</code></summary>
          <pre class="highlight"><code class="language-python">def conversions(
    entries: Directives,
    conversion_account: Account,
    conversion_currency: Currency,
    date: datetime.date | None = None,
) -&gt; Directives:
    """Insert a conversion entry at date 'date' at the given account.

    Args:
      entries: A list of entries.
      conversion_account: A string, the account to book against.
      conversion_currency: A string, the transfer currency to use for zero prices
        on the conversion entry.
      date: The date before which to insert the conversion entry. The new
        entry will be inserted as the last entry of the date just previous
        to this date.
    Returns:
      A modified list of entries.
    """
    # Compute the balance at the given date.
    conversion_balance = interpolate.compute_entries_balance(entries, date=date)

    # Early exit if there is nothing to do.
    conversion_cost_balance = conversion_balance.reduce(convert.get_cost)
    if conversion_cost_balance.is_empty():
        return entries

    # Calculate the index and the date for the new entry. We want to store it as
    # the last transaction of the day before.
    if date is not None:
        index = bisect_key.bisect_left_with_key(entries, date, key=lambda entry: entry.date)
        last_date = date - datetime.timedelta(days=1)
    else:
        index = len(entries)
        last_date = entries[-1].date

    meta = data.new_metadata("&lt;conversions&gt;", -1)
    narration = "Conversion for {}".format(conversion_balance)
    conversion_entry = Transaction(
        meta,
        last_date,
        flags.FLAG_CONVERSIONS,
        None,
        narration,
        data.EMPTY_SET,
        data.EMPTY_SET,
        [],
    )
    for position in conversion_cost_balance.get_positions():
        # Important note: Set the cost to zero here to maintain the balance
        # invariant. (This is the only single place we cheat on the balance rule
        # in the entire system and this is necessary; see documentation on
        # Conversions.)
        price = amount.Amount(ZERO, conversion_currency)
        neg_pos = -position
        conversion_entry.postings.append(
            data.Posting(conversion_account, neg_pos.units, neg_pos.cost, price, None, None)
        )

    # Make a copy of the list of entries and insert the new transaction into it.
    new_entries = list(entries)
    new_entries.insert(index, conversion_entry)

    return new_entries
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.summarize.create_entries_from_balances" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.summarize.create_entries_from_balances(balances, date, source_account, direction, meta, flag, narration_template)</code>


<a href="#beancount.ops.summarize.create_entries_from_balances" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>"Create a list of entries from a dict of balances.</p>
<p>This method creates a list of new entries to transfer the amounts in the
'balances' dict to/from another account specified in 'source_account'.</p>
<p>The balancing posting is created with the equivalent at cost. In other
words, if you attempt to balance 10 HOOL {500 USD}, this will synthesize a
posting with this position on one leg, and with 5000 USD on the
'source_account' leg.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>balances</strong> (<code>dict[Account, inventory.Inventory]</code>) – A dict of account name strings to Inventory instances.</p></li>
            <li><p><strong>date</strong> (<code>datetime.date</code>) – A datetime.date object, the date at which to create the transaction.</p></li>
            <li><p><strong>source_account</strong> (<code>Account</code>) – A string, the name of the account to pull the balances
from. This is the magician's hat to pull the rabbit from.</p></li>
            <li><p><strong>direction</strong> (<code>bool</code>) – If 'direction' is True, the new entries transfer TO the
balances account from the source account; otherwise the new entries
transfer FROM the balances into the source account.</p></li>
            <li><p><strong>meta</strong> (<code>data.Meta</code>) – A dict to use as metadata for the transactions.</p></li>
            <li><p><strong>flag</strong> (<code>data.Flag</code>) – A string, the flag to use for the transactions.</p></li>
            <li><p><strong>narration_template</strong> (<code>str</code>) – A format string for creating the narration. It is
formatted with 'account' and 'date' replacement variables.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p><code>Directives</code> – A list of newly synthesizes Transaction entries.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/summarize.py</code></summary>
          <pre class="highlight"><code class="language-python">def create_entries_from_balances(
    balances: dict[Account, inventory.Inventory],
    date: datetime.date,
    source_account: Account,
    direction: bool,
    meta: data.Meta,
    flag: data.Flag,
    narration_template: str,
) -&gt; Directives:
    """ "Create a list of entries from a dict of balances.

    This method creates a list of new entries to transfer the amounts in the
    'balances' dict to/from another account specified in 'source_account'.

    The balancing posting is created with the equivalent at cost. In other
    words, if you attempt to balance 10 HOOL {500 USD}, this will synthesize a
    posting with this position on one leg, and with 5000 USD on the
    'source_account' leg.

    Args:
      balances: A dict of account name strings to Inventory instances.
      date: A datetime.date object, the date at which to create the transaction.
      source_account: A string, the name of the account to pull the balances
        from. This is the magician's hat to pull the rabbit from.
      direction: If 'direction' is True, the new entries transfer TO the
        balances account from the source account; otherwise the new entries
        transfer FROM the balances into the source account.
      meta: A dict to use as metadata for the transactions.
      flag: A string, the flag to use for the transactions.
      narration_template: A format string for creating the narration. It is
        formatted with 'account' and 'date' replacement variables.
    Returns:
      A list of newly synthesizes Transaction entries.
    """
    new_entries: Directives = []
    for account, account_balance in sorted(balances.items()):
        # Don't create new entries where there is no balance.
        if account_balance.is_empty():
            continue

        narration = narration_template.format(account=account, date=date)

        if not direction:
            account_balance = -account_balance

        postings: list[data.Posting] = []
        new_entry = Transaction(
            meta, date, flag, None, narration, data.EMPTY_SET, data.EMPTY_SET, postings
        )

        for position in account_balance.get_positions():
            postings.append(
                data.Posting(account, position.units, position.cost, None, None, None)
            )
            cost = -convert.get_cost(position)
            postings.append(data.Posting(source_account, cost, None, None, None, None))

        new_entries.append(new_entry)

    return new_entries
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.summarize.get_open_entries" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.summarize.get_open_entries(entries, date)</code>


<a href="#beancount.ops.summarize.get_open_entries" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Gather the list of active Open entries at date.</p>
<p>This returns the list of Open entries that have not been closed at the given
date, in the same order they were observed in the document.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> (<code>Directives</code>) – A list of directives.</p></li>
            <li><p><strong>date</strong> (<code>datetime.date</code>) – The date at which to look for an open entry. If not specified, will
return the entries still open at the latest date.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p><code>list[Open]</code> – A list of Open directives.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/summarize.py</code></summary>
          <pre class="highlight"><code class="language-python">def get_open_entries(entries: Directives, date: datetime.date) -&gt; list[Open]:
    """Gather the list of active Open entries at date.

    This returns the list of Open entries that have not been closed at the given
    date, in the same order they were observed in the document.

    Args:
      entries: A list of directives.
      date: The date at which to look for an open entry. If not specified, will
        return the entries still open at the latest date.
    Returns:
      A list of Open directives.
    """
    open_entries: dict[Account, tuple[int, Open]] = {}
    for index, entry in enumerate(entries):
        if date is not None and entry.date &gt;= date:
            break

        if isinstance(entry, Open):
            try:
                ex_index, ex_entry = open_entries[entry.account]
                if entry.date &lt; ex_entry.date:
                    open_entries[entry.account] = (index, entry)
            except KeyError:
                open_entries[entry.account] = (index, entry)

        elif isinstance(entry, Close):
            # If there is no corresponding open, don't raise an error.
            open_entries.pop(entry.account, None)

    return [entry for (index, entry) in sorted(open_entries.values())]
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.summarize.open" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.summarize.open(entries, date, account_types, conversion_currency, account_earnings, account_opening, account_conversions)</code>


<a href="#beancount.ops.summarize.open" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Summarize entries before a date and transfer income/expenses to equity.</p>
<p>This method essentially prepares a list of directives to contain only
transactions that occur after a particular date. It truncates the past. To
do so, it will</p>
<ol>
<li>
<p>Insert conversion transactions at the given open date, then</p>
</li>
<li>
<p>Insert transactions at that date to move accumulated balances from before
   that date from the income and expenses accounts to an equity account, and
   finally</p>
</li>
<li>
<p>It removes all the transactions previous to the date and replaces them by
   opening balances entries to bring the balances to the same amount.</p>
</li>
</ol>
<p>The result is a list of entries for which the income and expense accounts
are beginning with a balance of zero, and all other accounts begin with a
transaction that brings their balance to the expected amount. All the past
has been summarized at that point.</p>
<p>An index is returned to the first transaction past the balance opening
transactions, so you can keep just those in order to render a balance sheet
for only the opening balances.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> (<code>Directives</code>) – A list of directive tuples.</p></li>
            <li><p><strong>date</strong> (<code>datetime.date</code>) – A datetime.date instance, the date at which to do this.</p></li>
            <li><p><strong>account_types</strong> (<code>AccountTypes</code>) – An instance of AccountTypes.</p></li>
            <li><p><strong>conversion_currency</strong> (<code>Currency</code>) – A string, the transfer currency to use for zero prices
on the conversion entry.</p></li>
            <li><p><strong>account_earnings</strong> (<code>Account</code>) – A string, the name of the account to transfer
previous earnings from the income statement accounts to the balance
sheet.</p></li>
            <li><p><strong>account_opening</strong> (<code>Account</code>) – A string, the name of the account in equity
to transfer previous balances from, in order to initialize account
balances at the beginning of the period. This is typically called an
opening balances account.</p></li>
            <li><p><strong>account_conversions</strong> (<code>Account</code>) – A string, the name of the equity account to
book currency conversions against.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p><code>tuple[Directives, int]</code> – A new list of entries is returned, and the index that points to the first
original transaction after the beginning date of the period. This index
can be used to generate the opening balances report, which is a balance
sheet fed with only the summarized entries.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/summarize.py</code></summary>
          <pre class="highlight"><code class="language-python">def open(
    entries: Directives,
    date: datetime.date,
    account_types: AccountTypes,
    conversion_currency: Currency,
    account_earnings: Account,
    account_opening: Account,
    account_conversions: Account,
) -&gt; tuple[Directives, int]:
    """Summarize entries before a date and transfer income/expenses to equity.

    This method essentially prepares a list of directives to contain only
    transactions that occur after a particular date. It truncates the past. To
    do so, it will

    1. Insert conversion transactions at the given open date, then

    2. Insert transactions at that date to move accumulated balances from before
       that date from the income and expenses accounts to an equity account, and
       finally

    3. It removes all the transactions previous to the date and replaces them by
       opening balances entries to bring the balances to the same amount.

    The result is a list of entries for which the income and expense accounts
    are beginning with a balance of zero, and all other accounts begin with a
    transaction that brings their balance to the expected amount. All the past
    has been summarized at that point.

    An index is returned to the first transaction past the balance opening
    transactions, so you can keep just those in order to render a balance sheet
    for only the opening balances.

    Args:
      entries: A list of directive tuples.
      date: A datetime.date instance, the date at which to do this.
      account_types: An instance of AccountTypes.
      conversion_currency: A string, the transfer currency to use for zero prices
        on the conversion entry.
      account_earnings: A string, the name of the account to transfer
        previous earnings from the income statement accounts to the balance
        sheet.
      account_opening: A string, the name of the account in equity
        to transfer previous balances from, in order to initialize account
        balances at the beginning of the period. This is typically called an
        opening balances account.
      account_conversions: A string, the name of the equity account to
        book currency conversions against.
    Returns:
      A new list of entries is returned, and the index that points to the first
      original transaction after the beginning date of the period. This index
      can be used to generate the opening balances report, which is a balance
      sheet fed with only the summarized entries.

    """
    # Insert conversion entries.
    entries = conversions(entries, account_conversions, conversion_currency, date)

    # Transfer income and expenses before the period to equity.
    entries, _ = clear(entries, date, account_types, account_earnings)

    # Summarize all the previous balances, after transferring the income and
    # expense balances, so all entries for those accounts before the begin date
    # should now disappear.
    entries, index = summarize(entries, date, account_opening)

    return entries, index
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.summarize.open_opt" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.summarize.open_opt(entries, date, options_map)</code>


<a href="#beancount.ops.summarize.open_opt" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Convenience function to open() using an options map.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/ops/summarize.py</code></summary>
          <pre class="highlight"><code class="language-python">def open_opt(
    entries: Directives, date: datetime.date, options_map: OptionsMap
) -&gt; tuple[Directives, int]:
    """Convenience function to open() using an options map."""
    account_types = options.get_account_types(options_map)
    previous_accounts = options.get_previous_accounts(options_map)
    conversion_currency = options_map["conversion_currency"]
    return open(entries, date, account_types, conversion_currency, *previous_accounts)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.summarize.summarize" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.summarize.summarize(entries, date, account_opening)</code>


<a href="#beancount.ops.summarize.summarize" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Summarize all entries before a date by replacing then with summarization entries.</p>
<p>This function replaces the transactions up to (and not including) the given
date with a opening balance transactions, one for each account. It returns
new entries, all of the transactions before the given date having been
replaced by a few summarization entries, one for each account.</p>
<p>Notes:
- Open entries are preserved for active accounts.
- The last relevant price entry for each (base, quote) pair is preserved.
- All other entries before the cutoff date are culled.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> (<code>Directives</code>) – A list of directives.</p></li>
            <li><p><strong>date</strong> (<code>datetime.date</code>) – A datetime.date instance, the cutoff date before which to summarize.</p></li>
            <li><p><strong>account_opening</strong> (<code>Account</code>) – A string, the name of the source account to book summarization
entries against.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p><code>tuple[Directives, int]</code> – The function returns a list of new entries and the integer index at which
the entries on or after the cutoff date begin.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/summarize.py</code></summary>
          <pre class="highlight"><code class="language-python">def summarize(
    entries: Directives, date: datetime.date, account_opening: Account
) -&gt; tuple[Directives, int]:
    """Summarize all entries before a date by replacing then with summarization entries.

    This function replaces the transactions up to (and not including) the given
    date with a opening balance transactions, one for each account. It returns
    new entries, all of the transactions before the given date having been
    replaced by a few summarization entries, one for each account.

    Notes:
    - Open entries are preserved for active accounts.
    - The last relevant price entry for each (base, quote) pair is preserved.
    - All other entries before the cutoff date are culled.

    Args:
      entries: A list of directives.
      date: A datetime.date instance, the cutoff date before which to summarize.
      account_opening: A string, the name of the source account to book summarization
        entries against.
    Returns:
      The function returns a list of new entries and the integer index at which
      the entries on or after the cutoff date begin.
    """
    # Compute balances at date.
    balances, index = balance_by_account(entries, date)

    # We need to insert the entries with a date previous to subsequent checks,
    # to maintain ensure the open directives show up before any transaction.
    summarize_date = date - datetime.timedelta(days=1)

    # Create summarization / opening balance entries.
    summarizing_entries = create_entries_from_balances(
        balances,
        summarize_date,
        account_opening,
        True,
        data.new_metadata("&lt;summarize&gt;", 0),
        flags.FLAG_SUMMARIZE,
        "Opening balance for '{account}' (Summarization)",
    )

    # Insert the last price entry for each commodity from before the date.
    price_entries = prices.get_last_price_entries(entries, date)

    # Gather the list of active open entries at date.
    open_entries = get_open_entries(entries, date)

    # Compute entries before the date and preserve the entries after the date.
    before_entries = sorted(
        open_entries + price_entries + summarizing_entries, key=data.entry_sortkey
    )
    after_entries = entries[index:]

    # Return a new list of entries and the index that points after the entries
    # were inserted.
    return (before_entries + after_entries), len(before_entries)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.summarize.transfer_balances" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.summarize.transfer_balances(entries, date, account_pred, transfer_account)</code>


<a href="#beancount.ops.summarize.transfer_balances" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Synthesize transactions to transfer balances from some accounts at a given date.</p>
<p>For all accounts that match the 'account_pred' predicate, create new entries
to transfer the balance at the given date from the account to the transfer
account. This is used to transfer balances from income and expenses from a
previous period to a "retained earnings" account. This is accomplished by
creating new entries.</p>
<p>Note that inserting transfers breaks any following balance checks that are
in the transferred accounts. For this reason, all balance assertion entries
following the cutoff date for those accounts are removed from the list in
output.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> (<code>Directives</code>) – A list of directives.</p></li>
            <li><p><strong>date</strong> (<code>datetime.date | None</code>) – A datetime.date instance, the date at which to make the transfer.</p></li>
            <li><p><strong>account_pred</strong> (<code>Callable[[Account], bool]</code>) – A predicate function that, given an account string, returns
true if the account is meant to be transferred.</p></li>
            <li><p><strong>transfer_account</strong> (<code>Account</code>) – A string, the name of the source account to be used on
the transfer entries to receive balances at the given date.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p><code>Directives</code> – A new list of entries, with the new transfer entries added in.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/summarize.py</code></summary>
          <pre class="highlight"><code class="language-python">def transfer_balances(
    entries: Directives,
    date: datetime.date | None,
    account_pred: Callable[[Account], bool],
    transfer_account: Account,
) -&gt; Directives:
    """Synthesize transactions to transfer balances from some accounts at a given date.

    For all accounts that match the 'account_pred' predicate, create new entries
    to transfer the balance at the given date from the account to the transfer
    account. This is used to transfer balances from income and expenses from a
    previous period to a "retained earnings" account. This is accomplished by
    creating new entries.

    Note that inserting transfers breaks any following balance checks that are
    in the transferred accounts. For this reason, all balance assertion entries
    following the cutoff date for those accounts are removed from the list in
    output.

    Args:
      entries: A list of directives.
      date: A datetime.date instance, the date at which to make the transfer.
      account_pred: A predicate function that, given an account string, returns
        true if the account is meant to be transferred.
      transfer_account: A string, the name of the source account to be used on
        the transfer entries to receive balances at the given date.
    Returns:
      A new list of entries, with the new transfer entries added in.
    """
    # Don't bother doing anything if there are no entries.
    if not entries:
        return entries

    # Compute balances at date.
    balances, index = balance_by_account(entries, date)

    # Filter out to keep only the accounts we want.
    transfer_balances = {
        account: balance for account, balance in balances.items() if account_pred(account)
    }

    # We need to insert the entries at the end of the previous day.
    if date:
        transfer_date = date - datetime.timedelta(days=1)
    else:
        transfer_date = entries[-1].date

    # Create transfer entries.
    transfer_entries = create_entries_from_balances(
        transfer_balances,
        transfer_date,
        transfer_account,
        False,
        data.new_metadata("&lt;transfer_balances&gt;", 0),
        flags.FLAG_TRANSFER,
        "Transfer balance for '{account}' (Transfer balance)",
    )

    # Remove balance assertions that occur after a transfer on an account that
    # has been transferred away; they would break.
    after_entries = [
        entry
        for entry in entries[index:]
        if not (isinstance(entry, data.Balance) and entry.account in transfer_balances)
    ]

    # Split the new entries in a new list.
    return entries[:index] + transfer_entries + after_entries
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.summarize.truncate" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.summarize.truncate(entries, date)</code>


<a href="#beancount.ops.summarize.truncate" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Filter out all the entries at and after date. Returns a new list of entries.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> (<code>Directives</code>) – A sorted list of directives.</p></li>
            <li><p><strong>date</strong> (<code>datetime.date</code>) – A datetime.date instance.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p><code>Directives</code> – A truncated list of directives.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/summarize.py</code></summary>
          <pre class="highlight"><code class="language-python">def truncate(entries: Directives, date: datetime.date) -&gt; Directives:
    """Filter out all the entries at and after date. Returns a new list of entries.

    Args:
      entries: A sorted list of directives.
      date: A datetime.date instance.
    Returns:
      A truncated list of directives.
    """
    index = bisect_key.bisect_left_with_key(entries, date, key=lambda entry: entry.date)
    return entries[:index]
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="beancount.ops.validation" class="doc doc-heading">
        <code>beancount.ops.validation</code>



<a href="#beancount.ops.validation" class="headerlink" title="Permanent link"></a></h2>

    <div class="doc doc-contents ">

      <p>Validation checks.</p>
<p>These checks are intended to be run after all the plugins have transformed the
list of entries, just before serving them or generating reports from them. The
idea is to ensure a reasonable set of invariants and generate errors if those
invariants are violated. They are not sanity checks--user data is subject to
constraints which are hopefully detected here and which will result in errors
trickled up to the user.</p>



  <div class="doc doc-children">













  <div class="doc doc-object doc-class">



<h3 id="beancount.ops.validation.ValidationError" class="doc doc-heading">
        <code>
beancount.ops.validation.ValidationError            (<span title="tuple">tuple</span>)
        </code>



<a href="#beancount.ops.validation.ValidationError" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>An error from one of the checks.</p>




  <div class="doc doc-children">












  <div class="doc doc-object doc-method">



<h4 id="beancount.ops.validation.ValidationError.__getnewargs__" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.validation.ValidationError.__getnewargs__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.ops.validation.ValidationError.__getnewargs__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return self as a plain tuple.  Used by copy and pickle.</p>

        <details class="quote">
          <summary>Source code in <code>beancount/ops/validation.py</code></summary>
          <pre class="highlight"><code class="language-python">def __getnewargs__(self):
    'Return self as a plain tuple.  Used by copy and pickle.'
    return _tuple(self)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.ops.validation.ValidationError.__new__" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.validation.ValidationError.__new__(_cls, source, message, entry)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
      <small class="doc doc-property doc-property-staticmethod"><code>staticmethod</code></small>
  </span>

<a href="#beancount.ops.validation.ValidationError.__new__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Create new instance of ValidationError(source, message, entry)</p>

    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="beancount.ops.validation.ValidationError.__repr__" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.validation.ValidationError.__repr__(self)</code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#beancount.ops.validation.ValidationError.__repr__" class="headerlink" title="Permanent link"></a></h4>

    <div class="doc doc-contents ">

      <p>Return a nicely formatted representation string</p>

        <details class="quote">
          <summary>Source code in <code>beancount/ops/validation.py</code></summary>
          <pre class="highlight"><code class="language-python">def __repr__(self):
    'Return a nicely formatted representation string'
    return self.__class__.__name__ + repr_fmt % self
</code></pre>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>




  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.validation.validate" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.validation.validate(entries, options_map, log_timings=None, extra_validations=None)</code>


<a href="#beancount.ops.validation.validate" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Perform all the standard checks on parsed contents.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> – A list of directives.</p></li>
            <li><p><strong>unused_options_map</strong> – An options map.</p></li>
            <li><p><strong>log_timings</strong> – An optional function to use for logging the time of individual
operations.</p></li>
            <li><p><strong>extra_validations</strong> – A list of extra validation functions to run after loading
this list of entries.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A list of new errors, if any were found.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/validation.py</code></summary>
          <pre class="highlight"><code class="language-python">def validate(entries, options_map, log_timings=None, extra_validations=None):
    """Perform all the standard checks on parsed contents.

    Args:
      entries: A list of directives.
      unused_options_map: An options map.
      log_timings: An optional function to use for logging the time of individual
        operations.
      extra_validations: A list of extra validation functions to run after loading
        this list of entries.
    Returns:
      A list of new errors, if any were found.
    """
    validation_tests = VALIDATIONS
    if extra_validations:
        validation_tests += extra_validations

    # Run various validation routines define above.
    errors = []
    for validation_function in validation_tests:
        with misc_utils.log_time(
            "function: {}".format(validation_function.__name__), log_timings, indent=2
        ):
            new_errors = validation_function(entries, options_map)
        errors.extend(new_errors)

    return errors
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.validation.validate_active_accounts" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.validation.validate_active_accounts(entries, unused_options_map)</code>


<a href="#beancount.ops.validation.validate_active_accounts" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Check that all references to accounts occurs on active accounts.</p>
<p>We basically check that references to accounts from all directives other
than Open and Close occur at dates the open-close interval of that account.
This should be good for all of the directive types where we can extract an
account name.</p>
<p>Note that this is more strict a check than comparing the dates: we actually
check that no references to account are made on the same day before the open
directive appears for that account. This is a nice property to have, and is
supported by our custom sorting routine that will sort open entries before
transaction entries, given the same date.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> – A list of directives.</p></li>
            <li><p><strong>unused_options_map</strong> – An options map.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A list of new errors, if any were found.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/validation.py</code></summary>
          <pre class="highlight"><code class="language-python">def validate_active_accounts(entries, unused_options_map):
    """Check that all references to accounts occurs on active accounts.

    We basically check that references to accounts from all directives other
    than Open and Close occur at dates the open-close interval of that account.
    This should be good for all of the directive types where we can extract an
    account name.

    Note that this is more strict a check than comparing the dates: we actually
    check that no references to account are made on the same day before the open
    directive appears for that account. This is a nice property to have, and is
    supported by our custom sorting routine that will sort open entries before
    transaction entries, given the same date.

    Args:
      entries: A list of directives.
      unused_options_map: An options map.
    Returns:
      A list of new errors, if any were found.
    """
    error_pairs = []
    active_set = set()
    opened_accounts = set()
    for entry in entries:
        if isinstance(entry, data.Open):
            active_set.add(entry.account)
            opened_accounts.add(entry.account)

        elif isinstance(entry, data.Close):
            active_set.discard(entry.account)

        else:
            for account in getters.get_entry_accounts(entry):
                if account not in active_set:
                    # Allow document and note directives that occur after an
                    # account is closed.
                    if isinstance(entry, ALLOW_AFTER_CLOSE) and account in opened_accounts:
                        continue

                    # Register an error to be logged later, with an appropriate
                    # message.
                    error_pairs.append((account, entry))

    # Refine the error message to disambiguate between the case of an account
    # that has never been seen and one that was simply not active at the time.
    errors = []
    for account, entry in error_pairs:
        if account in opened_accounts:
            message = "Invalid reference to inactive account '{}'".format(account)
        else:
            message = "Invalid reference to unknown account '{}'".format(account)
        errors.append(ValidationError(entry.meta, message, entry))

    return errors
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.validation.validate_check_transaction_balances" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.validation.validate_check_transaction_balances(entries, options_map)</code>


<a href="#beancount.ops.validation.validate_check_transaction_balances" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Check again that all transaction postings balance, as users may have
transformed transactions.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> – A list of directives.</p></li>
            <li><p><strong>unused_options_map</strong> – An options map.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A list of new errors, if any were found.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/validation.py</code></summary>
          <pre class="highlight"><code class="language-python">def validate_check_transaction_balances(entries, options_map):
    """Check again that all transaction postings balance, as users may have
    transformed transactions.

    Args:
      entries: A list of directives.
      unused_options_map: An options map.
    Returns:
      A list of new errors, if any were found.
    """
    # Note: this is a bit slow; we could limit our checks to the original
    # transactions by using the hash function in the loader.
    errors = []
    for entry in entries:
        if isinstance(entry, Transaction):
            # IMPORTANT: This validation is _crucial_ and cannot be skipped.
            # This is where we actually detect and warn on unbalancing
            # transactions. This _must_ come after the user routines, because
            # unbalancing input is legal, as those types of transactions may be
            # "fixed up" by a user-plugin. In other words, we want to allow
            # users to input unbalancing transactions as long as the final
            # transactions objects that appear on the stream (after processing
            # the plugins) are balanced. See {9e6c14b51a59}.
            #
            # Detect complete sets of postings that have residual balance;
            residual = interpolate.compute_residual(entry.postings)
            tolerances = interpolate.infer_tolerances(entry.postings, options_map)
            if not residual.is_small(tolerances):
                errors.append(
                    ValidationError(
                        entry.meta,
                        "Transaction does not balance: {}".format(residual),
                        entry,
                    )
                )

    return errors
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.validation.validate_currency_constraints" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.validation.validate_currency_constraints(entries, options_map)</code>


<a href="#beancount.ops.validation.validate_currency_constraints" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Check the currency constraints from account open declarations.</p>
<p>Open directives admit an optional list of currencies that specify the only
types of commodities that the running inventory for this account may
contain. This function checks that all postings are only made in those
commodities.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> – A list of directives.</p></li>
            <li><p><strong>unused_options_map</strong> – An options map.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A list of new errors, if any were found.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/validation.py</code></summary>
          <pre class="highlight"><code class="language-python">def validate_currency_constraints(entries, options_map):
    """Check the currency constraints from account open declarations.

    Open directives admit an optional list of currencies that specify the only
    types of commodities that the running inventory for this account may
    contain. This function checks that all postings are only made in those
    commodities.

    Args:
      entries: A list of directives.
      unused_options_map: An options map.
    Returns:
      A list of new errors, if any were found.
    """

    # Get all the open entries with currency constraints.
    open_map = {
        entry.account: entry
        for entry in entries
        if isinstance(entry, Open) and entry.currencies
    }

    errors = []
    for entry in entries:
        if not isinstance(entry, Transaction):
            continue

        for posting in entry.postings:
            # Look up the corresponding account's valid currencies; skip the
            # check if there are none specified.
            try:
                open_entry = open_map[posting.account]
                valid_currencies = open_entry.currencies
                if not valid_currencies:
                    continue
            except KeyError:
                continue

            # Perform the check.
            if posting.units.currency not in valid_currencies:
                errors.append(
                    ValidationError(
                        entry.meta,
                        "Invalid currency {} for account '{}'".format(
                            posting.units.currency, posting.account
                        ),
                        entry,
                    )
                )

    return errors
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.validation.validate_data_types" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.validation.validate_data_types(entries, options_map)</code>


<a href="#beancount.ops.validation.validate_data_types" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Check that all the data types of the attributes of entries are as expected.</p>
<p>Users are provided with a means to filter the list of entries. They're able to
write code that manipulates those tuple objects without any type constraints.
With discipline, this mostly works, but I know better: check, just to make sure.
This routine checks all the data types and assumptions on entries.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> – A list of directives.</p></li>
            <li><p><strong>unused_options_map</strong> – An options map.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A list of new errors, if any were found.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/validation.py</code></summary>
          <pre class="highlight"><code class="language-python">def validate_data_types(entries, options_map):
    """Check that all the data types of the attributes of entries are as expected.

    Users are provided with a means to filter the list of entries. They're able to
    write code that manipulates those tuple objects without any type constraints.
    With discipline, this mostly works, but I know better: check, just to make sure.
    This routine checks all the data types and assumptions on entries.

    Args:
      entries: A list of directives.
      unused_options_map: An options map.
    Returns:
      A list of new errors, if any were found.
    """
    errors = []
    for entry in entries:
        try:
            data.sanity_check_types(
                entry, options_map["allow_deprecated_none_for_tags_and_links"]
            )
        except AssertionError as exc:
            errors.append(
                ValidationError(entry.meta, "Invalid data types: {}".format(exc), entry)
            )
    return errors
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.validation.validate_documents_paths" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.validation.validate_documents_paths(entries, options_map)</code>


<a href="#beancount.ops.validation.validate_documents_paths" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Check that all filenames in resolved Document entries are absolute filenames.</p>
<p>The processing of document entries is assumed to result in absolute paths.
Relative paths are resolved at the parsing stage and at point we want to
make sure we don't have to do any further processing on them.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> – A list of directives.</p></li>
            <li><p><strong>unused_options_map</strong> – An options map.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A list of new errors, if any were found.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/validation.py</code></summary>
          <pre class="highlight"><code class="language-python">def validate_documents_paths(entries, options_map):
    """Check that all filenames in resolved Document entries are absolute filenames.

    The processing of document entries is assumed to result in absolute paths.
    Relative paths are resolved at the parsing stage and at point we want to
    make sure we don't have to do any further processing on them.

    Args:
      entries: A list of directives.
      unused_options_map: An options map.
    Returns:
      A list of new errors, if any were found.
    """
    return [
        ValidationError(entry.meta, "Invalid relative path for entry", entry)
        for entry in entries
        if (isinstance(entry, Document) and not path.isabs(entry.filename))
    ]
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.validation.validate_duplicate_balances" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.validation.validate_duplicate_balances(entries, unused_options_map)</code>


<a href="#beancount.ops.validation.validate_duplicate_balances" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Check that balance entries occur only once per day.</p>
<p>Because we do not support time, and the declaration order of entries is
meant to be kept irrelevant, two balance entries with different amounts
should not occur in the file. We do allow two identical balance assertions,
however, because this may occur during import.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> – A list of directives.</p></li>
            <li><p><strong>unused_options_map</strong> – An options map.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A list of new errors, if any were found.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/validation.py</code></summary>
          <pre class="highlight"><code class="language-python">def validate_duplicate_balances(entries, unused_options_map):
    """Check that balance entries occur only once per day.

    Because we do not support time, and the declaration order of entries is
    meant to be kept irrelevant, two balance entries with different amounts
    should not occur in the file. We do allow two identical balance assertions,
    however, because this may occur during import.

    Args:
      entries: A list of directives.
      unused_options_map: An options map.
    Returns:
      A list of new errors, if any were found.
    """
    errors = []

    # Mapping of (account, currency, date) to Balance entry.
    balance_entries = {}
    for entry in entries:
        if not isinstance(entry, data.Balance):
            continue

        key = (entry.account, entry.amount.currency, entry.date)
        try:
            previous_entry = balance_entries[key]
            if entry.amount != previous_entry.amount:
                errors.append(
                    ValidationError(
                        entry.meta,
                        "Duplicate balance assertion with different amounts",
                        entry,
                    )
                )
        except KeyError:
            balance_entries[key] = entry

    return errors
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.validation.validate_duplicate_commodities" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.validation.validate_duplicate_commodities(entries, unused_options_map)</code>


<a href="#beancount.ops.validation.validate_duplicate_commodities" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Check that commodity entries are unique for each commodity.</p>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> – A list of directives.</p></li>
            <li><p><strong>unused_options_map</strong> – An options map.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A list of new errors, if any were found.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/validation.py</code></summary>
          <pre class="highlight"><code class="language-python">def validate_duplicate_commodities(entries, unused_options_map):
    """Check that commodity entries are unique for each commodity.

    Args:
      entries: A list of directives.
      unused_options_map: An options map.
    Returns:
      A list of new errors, if any were found.
    """
    errors = []

    # Mapping of (account, currency, date) to Balance entry.
    commodity_entries = {}
    for entry in entries:
        if not isinstance(entry, data.Commodity):
            continue

        key = entry.currency
        try:
            previous_entry = commodity_entries[key]
            if previous_entry:
                errors.append(
                    ValidationError(
                        entry.meta,
                        "Duplicate commodity directives for '{}'".format(key),
                        entry,
                    )
                )
        except KeyError:
            commodity_entries[key] = entry

    return errors
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="beancount.ops.validation.validate_open_close" class="doc doc-heading">
<code class="highlight language-python">beancount.ops.validation.validate_open_close(entries, unused_options_map)</code>


<a href="#beancount.ops.validation.validate_open_close" class="headerlink" title="Permanent link"></a></h3>

    <div class="doc doc-contents ">

      <p>Check constraints on open and close directives themselves.</p>
<p>This method checks two kinds of constraints:</p>
<ol>
<li>
<p>An open or a close directive may only show up once for each account. If a
   duplicate is detected, an error is generated.</p>
</li>
<li>
<p>Close directives may only appear if an open directive has been seen
   previously (chronologically).</p>
</li>
<li>
<p>The date of close directives must be strictly greater than their
   corresponding open directive.</p>
</li>
</ol>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li><p><strong>entries</strong> – A list of directives.</p></li>
            <li><p><strong>unused_options_map</strong> – An options map.</p></li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
    <th class="field-name">Returns:</th>
    <td class="field-body">
        <ul class="first simple">
          <li><p>A list of new errors, if any were found.</p></li>
        </ul>
    </td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>beancount/ops/validation.py</code></summary>
          <pre class="highlight"><code class="language-python">def validate_open_close(entries, unused_options_map):
    """Check constraints on open and close directives themselves.

    This method checks two kinds of constraints:

    1. An open or a close directive may only show up once for each account. If a
       duplicate is detected, an error is generated.

    2. Close directives may only appear if an open directive has been seen
       previously (chronologically).

    3. The date of close directives must be strictly greater than their
       corresponding open directive.

    Args:
      entries: A list of directives.
      unused_options_map: An options map.
    Returns:
      A list of new errors, if any were found.
    """
    errors = []
    open_map = {}
    close_map = {}
    for entry in entries:
        if isinstance(entry, Open):
            if entry.account in open_map:
                errors.append(
                    ValidationError(
                        entry.meta,
                        "Duplicate open directive for {}".format(entry.account),
                        entry,
                    )
                )
            else:
                open_map[entry.account] = entry

        elif isinstance(entry, Close):
            if entry.account in close_map:
                errors.append(
                    ValidationError(
                        entry.meta,
                        "Duplicate close directive for {}".format(entry.account),
                        entry,
                    )
                )
            else:
                try:
                    open_entry = open_map[entry.account]
                    if entry.date &lt; open_entry.date:
                        errors.append(
                            ValidationError(
                                entry.meta,
                                "Internal error: closing date for {} "
                                "appears before opening date".format(entry.account),
                                entry,
                            )
                        )
                except KeyError:
                    errors.append(
                        ValidationError(
                            entry.meta,
                            "Unopened account {} is being closed".format(entry.account),
                            entry,
                        )
                    )

                close_map[entry.account] = entry

    return errors
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>




  </div>

    </div>

  </div>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="beancount.parser.html" class="btn btn-neutral float-right" title="beancount.parser">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="beancount.loader.html" class="btn btn-neutral" title="beancount.loader"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="beancount.loader.html" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="beancount.parser.html" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
